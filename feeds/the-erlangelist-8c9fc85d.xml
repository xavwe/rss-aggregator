<?xml version="1.0" encoding="utf-8"?><rss version="2.0"><channel><title>The Erlangelist</title><link>https://raw.githubusercontent.com/xavwe/rss-aggregator/refs/heads/main/feeds/the-erlangelist-8c9fc85d.xml</link><description>Archived feed from https://www.theerlangelist.com/rss</description><item><title>Sequences</title><link>http://theerlangelist.com//article/sequences</link><description><![CDATA[<h1>Sequences</h1>
<h4 class="right">2020-12-14</h4>

<div class="article-body">
<p>
It was the first day of my first Erlang-based system in production. I’ve invested some sensible amount of time to test and stabilize it. I’s were dotted, t’s were crossed and I felt confident that it would work reasonably well. The system broke in production within the first few hours of its life.</p>
<p>
The breakage was caused by the excessive usage of the <code class="inline">++</code> operator. I was iteratively building a large list by appending new chunks to its end, which is extremely inefficient in Erlang. Why did I do it then? Because I didn’t know better :-) I incorrectly assumed, based on my experience with other languages, that in the expression <code class="inline">list_a ++ list_b</code> only <code class="inline">list_b</code> is being iterated (which would have been fine).</p>
<p>
This incident took me down the path of prepends, right folds, and reverses, and taught me that dealing with sequences in Erlang is very different compared to what I’ve seen so far. After a couple of other issues I realized that choosing a data structure to represent a sequence is highly context-sensitive in Erlang, much more than in many other languages I’ve seen until that point. For better or worse (probably worse, more on that later), in BEAM languages we’re lacking a solid all-rounder, a structure which might be a sensible default choice for most cases.</p>
<p>
For the purpose of this article, the term <em>sequence</em> means an ordered collection of things. For example, a list <code class="inline">[:foo, :bar, :baz]</code> is a sequence because the structure preserves the information that foo comes before bar, which in turn comes before baz. On the other hand, a <code class="inline">MapSet</code> containing those same elements will not preserve that order (in fact, the internal order in this particular case will be bar, baz, foo).</p>
<p>
Sequences can be used in a bunch of different ways. For example sometimes we might need to walk it from start to end, in the given order. Other times we might want to work on elements based on their position (e.g. get the 3rd element, or replace the fifth one). This is known as a <em>random-access</em> operation, and it’s going to play an important role in choosing an optimal data structure to represent our sequence.</p>
<p>
In this post I’ll go over a couple (but not all) of data structures that can be used to model a sequence. In particular we’ll take a look at lists, arrays, maps, and tuples, discuss their trade-offs, and compare their performances through a set of simple and fairly naive benchmarks. The results we’ll obtain won’t exactly be scientific-paper grade, but we should get some basic intuition about which structure works best in different scenarios :-)</p>
<h2>
Lists</h2>
<p>
A frequent choice for representing a sequence, lists deceptively resemble arrays from many other languages. However, lists are nothing like arrays, and if you treat them as such you might end up in problems. Think of lists as <a href="https://en.wikipedia.org/wiki/Linked_list">singly linked lists</a>, and the trade-offs should become clearer.</p>
<p>
Prepending an element to the list is very fast and creates zero garbage, which is the reason why lists are the fastest option for iteratively building a sequence the size of which is not known upfront. The same holds for reading and popping the list head (the first element). Getting the next element is a matter of a single pointer dereference, so walking the entire list (or some prefix of it) is also very efficient. Finally, it’s worth noting that lists receive some syntactic love from the language, most notably with first class support for pattern matching, which often leads to a nice expressive code.</p>
<p>
These is pretty much the complete list of things lists are good at. They basically suck at everything else :-) Random-access read (fetching the n-th element) boils down to a sequential scan. Random-access writes will additionally have to rebuild the entire prefix up to and including the element which is changed. The <code class="inline">length</code> function (and consequently also <code class="inline">Enum.count</code>) will walk the entire list to count the number of elements.</p>
<p>
Consequently, lists are not a general purpose sequence data structure, and treating them as such may get you into trouble. To be clear, doing an occasional iterative operation, e.g. <code class="inline">Enum.at</code>, <code class="inline">length</code>, or even <code class="inline">List.replace_at</code> doesn’t necessarily have to be a problem, especially if the list is small. On the other hand, performing frequent random-access operations against a larger list inside a tight loop is probably best avoided.</p>
<h2>
Arrays</h2>
<p>
Somewhat less well-known, the <a href="https://erlang.org/doc/man/array.html">:array module</a> from the Erlang’s stdlib offers fast random-access operations, and can also be used to handle sparse arrays. The memory overhead of an array is also significantly smaller compared to list. Arrays are the only data structure presented here which is completely implemented in Erlang code. Internally, arrays are represented as a tree of small tuples. As we’ll see from the benchmarks, small tuples have excellent random-access read &amp; write performance. Relying on them allows <code class="inline">:array</code> to offer pretty good all-round performance. I wonder if the results would be even better if <code class="inline">:array</code> was implemented natively.</p>
<h2>
Maps</h2>
<p>
A sequence can be represented with a map where keys are element indices. Here’s a basic sketch:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># initialization</span><span class="w">
</span><span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8459718200-1">%{</span><span class="p" data-group-id="8459718200-1">}</span><span class="w">

</span><span class="c1"># append</span><span class="w">
</span><span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="8459718200-2">(</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">map_size</span><span class="p" data-group-id="8459718200-3">(</span><span class="n">seq</span><span class="p" data-group-id="8459718200-3">)</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="8459718200-2">)</span><span class="w">

</span><span class="c1"># random-access read</span><span class="w">
</span><span class="nc">Map</span><span class="o">.</span><span class="n">fetch!</span><span class="p" data-group-id="8459718200-4">(</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="8459718200-4">)</span><span class="w">

</span><span class="c1"># random-access write</span><span class="w">
</span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="8459718200-5">(</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">new_value</span><span class="p" data-group-id="8459718200-5">)</span><span class="w">

</span><span class="c1"># sequential walk</span><span class="w">
</span><span class="nc">Enum</span><span class="o">.</span><span class="n">each</span><span class="p" data-group-id="8459718200-6">(</span><span class="w">
  </span><span class="mi">0</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="8459718200-7">(</span><span class="n">map_size</span><span class="p" data-group-id="8459718200-8">(</span><span class="n">seq</span><span class="p" data-group-id="8459718200-8">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="8459718200-7">)</span><span class="p">,</span><span class="w">
  </span><span class="k" data-group-id="8459718200-9">fn</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">do_something_with</span><span class="p" data-group-id="8459718200-10">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">fetch!</span><span class="p" data-group-id="8459718200-11">(</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="8459718200-11">)</span><span class="p" data-group-id="8459718200-10">)</span><span class="w"> </span><span class="k" data-group-id="8459718200-9">end</span><span class="w">
</span><span class="p" data-group-id="8459718200-6">)</span></code></pre>
<p>
At first glance using a general-purpose k-v might seem hacky, but in my experience it can work quite well for moderately sized sequences. Map-powered sequences are my frequent choice if random-access operations, especially reads, are called for, and I’ve had good experiences with them, not only for basic one-dimensional sequences, but also for matrices (e.g. by using <code class="inline">{x, y}</code> for keys) and sparse arrays.</p>
<p>
On the flip side, maps will suck where lists excel. Building a sequence incrementally is much slower. The same holds for sequential traversal through the entire sequence. However, maps will suck at these things much less than lists suck at random access. In addition, building a sequence and walking it are frequently one-off operations, while random access is more often performed inside a loop. Therefore, maps may provide a better overall performance, but only if you need random access. Otherwise, it’s probably better to stick with lists.</p>
<p>
It’s also worth mentioning that maps will introduce a significantly higher memory overhead (about 3x more than arrays)</p>
<p>
I personally consider maps to be an alternative to arrays. More often than not I start with maps for a couple of reasons:</p>
<ol>
  <li>
Maps are slightly faster at reading from “medium sized” sequences (around 10k elements).  </li>
  <li>
They can elegantly handle a wider range of scenarios (e.g. matrices, negative indices, prepends).  </li>
  <li>
The interface is more “Elixiry”, while <code class="inline">:array</code> functions (like many other Erlang functions) take the subject (array) as the last argument.  </li>
</ol>
<h2>
Tuples</h2>
<p>
Tuples are typically used to throw a couple of values together, e.g. in Erlang records, keywords/proplists, or ok/error tuples. However, they can also be an interesting choice to handle random-access reads from a constant sequence, i.e. a sequence that, once built, doesn’t change. Here’s how we can implement a tuple-based sequence:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># We&#39;re building the complete list (which is fast), and then convert it into</span><span class="w">
</span><span class="c1"># a tuple with a single fast call.</span><span class="w">
</span><span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">build_list</span><span class="p" data-group-id="6932210718-1">(</span><span class="p" data-group-id="6932210718-1">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">List</span><span class="o">.</span><span class="n">to_tuple</span><span class="p" data-group-id="6932210718-2">(</span><span class="p" data-group-id="6932210718-2">)</span><span class="w">

</span><span class="c1"># random-access read</span><span class="w">
</span><span class="n">elem</span><span class="p" data-group-id="6932210718-3">(</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="6932210718-3">)</span><span class="w">

</span><span class="c1"># iteration</span><span class="w">
</span><span class="nc">Enum</span><span class="o">.</span><span class="n">each</span><span class="p" data-group-id="6932210718-4">(</span><span class="w">
  </span><span class="mi">0</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="6932210718-5">(</span><span class="n">tuple_size</span><span class="p" data-group-id="6932210718-6">(</span><span class="n">seq</span><span class="p" data-group-id="6932210718-6">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6932210718-5">)</span><span class="p">,</span><span class="w">
  </span><span class="k" data-group-id="6932210718-7">fn</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">do_something_with</span><span class="p" data-group-id="6932210718-8">(</span><span class="n">elem</span><span class="p" data-group-id="6932210718-9">(</span><span class="n">seq</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="6932210718-9">)</span><span class="p" data-group-id="6932210718-8">)</span><span class="w"> </span><span class="k" data-group-id="6932210718-7">end</span><span class="w">
</span><span class="p" data-group-id="6932210718-4">)</span></code></pre>
<p>
As we’ll see from the benchmark, random-access read from a tuple is a very fast operation. Moreover, compared to other structures, the memory overhead of tuples is going to be much smaller (about 20% less than arrays, 2x less than lists, and 3.7x less than maps). On the flip side, modifying a single element copies the entire tuple, and will therefore be pretty slow, except for very small tuples. Finally, It’s also worth mentioning that <a href="http://erlang.org/doc/efficiency_guide/advanced.html#system-limits">maximum tuple size is 16,777,215 elements</a>, so tuples won’t work for unbounded collections.</p>
<h2>
Benchmarking</h2>
<p>
We’ll compare the performance of these different data structures in the following scenarios: iterative building, sequential walk, random-access reads and writes. The benching code can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/examples/seq">here</a>. The results have been obtained on a i7-8565U CPU.</p>
<p>
Before we start analyzing the results, I want to make a couple of important points. First, these benches are not very detailed, so don’t consider them as some ultimate proof of anything.</p>
<p>
Moreover, bear in mind that data structure is only a part of the story. Often the bulk of the processing will take place outside of the generic data structure code. For example while iterating a sequence the processing time of each element will likely dominate over the iteration time, so a switch to a more efficient data structure might not lead to any relevant improvements in the grand scheme of things.</p>
<p>
Sometimes a problem-specific optimization can lead to much more drastic improvements. For example, suppose the program is doing 1M random-access operations. If, taking the specific problem into account, we can change the algorithm to reduce that to e.g. 20 operations, we could get radical improvements, to the point where the choice of the data structure isn’t relevant anymore.</p>
<p>
Therefore, treat these results carefully, and always measure in the context of the actual problem. Just because A is 1000x faster than B, doesn’t mean that replacing B with A will give you any significant performance gains.</p>
<h2>
Building a sequence</h2>
<p>
Let’s first compare the performance of building a sequence incrementally. Here are the results:</p>
<p>
  <img src="/images/seq_build.png" alt="Incremental build benchmark" />
</p>
<p>
The measurements are performed on various sizes: 1, 2, 3, …, 10, 20, 30, …, 100, …, 1M. For the sake of better identification of each measurement, a few points on each line are highlighted (circles, squares, …).</p>
<p>
The results demonstrate that lists are the fastest option for dynamically building a sequence. The 2nd- and the 3rd- best option also owe their results to lists. In both of these cases we first build a list, and then convert it to a target structure with <code class="inline">List.to_tuple</code> and <code class="inline">:array.from_list</code> respectively. <code class="inline">List.to_tuple</code> is particularly fast since it’s implemented natively. It takes a few milliseconds to transform a list of million elements into a tuple on my machine.</p>
<p>
Gradually growing arrays or maps is going to be slower, with maps being particularly bad, taking almost a second to build a sequence of 1M elements. However, I’m usually not too worried about it. In the lower-to-medium range (up to about 10k elements) growing a map will be reasonably fast. When it comes to larger sequences, I personally try to avoid them if possible. If I need to deal with hundreds of thousand or millions of “things”, I usually look for other options, such as streaming or chunking, to keep the memory usage stable. Another alternative are ETS tables, which might work faster in such cases since they are non-persistent and reside off-heap (I discussed this a while ago <a href="https://www.theerlangelist.com/article/reducing_maximum_latency">in this post</a>).</p>
<h3>
Memory usage</h3>
<p>
It’s also worth checking the memory usage of each structure. I used <code class="inline">:erts_debug.size</code> on a sequence of 100k <code class="inline">:ok</code> elements, and got the following results:</p>
<ul>
  <li>
tuple: 100k words  </li>
  <li>
array: 123k words  </li>
  <li>
list:  200k words  </li>
  <li>
map: 377k words  </li>
</ul>
<p>
Unsurprisingly, tuples have the smallest footprint, with arrays adding some 20% extra overhead. A list will require one additional word per each item, and finally a map will take up quite a lot of extra space.</p>
<h2>
Walking a collection</h2>
<p>
Next up let’s see how long it takes to sequentially walk through the entire sequence. Note that tuples and maps don’t support ordered traversal, so we have to resort to random-access reads (get the 1st element, then the 2nd, …).</p>
<p>
This test uses a plain tail recursion to sum all the elements in the sequence. The times therefore include more than just the iteration, but the overhead should be small enough not to affect the results:</p>
<p>
  <img src="/images/seq_walk.png" alt="Sequential walk benchmark" />
</p>
<p>
Here we get the same ranking, with lists coming on top. Coupled with the previous benchmark this demonstrates the strengths of lists. You’re gonna have a hard time finding another structure which is as fast as lists at incremental growth and sequential iteration for sequences of an unknown size. If that is your nail, lists are probably your best hammer.</p>
<p>
Tuples come very close, but growing them dynamically will still require building a list. That said, it’s worth noting that walking a tuple-powered sequence may even beat lists in some circumstances. The thing is that you can scan the tuple equally fast in both directions (front to end, or end to front). On the other hand, walking the list in the reverse order will require a body recursion which will add a bit of extra overhead, just enough to be slower than a tail-recursive tuple iteration.</p>
<p>
Arrays also show pretty good performance owing to their first-class support for iterations through <code class="inline">foldl</code> and <code class="inline">foldr</code>. Both perform equally well, so an array can also be efficiently traversed in both directions. On the flip side, both functions are eager, and there’s no support for lazy iteration. In such cases you’ll either have to use positional reads or otherwise resort to throwing a result from inside the fold for early exit.</p>
<p>
Maps are significantly slower than the rest of the pack, but not necessarily terrible in the medium range, which we can see if we plot the same data using logarithmic scale with base 10:</p>
<p>
  <img src="/images/seq_walk_log.png" alt="Sequential walk benchmark (logscale)" />
</p>
<p>
Up to 10k elements, a full sequential map traversal will run in less than one millisecond. This is still slower than other data structures, but it might suffice in many cases. It’s also worth noting that maps can be iterated much faster using <a href="https://erlang.org/doc/man/maps.html#iterator-1">:maps.iterator</a> and <a href="https://erlang.org/doc/man/maps.html#next-1">:maps.next</a>. Such iteration is as fast as array iteration, but it’s not ordered, and is therefore not included in this benchmark.</p>
<h2>
Random-access reads</h2>
<p>
Let’s turn our attention to random-access reads. This benchmark measures the time it takes to read every element through a positional read.  Here are the results:</p>
<p>
  <img src="/images/seq_read.png" alt="Random-access read benchmark" />
</p>
<p>
Note that y-axis value represents the time it takes to read the entire sequence, not just one element, which is for tuples and maps effectively the same as the sequential walk benchmark.</p>
<p>
Also note that this graph uses log-10 scale for both axes, which allows us to better see the results for smaller sequences. This scale affects the shape of the curves. Note how the green line starts to ascend faster in the hundreds area. On a linear scale this would look like a standard U-shaped curve skyrocketing near the left edge of the graph.</p>
<p>
This benchmark confirms that tuples are the fastest option for positional reads. Given how well they did in the previous two tests, they turn out to be quite a compelling option. This will change in the final test, but it’s worth noting that as long as you don’t need writes, tuples can give you fast random-access reads and sequential scans (both ways), plus they have the smallest memory footprint of the pack (though to build a tuple you’ll need to create a list first).</p>
<p>
The 2nd and the 3rd place are occupied by maps and arrays. In the low-to-mid range maps are somewhat faster, while arrays take over in the lower 100k area. In throughput terms, you can expect about few million reads/sec from arrays/maps, and a few dozen million reads/sec from tuples.</p>
<p>
The results for lists are a great example of why we should think about performance contextually. For larger sequences lists are terrible at random access. However, for very small collections (10 elements), the difference is less striking and absolute times might often be acceptable. Of course, if you need to do a lot of such reads, other options will still work better, but it’s still possible that lists might suffice. For example, keyword lists in Elixir are lists, and they work just fine in practice.</p>
<h2>
Random-access writes</h2>
<p>
Finally, let’s see how these structures perform at random-access write operations:</p>
<p>
  <img src="/images/seq_write.png" alt="Random-access write benchmark" />
</p>
<p>
Just like with reads, this graph uses log-10 scale for both axes, with y-axis representing the time it takes to write to every element of the sequence.</p>
<p>
On the tiny end (10 elements), tuples are the fastest. This is probably why they are the prevalent option in Erlang for bundling small fixed-size unrelated data (e.g. Erlang records are tuples). I’ve had a few situations where replacing a small map with a tuple (e.g. <code class="inline">%{x: x, y: y}</code> with <code class="inline">{x, y}</code>) brought significant improvements. That said, the difference usually doesn’t matter, so when I model structured data I still start with maps, using tuples only in exceptional situation where maximum speed is needed.</p>
<p>
As soon as the sequence becomes slightly larger, the performance of tuples degrades significantly, while arrays and maps become much better choices, with arrays being consistently better. If frequent random-access writes on medium or larger sequences are what you need, arrays are likely the best option.</p>
<p>
Finally it’s worth noting that for very small sequences (10 elements or less), lists will be reasonably fast at positional writes. Their performance might even suffice for a 100-element sequence, taking less than 1 microsecond for a single random-access write. Past that point you’ll probably be better off using something else.</p>
<h2>
Other operations</h2>
<p>
I conveniently skipped some other operations such as inserts, deletes, joins, splits. Generally, these will amount to O(n) operations for all of the mentioned structures. If such actions are performed infrequently, or taken on a small collection, the performance of the presented structures might suffice. Otherwise, you’ll need to look for something else.</p>
<p>
For example, if you need to frequently insert items in the middle of a sequence, <a href="https://erlang.org/doc/man/gb_trees.html">gb_trees</a> could be a good choice. Implementing a priority queue can be as easy as using <code class="inline">{priority, System.unique_integer([:monotonic])}</code> for keys.</p>
<p>
If you need a FIFO queue consider using <a href="https://erlang.org/doc/man/queue.html">:queue</a>, which will give you amortized constant time for prepend, append, and pop operations.</p>
<p>
Sometimes you’ll need to resort to hand-crafted data structures which are tailor-made to efficiently solve the particular problem you’re dealing with. For example, suppose we’re receiving chunks of items, where some chunks need to be prepended and others need to be appended. We could use the following approach:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># append seq2 to seq1</span><span class="w">
</span><span class="p" data-group-id="3308900712-1">[</span><span class="n">seq1</span><span class="p">,</span><span class="w"> </span><span class="n">seq2</span><span class="p" data-group-id="3308900712-1">]</span><span class="w">

</span><span class="c1"># prepend seq2 to seq1</span><span class="w">
</span><span class="p" data-group-id="3308900712-2">[</span><span class="n">seq2</span><span class="p">,</span><span class="w"> </span><span class="n">seq1</span><span class="p" data-group-id="3308900712-2">]</span></code></pre>
<p>
If leaf elements can be lists, you can use tuple to combine two sequences (<code class="inline">{seq1, seq2}</code>). In either case this will be a constant time operation which requires no reshuffling of the structure internals. The final structure will be a tree that can be traversed with a body recursion. This should be roughly as fast as walking a flat list. If the input elements are strings which must be joined into a single big string, you can reach for <code class="inline">iolist</code> (a deeply nested list of binaries or bytes). See <a href="https://www.bignerdranch.com/blog/elixir-and-io-lists-part-1-building-output-efficiently/">this post by Nathan Long</a> for more details.</p>
<h2>
Summary</h2>
<p>
As you can see, the list of options is pretty big, and there’s no clear sensible default choice that fits all the cases. I understand that this can be frustrating, so let me try to provide some basic guidelines:</p>
<ol>
  <li>
If you don’t need random-access operations, use lists.  </li>
  <li>
For frequent random-access operations inside a loop, consider maps or arrays.  </li>
  <li>
If the sequence size is fixed and very small, tuples could be the best option.  </li>
  <li>
Tuples might also be a good choice if you’re only doing random-access reads.  </li>
</ol>
<p>
Also keep in mind that performance of the structure often won’t matter, for example if you’re dealing with a small sequence and a small amount of operations. Aim for the reading experience first, and optimize the code only if needed. Finally, see if you can replace random-access operations with a chain of forward-only transformations, in which case lists will work well.</p>
<p>
It would be nice if we could somehow simplify this decision process, perhaps with a good all-round data structure that wouldn’t necessary be the best fit for everything, but would be good enough at most things. One potential candidate could be Relaxed Radix Balanced Trees (aka RRB-Trees), data structure behind Clojure’s vectors. You can read more about RRB-Trees in <a href="https://infoscience.epfl.ch/record/169879/files/RMTrees.pdf">this paper</a> and <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">this blog series</a>. With fast times for operations such as append, random-access, join and split, RRB-Trees looks very interesting. Unfortunately, I’m not aware of an existing implementation for BEAM languages.</p>
<p>
No data structure can perfectly fit all the scenarios, so I don’t expect RRB-Trees to magically eliminate the need for lists, arrays, or maps. We will still need to use different structures in different scenarios, considering their strengths and weaknesses. That said, I think that RRB-Trees could potentially simplify the initial choice of the sequence type in many cases, reducing the chance of beginner mistakes like the one mentioned at the start of the article.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2020, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/sequences">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/sequences.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate></item><item><title>Operating systems via development</title><link>http://theerlangelist.com//article/operating_via_development</link><description><![CDATA[<h1>Operating systems via development</h1>
<h4 class="right">2020-06-24</h4>

<div class="article-body">
<p>
About two years ago I decided to add HTTPS support to this site, using automatic certification via Let’s Encrypt. All the articles on the subject relied on a tool called <a href="https://certbot.eff.org/">certbot</a>. A couple of variations were mentioned, some requiring the tool to run while the site is down, others using nginx + certbot combination. It seemed that installing and running some additional external tool(s) in production was mandatory.</p>
<p>
At that point The Erlangelist was a standalone Elixir-powered system which required no external program. It seemed that now I have to start worrying about setting up additional services and interact with them using their custom DSLs. This would complicate operations, and create a disconnect between production and development. Any changes to the certification configuration would need to be tested directly in production, or alternatively I’d have to setup a staging server. Either way, testing of certification would be done manually.</p>
<p>
Unhappy with this state I started the work on <a href="https://hexdocs.pm/site_encrypt/readme.html">site_encrypt</a>, a library which takes a different approach to automatic certification:</p>
<ol>
  <li>
site_encrypt is a library dependency, not an external tool. You’re not required to install any OS-level package to use it.  </li>
  <li>
The certification process and periodical renewal are running in the same OS process as the rest of the system. No other OS processes need to be started.  </li>
  <li>
Everything is configured in the same project where the system is implemented.  </li>
  <li>
Interaction with site_encrypt is done via Elixir functions and data. No yaml, ini, json, or other kind of DSL is required.  </li>
  <li>
It’s trivial to run the certification locally, which reduces the differences between prod and local dev.  </li>
  <li>
The support for automatic testing of the certification is provided. There’s no need to setup staging machines, or make changes directly on the production system.  </li>
</ol>
<p>
This is an example of what I call “integrated operations”. Instead of being spread across a bunch of yamls, inis, jsons, and bash scripts, somehow all glued together at the OS-level, most of the operations is done in development, i.e. the same place where the rest of the system is implemented, using the same language. Such approach significantly reduces the technical complexity of the system. The Erlangelist is mostly implemented in Elixir, with only a few administrative tasks, such as installation of OS packages, users creation, port forwarding rules, and similar provisioning tasks being done outside of Elixir.</p>
<p>
This also simplifies local development. The <a href="https://github.com/sasa1977/erlangelist/#running-the-site-locally">instructions to start the system locally</a> are very simple:</p>
<ol>
  <li>
Install build tools (Elixir, Erlang, nodejs)  </li>
  <li>
Fetch dependencies  </li>
  <li>
Invoke a single command to start the system  </li>
</ol>
<p>
The locally started system will be extremely close to the production version. There is almost nothing of significance running on production which is not running locally. The only two differences of note I can think of are:</p>
<ol>
  <li>
Ports 80/443 are forwarded in prod  </li>
  <li>
The prod version uses Lets Encrypt for certification, while the local version uses a local CA server (more on this later).  </li>
</ol>
<p>
Now, this may not sound like much for a simple blog host, but behind the scene The Erlangelist is a bit more than a simple request responder:</p>
<ol>
  <li>
The Erlangelist system runs two separate web servers. The public facing server is the one you use to read this article. Another internal server uses the <a href="https://hexdocs.pm/phoenix_live_dashboard/Phoenix.LiveDashboard.html">Phoenix Live Dashboard</a> to expose some metrics.  </li>
  <li>
A small hand-made database is running which collects, aggregates, and persists the reading stats, periodically removing older stats from the disk.  </li>
  <li>
The system periodically renews the certificate.  </li>
  <li>
Locally and on CI, another web server which acts as a local certificate authority (CA) is running.  </li>
</ol>
<p>
In other words, The Erlangelist is more than just a blog, a site, a server, or an app. It’s a system consisting of multiple activities which collectively work together to support the full end-user service, as well as the operational aspects of the system. All of these activities are running concurrently. They don’t block each other, or crash each other. The system utilizes all CPU cores of its host machine. For more details on how this works take a look at my talk <a href="https://www.youtube.com/watch?v=JvBT4XBdoUE">The soul of Erlang and Elixir</a>.</p>
<p>
Let’s take a closer look at site_encrypt.</p>
<h2>
Certification</h2>
<p>
Let’s Encrypt supports automatic certification via the <a href="https://tools.ietf.org/html/rfc8555">ACME (Automatic Certificate Management Environment) protocol</a>. This protocol describes the conversation between the client, which is a system wanting to obtain the certificate for some domain, and the server, which is the certificate authority (CA) that can create such certificate. In ACME conversation, our system asks the CA to provide the certificate for some domain, and the CA asks us to prove that we’re the owners of that domain. The CA gives us some random bytes, and then makes a request at our domain, expecting to get those same bytes in return. This is also called a challenge. If we successfully respond to the challenge, the CA will create the certificate for us. The real story is of course more involved, but this simplified version hopefully gives you the basic idea.</p>
<p>
This conversation is an activity of the system. It’s a job which needs to be occasionally done to allow the system to provide the full service. If we don’t do the certification, we don’t have a valid certificate, and most people won’t use the site. Likewise, if I decide to shut the site down, the certification serves no purpose anymore.</p>
<p>
In such situations my preferred approach is to run this activity together with the rest of the system. The less fragmented the system is, the easier it is to manage. Running some part of the system externally is fine if there are stronger reasons, but I don’t see such reasons in this simple scenario.</p>
<p>
<a href="https://hexdocs.pm/site_encrypt/readme.html#quick-start">site_encrypt makes this task straightforward</a>. Add a library dep, fill in some blanks, and you’re good to go. The certification configuration is provided by defining the <code class="inline">certification</code> function:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">certification</span><span class="w"> </span><span class="k" data-group-id="1614957701-1">do</span><span class="w">
  </span><span class="nc">SiteEncrypt</span><span class="o">.</span><span class="n">configure</span><span class="p" data-group-id="1614957701-2">(</span><span class="w">
    </span><span class="ss">client</span><span class="p">:</span><span class="w"> </span><span class="ss">:native</span><span class="p">,</span><span class="w">
    </span><span class="ss">domains</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1614957701-3">[</span><span class="s">&quot;mysite.com&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;www.mysite.com&quot;</span><span class="p" data-group-id="1614957701-3">]</span><span class="p">,</span><span class="w">
    </span><span class="ss">emails</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1614957701-4">[</span><span class="s">&quot;contact@mysite.com&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;another_contact@mysite.com&quot;</span><span class="p" data-group-id="1614957701-4">]</span><span class="p">,</span><span class="w">
    </span><span class="ss">db_folder</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/folder/where/site_encrypt/stores/files&quot;</span><span class="p">,</span><span class="w">
    </span><span class="ss">directory_url</span><span class="p">:</span><span class="w"> </span><span class="n">directory_url</span><span class="p" data-group-id="1614957701-5">(</span><span class="p" data-group-id="1614957701-5">)</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="1614957701-2">)</span><span class="w">
</span><span class="k" data-group-id="1614957701-1">end</span></code></pre>
<p>
This code looks pretty declarative, but it is executable code, not just a collection of facts. And that means that we have a lot of flexibility to shape the configuration data however we want. For example, if we want to make the certification parameters configurable by the system operator, say via a yaml file, nothing stops us from invoking <code class="inline">load_configuration_from_yaml()</code> instead of hardcoding the data. Say we want to make only some parameters configurable (e.g. domains and email), while leaving the rest hardcoded. We can simply do <code class="inline">Keyword.merge(load_some_params_from_yaml(), hardcoded_data)</code>. Supporting other kinds of config sources, like etcd or a database, is equally straightforward. You can always build declarative on top of imperative, while the opposite will require some imagination and trickery, such as running external configuration generators, and good luck managing that in production :-)</p>
<p>
It’s also worth mentioning that site_encrypt internally ships with two lower-level modules, a sort of plumbing to this porcelain. There is a <a href="https://hexdocs.pm/site_encrypt/SiteEncrypt.Acme.Client.html#content">mid-level module</a> which provides workflow-related operations, such as “create an account”, or “perform the certification”, and a <a href="https://hexdocs.pm/site_encrypt/SiteEncrypt.Acme.Client.API.html#content">lower-level module</a> which provides basic ACME client operations. These modules can be used when you want a finer grained control over the certification process.</p>
<h2>
Reducing the dev-production mismatch</h2>
<p>
There’s one interesting thing happening in the configuration presented earlier:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">certification</span><span class="w"> </span><span class="k" data-group-id="6616258172-1">do</span><span class="w">
  </span><span class="nc">SiteEncrypt</span><span class="o">.</span><span class="n">configure</span><span class="p" data-group-id="6616258172-2">(</span><span class="w">
    </span><span class="c1"># ...</span><span class="w">
    </span><span class="ss">directory_url</span><span class="p">:</span><span class="w"> </span><span class="n">directory_url</span><span class="p" data-group-id="6616258172-3">(</span><span class="p" data-group-id="6616258172-3">)</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="6616258172-2">)</span><span class="w">
</span><span class="k" data-group-id="6616258172-1">end</span></code></pre>
<p>
The <code class="inline">directory_url</code> property defines the CA where site_encrypt will obtain the certificate. Instead of hardcoding this url, we’re invoking a function to compute it. This happens because we need to use different urls for production vs staging vs local development. Let’s take a look:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">directory_url</span><span class="w"> </span><span class="k" data-group-id="8610474942-1">do</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">get_env</span><span class="p" data-group-id="8610474942-2">(</span><span class="s">&quot;MODE&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;local&quot;</span><span class="p" data-group-id="8610474942-2">)</span><span class="w"> </span><span class="k" data-group-id="8610474942-3">do</span><span class="w">
    </span><span class="s">&quot;production&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;https://acme-v02.api.letsencrypt.org/directory&quot;</span><span class="w">
    </span><span class="s">&quot;staging&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;https://acme-staging-v02.api.letsencrypt.org/directory&quot;</span><span class="w">
    </span><span class="s">&quot;local&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="8610474942-4">{</span><span class="ss">:internal</span><span class="p">,</span><span class="w"> </span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="mi">4002</span><span class="p" data-group-id="8610474942-4">}</span><span class="w">
  </span><span class="k" data-group-id="8610474942-3">end</span><span class="w">
</span><span class="k" data-group-id="8610474942-1">end</span></code></pre>
<p>
Here, we’re distinguishing production from staging from development based on the <code class="inline">MODE</code> OS env (easily replaceable with other source, owing to programmable API). If the env is not provided, we’ll assume that the system running locally.</p>
<p>
On a production machine, we go to the real CA, while for staging we’ll use Let’s Encrypt staging site. But what about the <code class="inline">{:internal, port: 4002}</code> thing which we use in local development? If we pass this particular shape of data to site_encrypt, an internal ACME server will be started on the given port, a sort of a local mock of Let’s Encrypt. This server is running inside the same same OS process as the rest of the system.</p>
<p>
So locally, site_encrypt will start a mock of Let’s Encrypt, and it will use that mock to obtain the certificate. In other words, locally the system will certify itself. Here’s an example of this in action on a local version of The Erlangelist:</p>
<pre><code class="text">$ iex -S mix phx.server

[info]  Running Erlangelist.Web.Blog.Endpoint at 0.0.0.0:20080 (http)
[info]  Running Erlangelist.Web.Blog.Endpoint at 0.0.0.0:20443 (https)
[info]  Running local ACME server at port 20081
[info]  Creating new ACME account for domain theerlangelist.com
[info]  Ordering a new certificate for domain theerlangelist.com
[info]  New certificate for domain theerlangelist.com obtained
[info]  Certificate successfully obtained!</code></pre>
<h2>
Testability</h2>
<p>
Since local Erlangelist behaves exactly as the real one, we can test more of the system behaviour. For example, even on the local version HTTP requests are redirected to HTTPS. Here’s a test verifying this:</p>
<pre><code class="highlight makeup elixir"><span class="n">test</span><span class="w"> </span><span class="s">&quot;http requests are redirected to https&quot;</span><span class="w"> </span><span class="k" data-group-id="1496509507-1">do</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="n">redirected_to</span><span class="p" data-group-id="1496509507-2">(</span><span class="nc">Client</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="1496509507-3">(</span><span class="s">&quot;http://localhost/&quot;</span><span class="p" data-group-id="1496509507-3">)</span><span class="p">,</span><span class="w"> </span><span class="mi">301</span><span class="p" data-group-id="1496509507-2">)</span><span class="w"> </span><span class="o">==</span><span class="w">
    </span><span class="s">&quot;https://localhost/&quot;</span><span class="w">
</span><span class="k" data-group-id="1496509507-1">end</span></code></pre>
<p>
Likewise, redirection to www can also be tested:</p>
<pre><code class="highlight makeup elixir"><span class="n">test</span><span class="w"> </span><span class="s">&quot;theerlangelist.com is redirected to www.theerlangelist.com&quot;</span><span class="w"> </span><span class="k" data-group-id="6648286456-1">do</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="n">redirected_to</span><span class="p" data-group-id="6648286456-2">(</span><span class="nc">Client</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="6648286456-3">(</span><span class="s">&quot;https://theerlangelist.com/&quot;</span><span class="p" data-group-id="6648286456-3">)</span><span class="p">,</span><span class="w"> </span><span class="mi">301</span><span class="p" data-group-id="6648286456-2">)</span><span class="w">
    </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;https://www.theerlangelist.com/&quot;</span><span class="w">
</span><span class="k" data-group-id="6648286456-1">end</span></code></pre>
<p>
In contrast, external proxy rules, such as those defined in Nginx configuration are typically not tested, which means that some change in configuration might break something else in a way which is not obvious to the operator.</p>
<p>
In addition, site_encrypt ships with a small helper for testing the certification. Here’s the relevant test:</p>
<pre><code class="highlight makeup elixir"><span class="n">test</span><span class="w"> </span><span class="s">&quot;certification&quot;</span><span class="w"> </span><span class="k" data-group-id="2611148100-1">do</span><span class="w">
  </span><span class="n">clean_restart</span><span class="p" data-group-id="2611148100-2">(</span><span class="nc">Erlangelist.Web.Blog.Endpoint</span><span class="p" data-group-id="2611148100-2">)</span><span class="w">
  </span><span class="n">cert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_cert</span><span class="p" data-group-id="2611148100-3">(</span><span class="nc">Erlangelist.Web.Blog.Endpoint</span><span class="p" data-group-id="2611148100-3">)</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="n">cert</span><span class="o">.</span><span class="n">domains</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sx">~w/theerlangelist.com www.theerlangelist.com/</span><span class="w">
</span><span class="k" data-group-id="2611148100-1">end</span></code></pre>
<p>
During this test, the blog endpoint (i.e. the blog web server) will be restarted, with all previously existing certificates removed. During the restart, the endpoint will be certified via the local ACME server. This certification will go through the whole process, with no mocking (save for the fact that a local CA is used). HTTP requests will be made, some keys will be generated, the system will call CA, which will then concurrently make a request to the system, and ultimately the certificate will be obtained.</p>
<p>
Once that’s all finished, the invocation of <code class="inline">get_cert</code> will establish an ssl connection to the blog server and fetch the certificate of the peer. Then we can assert the expected properties of the certificate.</p>
<p>
Having such tests significantly increases my confidence in the system. Of course, there’s always a chance of something going wrong in production (e.g. if DNS isn’t correctly configured, and Let’s Encrypt can’t reach my site), but the possibility of errors is reduced, not only because of the tests, but also because a compiled language is used. For example, if I make a syntax error while changing the configuration, the code won’t even compile, let alone make it to production. If I make a typo, e.g. by specifying <code class="inline">theerlangelist.org</code> instead of <code class="inline">theerlangelist.com</code>, the certification test will fail. In contrast, external configurations are much harder to test, and so they typically end up being manually verified on staging, or in some cases only in production.</p>
<h2>
More automation</h2>
<p>
Beyond just obtaining the certificate, site_encrypt will periodically renew it. A periodic job is executed three times a day. This job checks the expiry date of the certificate, and starts the renewal process if the certificate is about to expire in 30 days. In addition, every time a certificate is obtained, site_encrypt can optionally generate a backup of its data. When the system is starting, if the site_encrypt database folder isn’t present and the backup file exists, site_encrypt will automatically restore the database from the backup.</p>
<p>
As a user of site_encrypt you have to do zero work to make this happen, which significantly reduces the amount of operational work required, bringing the bulk of it to the regular development.</p>
<p>
For more elaborate backup scenarios, site_encrypt provides a callback hook. In your endpoint module you can define the function which is invoked after the certificate is obtained. You can use this function to e.g. store the cert in an arbitrary secure storage of your choice. Notice how this becomes a part of the regular system codebase, which is the most convenient and logical place to express such task. The fact that this is running together with the rest of the system, also means it’s testable. Testing that the new certificate is correctly stored to desired storage is straightforward.</p>
<h2>
Tight integration</h2>
<p>
Since it runs in the same OS process, and is powered by the same language, site_encrypt can integrate much better with its client, which leads to some nice benefits. I mentioned earlier that certification is a conversation between our system and the CA server. Now, when we’re using the certbot tool, this dialogue turns into a three-party conversation. Instead of our system asking for the certificate, we ask certbot to do this on our behalf. However, the CA verification request (aka challenge) needs to be served by our site. Now, since certbot is an external tool, it treats our site as an opaque box. As a result, certbot doesn’t know when we responded to the CA challenge, and so it has to be a bit more conservative. Namely, certbot will sleep for about three seconds before it starts polling CA to see if the challenge has been answered.</p>
<p>
The native Elixir ACME client runs in the same OS process, and so it can integrate much better. The ACME client is informed by the challenge handler that the challenge is fulfilled, and so it can use a much shorter delay to start polling the CA. In production this optimization isn’t particularly relevant, but on local dev, and especially in tests the difference becomes significant. The certification test via certbot takes about 6 seconds on my machine. The same test via the native client is about 800ms.</p>
<p>
This tight integration offers some other interesting possibilities. With a bit of changes to the API, site_encrypt could support arbitrary storage for its database. It could also support coordination between multiple nodes, making it possible to implement a distributed certification, where an arbitrary node in the cluster initiates the certification, while any other node can successfully respond to the challenge, including even the nodes which came online after the challenge has been started.</p>
<h2>
Operations</h2>
<p>
With the bulk of the system behaviour described in Elixir code, the remaining operational tasks done outside of Elixir are exclusively related to preparing the machine to run the Erlangelist. These tasks involve creating necessary accounts, creating the folder structure, installing required OS packages (essentially just Docker is needed), and setting up a single systemd unit for starting the container.</p>
<p>
The production is dockerized, but the production docker image is very lightweight:</p>
<pre><code class="text">FROM alpine:3.11 as site

RUN apk --no-cache upgrade &amp;&amp; apk add --no-cache ncurses

COPY --from=builder /opt/app/site/_build/prod/rel/erlangelist /erlangelist

VOLUME /erlangelist/lib/erlangelist-0.0.1/priv/db
VOLUME /erlangelist/lib/erlangelist-0.0.1/priv/backup

WORKDIR /erlangelist
ENTRYPOINT [&quot;/erlangelist/bin/erlangelist&quot;]</code></pre>
<p>
The key part is the <code class="inline">COPY</code> instruction which adds the built release of the system to the image. This release will contain all the compiled binaries, as well as a minimal Erlang runtime system, and is therefore pretty much self-contained, requiring only one small OS-level package to be installed.</p>
<h2>
Final thoughts</h2>
<p>
Some might argue that using certbot with optionally Nginx or Caddy is simple enough, and I wouldn’t completely disagree. It’s perfectly valid to reach for external products to solve a technical challenge not related to the business domain. Such products can help us solve our problem quickly and focus on our core challenges. On the other hand, I feel that we should be more critical of the problems introduced by such products. As I’ve tried to show in this simple example, the integrated operations approach reduces the amount of moving parts and technologies used, bridges the gap between production and development, and improves the testability of the system. The implementation is simpler and at the same time more flexible, since the tool is driven by functions and data.</p>
<p>
For this approach to work, you need a runtime that supports managing multiple system activities. BEAM, the runtime of Erlang and Elixir, makes this possible. For example, in many cases serving traffic directly with Phoenix, without having a reverse proxy in front of it, will work just fine. Features such as ETS tables or GenServer will reduce the need for tools like Redis. Running periodic jobs, regulating load, rate-limiting, pipeline processing, can all be done directly from Elixir, without requiring any external product.</p>
<p>
Of course, there will always be cases where external tools will make more sense. But there will also be many cases where integrated approach will work just fine, especially in smaller systems not operating at the level of scale or complexity of Netflix, Twitter, Facebook, and similar. Having both options available would allow us to start with simple and move to an external tool only in more complicated scenarios.</p>
<p>
This is the reason why I started the work on site_encrypt. The library is still incomplete and probably buggy, but these are issues that can be fixed with time and effort :-) I believe that the benefits of this approach are worth the effort, so I’ll continue the work on the library. I’d like to see more of such libraries appearing, giving us simpler options for challenges such as load balancing, proxying, or persistence. As long as there are technical challenges where running an external product is the only option, there is opportunity for simplification, and it’s up to us, the developers, to make that happen.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2020, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/operating_via_development">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/operating_via_development.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate></item><item><title>Periodic jobs in Elixir with Periodic</title><link>http://theerlangelist.com//article/periodic</link><description><![CDATA[<h1>Periodic jobs in Elixir with Periodic</h1>
<h4 class="right">2020-01-27</h4>

<div class="article-body">
<p>
One cool thing about BEAM languages is that we can implement periodic jobs without using external tools, such as cron. The implementation of the job can reside in the same project as the rest of the system, and run in the same OS process as the other activities in the system, which can help simplify development, testing, and operations.</p>
<p>
There are various helper abstractions for running periodic jobs in BEAM, such as the built-in <a href="https://erlang.org/doc/man/timer.html">:timer</a> module from Erlang stdlib, and 3rd party libraries such as <a href="https://github.com/erlware/erlcron">erlcron</a>, <a href="https://hexdocs.pm/quantum/readme.html">quantum</a>, or <a href="https://hexdocs.pm/oban/Oban.html#module-periodic-cron-jobs">Oban</a>.</p>
<p>
In this article I’ll present my own small abstraction called <a href="https://hexdocs.pm/parent/Periodic.html#content">Periodic</a> which is a part of the <a href="https://github.com/sasa1977/parent">Parent</a> library. I wrote Periodic almost two years ago, mostly because I wasn’t particularly satisfied with the available options. Compared to most other periodic schedulers, Periodic makes some different choices:</p>
<ul>
  <li>
Scheduling is distributed. Each job uses its own dedicated scheduler process.  </li>
  <li>
Cron expressions are not supported.  </li>
  <li>
There is no out-of-the box support for fixed schedules.  </li>
</ul>
<p>
These choices may seem controversial, but there are reasons for making them. Periodic is built to be easy to use in simple scenarios, flexible enough to power various involved cases, and simple to grasp and reason about. To achieve these properties, Periodic is deliberately designed as a small and focused abstraction. Concerns such as declarative interfaces, back-pressure and load regulation, fixed scheduling, improved execution guarantees via persistence, are left to the client code. This means that as clients of Periodic, we sometimes have to invest some more work, but what we get in return is a simple and a flexible abstraction.</p>
<h2>
Simple usage</h2>
<p>
A periodic job can be started as follows:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Periodic</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="0426507210-1">(</span><span class="w">
  </span><span class="ss">run</span><span class="p">:</span><span class="w"> </span><span class="k" data-group-id="0426507210-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="0426507210-3">(</span><span class="s">&quot;Hello, World!&quot;</span><span class="p" data-group-id="0426507210-3">)</span><span class="w"> </span><span class="k" data-group-id="0426507210-2">end</span><span class="p">,</span><span class="w">
  </span><span class="ss">every</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">seconds</span><span class="p" data-group-id="0426507210-4">(</span><span class="mi">5</span><span class="p" data-group-id="0426507210-4">)</span><span class="w">
</span><span class="p" data-group-id="0426507210-1">)</span><span class="w">

</span><span class="c1"># after 5 seconds</span><span class="w">
</span><span class="nc">Hello</span><span class="p">,</span><span class="w"> </span><span class="nc">World</span><span class="w">

</span><span class="c1"># after 10 seconds</span><span class="w">
</span><span class="nc">Hello</span><span class="p">,</span><span class="w"> </span><span class="nc">World</span><span class="w">

</span><span class="c1"># ...</span></code></pre>
<p>
Unlike most other periodic libraries out there, Periodic doesn’t use the cron syntax. Even after many years of working with it, I still find that syntax cryptic, unintuitive, and limited. In contrast, I believe that <code class="inline">Periodic.start_link(run: something, every: x)</code> is clearer at expressing the intention.</p>
<p>
Periodic accepts a couple of options which allow you to control its behaviour, such as dealing with overlapping jobs, interpreting delays, or terminating jobs which run too long. These options make Periodic more convenient than the built-in <code class="inline">:timer</code> functionality, with a comparable ease of use. I’m not going to discuss those options in this post, but you can take a look at <a href="https://hexdocs.pm/parent/Periodic.html#module-options">docs</a> for more details.</p>
<p>
The interface of Periodic is small. The bulk of functionality is provided in the single module which exposes two functions: <code class="inline">start_link</code> for starting the process dynamically, and <code class="inline">child_spec</code> for building supervisor specs. Two additional modules are provided - one to assist with logging, and another to help with deterministic testing.</p>
<p>
Controversially enough, Periodic doesn’t provide out-of-the-box support for fixed schedules (e.g. run every Wednesday at 5pm). This might seem like a big deficiency, while it’s in fact a deliberate design choice. I personally regard fixed scheduling as a nuanced challenge for which there is no one-size-fits-all solution, so it’s best to make the trade-offs explicit and leave the choices to the client. Of course it’s perfectly possible to power fixed scheduled jobs with Periodic, and I’ll present some approaches later on in this article.</p>
<h2>
Flexibility</h2>
<p>
Since it is based on plain functions invoked at runtime, Periodic is as flexible as it gets. You don’t need to use app or OS envs, but you may use them if they suit your purposes. You don’t need to define a dedicated module (although <a href="https://hexdocs.pm/parent/Periodic.html#module-quick-start">it is advised for typical cases</a>), <code class="inline">use</code> some library module to inject the boilerplate, or pass anything at compile-time. In fact, Periodic is very runtime friendly, supporting various elaborate scenarios, such as on-demand starting/stopping of scheduled jobs.</p>
<p>
Another dimension of Periodic’s flexibility is its <a href="https://hexdocs.pm/parent/Periodic.html#module-process-structure">process model</a>. In Periodic, each job is powered by its own scheduler process. This is one of the core ideas behind Periodic which sets it apart from most other BEAM periodic schedulers I’ve seen.</p>
<p>
As a result of this approach, different jobs are separate children in the supervision tree, and so, stopping an individual job is no different from stopping any other kind process. If you know how to do that with OTP, then you know everything you need to know. If you don’t, you’ll need to learn these techniques, but that knowledge will be applicable in the wide range of scenarios outside of Periodic.</p>
<p>
Using supervision tree to separate runtime concerns gives us a fine grained control over job termination. Consider the following tree:</p>
<pre><code class="text">       MySystem
      /        \
    Db     CacheCleanup
   /  \
Repo  DbCleanup</code></pre>
<p>
In this system we run two periodic jobs (<code class="inline">DbCleanup</code> and <code class="inline">CacheCleanup</code>). If we want to stop the database part of the system, we can do that by stopping the <code class="inline">Db</code> supervisor, taking all db-related activities down, while keeping the cache cleanup alive.</p>
<p>
Since schedulers are a part of the supervision tree, and a scheduler acts as a supervisor (courtesy of being powered by <a href="https://hexdocs.pm/parent/Parent.GenServer.html">Parent.GenServer</a>), various generic code that manipulates the process hierarchy will work with Periodic too. For example, if the job process is trapping exits, <a href="https://hexdocs.pm/elixir/System.html#stop/1">System.stop</a> will wait for the job to finish, according to the job childspec (5 seconds by default).</p>
<p>
Of course, this process design comes with some trade-offs. Compared to singleton scheduler strategies, Periodic will use twice the amount of processes. This shouldn’t be problematic if the number of jobs is “reasonable”, but it might hurt you if you want to run millions of jobs. However, in such case I don’t think that any generic periodic library will fit the challenge perfectly, and it’s more likely you’ll need to roll your own special implementation, perhaps using <code class="inline">Parent.GenServer</code> to help out with some mechanical concerns.</p>
<p>
Speaking of Parent, it’s worth noting that this is the abstraction that handles supervisor aspect of the scheduler process, allowing the implementation of Periodic to remain focused and relatively small. The Periodic module currently has 410 LOC, 260 of which are user documentation. The code of Periodic is all about periodic execution concerns, such as ticking with <a href="https://hexdocs.pm/elixir/Process.html#send_after/4">Process.send_after</a>, starting the execution, interpreting and handling user options, and emitting telemetry events. Such division of responsibilities makes both abstractions fairly easy to grasp and reason about, while enabling <code class="inline">Parent.GenServer</code> to be used in various other situations (see <a href="https://hexdocs.pm/parent/rationale.html#examples">the Example section in the rationale document</a> for details).</p>
<h2>
Fixed scheduling</h2>
<p>
Periodic doesn’t offer ready-made abstraction for fixed scheduling (e.g. run once a day at midnight). However, such behaviour can be easily implemented on top of the existing functionality using the <code class="inline">:when</code> filter. Here’s a basic sketch:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Periodic</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="5516519337-1">(</span><span class="w">
  </span><span class="ss">every</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">minutes</span><span class="p" data-group-id="5516519337-2">(</span><span class="mi">1</span><span class="p" data-group-id="5516519337-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="k" data-group-id="5516519337-3">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">match?</span><span class="p" data-group-id="5516519337-4">(</span><span class="p" data-group-id="5516519337-5">%</span><span class="nc" data-group-id="5516519337-5">Time</span><span class="p" data-group-id="5516519337-5">{</span><span class="ss">hour</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">minute</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="5516519337-5">}</span><span class="p">,</span><span class="w"> </span><span class="nc">Time</span><span class="o">.</span><span class="n">utc_now</span><span class="p" data-group-id="5516519337-6">(</span><span class="p" data-group-id="5516519337-6">)</span><span class="p" data-group-id="5516519337-4">)</span><span class="w"> </span><span class="k" data-group-id="5516519337-3">end</span><span class="p">,</span><span class="w">
  </span><span class="ss">run</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">run_job</span><span class="o">/</span><span class="mi">0</span><span class="w">
</span><span class="p" data-group-id="5516519337-1">)</span></code></pre>
<p>
The idea is to tick regularly in short intervals, and use the provided <code class="inline">:when</code> filter to decide if the job should be started.</p>
<p>
Careful readers will spot some possible issues in this implementation. If the system (or the scheduler process) is down at the scheduled time, the job won’t be executed. Furthermore, it’s worth mentioning that Periodic doesn’t guarantee 100% interval precision. Though not very likely, it can (and occasionally will!) happen that in some interval a job is executed twice, while in another interval it’s not executed at all. Such situations will cause our daily job to be either skipped, or executed twice in the same minute. It’s worth noting that similar issues can be (and often are) present in other periodic scheduling systems, but at least in Periodic they are more explicit and clear, since they are present in our code, not in the internals of the abstraction.</p>
<p>
If you don’t care about occasional missed or extra beat, the basic take presented above will serve you just fine. In fact, if I wanted to do some daily nice-to-have cleanup, this is the version I’d start with. Perhaps the code is not as short as <code class="inline">0 0 * * *</code>, but on the upside it’s more explicit about its intention and possible consequences, and it is quite flexible. Implementing more elaborate schedules such as “run every 10 minutes during working hours, but once per hour otherwise” is a matter of adapting the <code class="inline">:when</code> function.</p>
<h2>
Abstracting</h2>
<p>
Our fixed scheduling code, while fairly short, might become a bit noisy and tedious if you want to run multiple fixed scheduled jobs. However, since Periodic interface is based on plain functions and arguments, nothing prevents you from generalizing the approach, for example as follows:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">NaiveDaily</span><span class="w"> </span><span class="k" data-group-id="7684041942-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">start_link</span><span class="p" data-group-id="7684041942-2">(</span><span class="n">hour</span><span class="p">,</span><span class="w"> </span><span class="n">minute</span><span class="p">,</span><span class="w"> </span><span class="n">run_job</span><span class="p" data-group-id="7684041942-2">)</span><span class="w"> </span><span class="k" data-group-id="7684041942-3">do</span><span class="w">
    </span><span class="nc">Periodic</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="7684041942-4">(</span><span class="w">
      </span><span class="ss">every</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">minutes</span><span class="p" data-group-id="7684041942-5">(</span><span class="mi">1</span><span class="p" data-group-id="7684041942-5">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">when</span><span class="p">:</span><span class="w">
        </span><span class="k" data-group-id="7684041942-6">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">match?</span><span class="p" data-group-id="7684041942-7">(</span><span class="p" data-group-id="7684041942-8">%</span><span class="nc" data-group-id="7684041942-8">Time</span><span class="p" data-group-id="7684041942-8">{</span><span class="ss">hour</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">hour</span><span class="p">,</span><span class="w"> </span><span class="ss">minute</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">minute</span><span class="p" data-group-id="7684041942-8">}</span><span class="p">,</span><span class="w"> </span><span class="nc">Time</span><span class="o">.</span><span class="n">utc_now</span><span class="p" data-group-id="7684041942-9">(</span><span class="p" data-group-id="7684041942-9">)</span><span class="p" data-group-id="7684041942-7">)</span><span class="w"> </span><span class="k" data-group-id="7684041942-6">end</span><span class="p">,</span><span class="w">
      </span><span class="ss">run</span><span class="p">:</span><span class="w"> </span><span class="n">run_job</span><span class="w">
    </span><span class="p" data-group-id="7684041942-4">)</span><span class="w">
  </span><span class="k" data-group-id="7684041942-3">end</span><span class="w">
</span><span class="k" data-group-id="7684041942-1">end</span></code></pre>
<p>
And now, in your project you can do:</p>
<pre><code class="highlight makeup elixir"><span class="nc">NaiveDaily</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="8956693355-1">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">do_something</span><span class="o">/</span><span class="mi">0</span><span class="p" data-group-id="8956693355-1">)</span><span class="w">
</span><span class="nc">NaiveDaily</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="8956693355-2">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">do_something_else</span><span class="o">/</span><span class="mi">0</span><span class="p" data-group-id="8956693355-2">)</span></code></pre>
<p>
Taking this idea further, implementing a generic translator of cron syntax to Periodic should be possible and straightforward. In theory, Parent, the host library of Periodic, could ship with such abstractions, and one day some such helpers might be added to the library. For the time being though, I’m content with keeping the library small and focused, and I’ll consider expanding it after gathering some data from the usage in the wild.</p>
<h2>
Improving execution guarantees</h2>
<p>
Our basic naive implementation of the fixed scheduler gives us “maybe once” guarantees - a job will usually be executed once a day, occasionally it won’t be executed at all, while in some special circumstances it might be executed more than once in the same minute.</p>
<p>
If we want to improve the guarantees, we need to expand the code. Luckily, since our approach is powered by a Turing-complete language, we can tweak the implementation to our needs. Here’s a basic sketch:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Periodic</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="2421752444-1">(</span><span class="w">
  </span><span class="ss">every</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">minutes</span><span class="p" data-group-id="2421752444-2">(</span><span class="mi">1</span><span class="p" data-group-id="2421752444-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="k" data-group-id="2421752444-3">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">job_executed_today?</span><span class="p" data-group-id="2421752444-4">(</span><span class="p" data-group-id="2421752444-4">)</span><span class="w"> </span><span class="k" data-group-id="2421752444-3">end</span><span class="p">,</span><span class="w">
  </span><span class="ss">run</span><span class="p">:</span><span class="w"> </span><span class="k" data-group-id="2421752444-5">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="n">run_job</span><span class="p" data-group-id="2421752444-6">(</span><span class="p" data-group-id="2421752444-6">)</span><span class="w">
    </span><span class="n">mark_job_as_executed_today</span><span class="p" data-group-id="2421752444-7">(</span><span class="p" data-group-id="2421752444-7">)</span><span class="w">
  </span><span class="k" data-group-id="2421752444-5">end</span><span class="w">
</span><span class="p" data-group-id="2421752444-1">)</span></code></pre>
<p>
As the name suggests <code class="inline">job_executed_today?/0</code> has to somehow figure out if we already ran the job. A simple version can be powered by a global in-memory data (e.g. using ETS), which should improve the chance of the job getting executed at least once a day, but it would also increase the chance of unwanted repeated executions.</p>
<p>
If we opt to base the logic on some persistence storage (say a database), we can reduce the chance of repeated executions. Note however that an occasional duplicate might still happen if the system is shut down right after the job is executed, but before it’s marked as executed. In this case, we’ll end up executing the job again after the restart. This issue can only be eliminated in some special circumstances, such as:</p>
<ul>
  <li>
The job manipulates the same database where we mark job as executed. In this case we can transactionally run the job and mark it as executed.  </li>
  <li>
The target of the job supports idempotence, allowing us to safely rerun the job without producing duplicate side-effects.  </li>
</ul>
<p>
Here’s a bit more involved scenario, which I actually had to solve in real-life. Suppose that we want to run a periodic cleanup during the night, but only if no other activity in the system is taking place. Moreover, while the job is running, all pending activities should wait. Here’s a basic sketch:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Periodic</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="4566321262-1">(</span><span class="w">
  </span><span class="ss">on_overlap</span><span class="p">:</span><span class="w"> </span><span class="ss">:ignore</span><span class="p">,</span><span class="w">
  </span><span class="ss">every</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">minutes</span><span class="p" data-group-id="4566321262-2">(</span><span class="mi">1</span><span class="p" data-group-id="4566321262-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="k" data-group-id="4566321262-3">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Time</span><span class="o">.</span><span class="n">utc_now</span><span class="p" data-group-id="4566321262-4">(</span><span class="p" data-group-id="4566321262-4">)</span><span class="o">.</span><span class="n">hour</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="o">.</span><span class="mi">4</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">job_executed_today?</span><span class="p" data-group-id="4566321262-5">(</span><span class="p" data-group-id="4566321262-5">)</span><span class="w"> </span><span class="k" data-group-id="4566321262-3">end</span><span class="p">,</span><span class="w">
  </span><span class="ss">run</span><span class="p">:</span><span class="w"> </span><span class="k" data-group-id="4566321262-6">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="n">with_exclusive_lock</span><span class="p" data-group-id="4566321262-7">(</span><span class="k" data-group-id="4566321262-8">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">run_job</span><span class="p" data-group-id="4566321262-9">(</span><span class="p" data-group-id="4566321262-9">)</span><span class="w">
      </span><span class="n">mark_job_as_executed_today</span><span class="p" data-group-id="4566321262-10">(</span><span class="p" data-group-id="4566321262-10">)</span><span class="w">
    </span><span class="k" data-group-id="4566321262-8">end</span><span class="p" data-group-id="4566321262-7">)</span><span class="w">
  </span><span class="k" data-group-id="4566321262-6">end</span><span class="w">
</span><span class="p" data-group-id="4566321262-1">)</span></code></pre>
<p>
The implementation relies on some exclusive lock mechanism. In a simple version we can use <a href="https://erlang.org/doc/man/global.html#trans-4">:global.trans</a> to implement a basic version of RW locking that would permit regular activities to grab the lock simultaneously (readers), while the job would be treated as a writer which grabs the lock exclusively to anyone else. Also note the usage of the <code class="inline">on_overlap: :ignore</code> option, which makes sure we don’t run multiple instances of the job simultaneously.</p>
<p>
In a real-life scenario I used this approach, combined with ad-hoc persistence to a local file with <a href="http://erlang.org/doc/man/erlang.html#term_to_binary-1">:erlang.term_to_binary</a> and <a href="http://erlang.org/doc/man/erlang.html#binary_to_term-1">its counterpart</a>. The project was completely standalone, powered at runtime by a single BEAM instance, and nothing else running on the side.</p>
<p>
This is a nice example of how we profit from the fact that the periodic execution is running together with the rest of the system. There’s a natural strong dependency between the job and other system activities, and we can model this dependency without needing to run external moving pieces, such as e.g. Redis. Our implementation is a straightforward representation of the problem, and it can even be easily tested!</p>
<p>
The locking mechanism could also be used to ensure that the job is executed only on a single machine in the cluster:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Periodic</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="1992931581-1">(</span><span class="w">
  </span><span class="ss">on_overlap</span><span class="p">:</span><span class="w"> </span><span class="ss">:ignore</span><span class="p">,</span><span class="w">
  </span><span class="ss">every</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">minutes</span><span class="p" data-group-id="1992931581-2">(</span><span class="mi">1</span><span class="p" data-group-id="1992931581-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">should_run?</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="ss">run</span><span class="p">:</span><span class="w"> </span><span class="k" data-group-id="1992931581-3">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="n">with_exclusive_lock</span><span class="p" data-group-id="1992931581-4">(</span><span class="k" data-group-id="1992931581-5">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="c1"># The repeated check makes sure the job hasn&#39;t been executed</span><span class="w">
      </span><span class="c1"># on some other machine while we were waiting for the lock.</span><span class="w">
      </span><span class="k">if</span><span class="w"> </span><span class="n">should_run?</span><span class="p" data-group-id="1992931581-6">(</span><span class="p" data-group-id="1992931581-6">)</span><span class="w"> </span><span class="k" data-group-id="1992931581-7">do</span><span class="w">
        </span><span class="n">run_job</span><span class="p" data-group-id="1992931581-8">(</span><span class="p" data-group-id="1992931581-8">)</span><span class="w">
        </span><span class="n">mark_job_as_executed</span><span class="p" data-group-id="1992931581-9">(</span><span class="p" data-group-id="1992931581-9">)</span><span class="w">
      </span><span class="k" data-group-id="1992931581-7">end</span><span class="w">
    </span><span class="k" data-group-id="1992931581-5">end</span><span class="p" data-group-id="1992931581-4">)</span><span class="w">
  </span><span class="k" data-group-id="1992931581-3">end</span><span class="w">
</span><span class="p" data-group-id="1992931581-1">)</span></code></pre>
<p>
In this version, <code class="inline">with_exclusive_lock</code> would be based on some shared locking mechanism, for example using database locks, or some distributed locking mechanism like <a href="https://erlang.org/doc/man/global.html">:global</a>.</p>
<h2>
Final thoughts</h2>
<p>
As an author, I’m admittedly very partial to Periodic. After all, I made it pretty much the way I wanted it. That said, I believe that it has some nice properties.</p>
<p>
With a small and intention-revealing interface, simple process structure, and OTP compliance, I believe that Periodic is a compelling choice for running periodical jobs directly in BEAM. Assuming nothing about the preferences of different clients, sticking to plain functions, and using a simple process structure make Periodic very flexible, and allow clients to use it however they want to. Building specialized abstractions on top of Periodic, such as the sketched <code class="inline">NaiveDaily</code> is possible and straightforward.</p>
<p>
The lack of dedicated support for fixed-time scheduling admittedly requires a bit more coding on the client part, but it also motivates the clients to consider the consequences and trade-offs. A naive solution, which should be roughly on par with what other similar libs are providing, is short and straightforward to implement. More demanding scenarios will require comparative effort in the code, but that’s something that can’t be avoided. On the plus side, all the approaches will share a similar pattern of <code class="inline">when: &amp;should_run?/0, run: &amp;run/0</code>, typically executed once a minute. Since the decision logic is implemented in Elixir, the client code has full freedom in the decision making process.</p>
<p>
In summary, I hope that this article will motivate you to give Periodic a try. If you spot some problems or have some feature proposals, feel free to open up an issue on the <a href="https://github.com/sasa1977/parent">project repo</a>.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2020, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/periodic">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/periodic.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate></item><item><title>Rethinking app env</title><link>http://theerlangelist.com//article/rethinking_app_env</link><description><![CDATA[<h1>Rethinking app env</h1>
<h4 class="right">2018-05-21</h4>

<div class="article-body">
<p>
What is app env, and what should we use it for? The Elixir docs <a href="https://hexdocs.pm/elixir/Application.html#module-application-environment">state</a>:</p>
<blockquote>
  <p>
OTP provides an application environment that can be used to configure the application.  </p>
</blockquote>
<p>
In my experience, an app env of a moderately complex system will typically contain the following things:</p>
<ul>
  <li>
Things which are system configuration  </li>
  <li>
Things which aren’t system configuration  </li>
  <li>
Things which, when modified at runtime, affect the system behaviour  </li>
  <li>
Things which, when modified at runtime, don’t affect the system behaviour  </li>
  <li>
Things which vary across different mix environments  </li>
  <li>
Things which don’t vary across different mix environments  </li>
  <li>
Things which are essentially code (e.g. MFA triplets and keys which are implicitly connected to some module)  </li>
</ul>
<p>
In other words, app env tends to degenerate into a bunch of key-values arbitrarily thrown into the same place. In this article I’ll try to reexamine the way we use app env, and its closely related Elixir cousin config scripts (<code class="inline">config.exs</code> and friends), and propose a different approach to configuring Elixir systems. The ideas I’ll present might sound heretical, so I should warn you upfront that at the point of writing this, it’s just my personal opinion, and not the community standard, nor the approach suggested by the Elixir core team.</p>
<p>
However, if you keep an open mind, you might find that these ideas might lead to some nice benefits:</p>
<ul>
  <li>
Better organized configuration code  </li>
  <li>
Complete flexibility to fetch configuration data from arbitrary sources  </li>
  <li>
Much less bloat in config scripts and app env  </li>
</ul>
<p>
There’s a long road ahead of us, so let’s kick off.</p>
<h2>
Live reconfiguration</h2>
<p>
Technically speaking, app env is a mechanism which allows us to keep some application specific data in memory. This data is visible to all processes of any app, and any process can change that data. Under the hood, the app env data sits in a publicly accessible ETS table named <code class="inline">:ac_tab</code>, so it has the same semantics as ETS.</p>
<p>
So what is it really good for? Let’s see a simple example. Suppose we need to run a periodic job, and we want to support runtime reconfiguration. A simple implementation could look like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">PeriodicJob</span><span class="w"> </span><span class="k" data-group-id="1428824348-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Task</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">start_link</span><span class="p" data-group-id="1428824348-2">(</span><span class="c">_arg</span><span class="p" data-group-id="1428824348-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">Task</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="1428824348-3">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">/</span><span class="mi">0</span><span class="p" data-group-id="1428824348-3">)</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">loop</span><span class="p" data-group-id="1428824348-4">(</span><span class="p" data-group-id="1428824348-4">)</span><span class="w"> </span><span class="k" data-group-id="1428824348-5">do</span><span class="w">
    </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Application</span><span class="o">.</span><span class="n">fetch_env!</span><span class="p" data-group-id="1428824348-6">(</span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="ss">:periodic_job</span><span class="p" data-group-id="1428824348-6">)</span><span class="w">
    </span><span class="nc">Process</span><span class="o">.</span><span class="n">sleep</span><span class="p" data-group-id="1428824348-7">(</span><span class="nc">Keyword</span><span class="o">.</span><span class="n">fetch!</span><span class="p" data-group-id="1428824348-8">(</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="ss">:interval</span><span class="p" data-group-id="1428824348-8">)</span><span class="p" data-group-id="1428824348-7">)</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="1428824348-9">(</span><span class="nc">Keyword</span><span class="o">.</span><span class="n">fetch!</span><span class="p" data-group-id="1428824348-10">(</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="ss">:message</span><span class="p" data-group-id="1428824348-10">)</span><span class="p" data-group-id="1428824348-9">)</span><span class="w">

    </span><span class="n">loop</span><span class="p" data-group-id="1428824348-11">(</span><span class="p" data-group-id="1428824348-11">)</span><span class="w">
  </span><span class="k" data-group-id="1428824348-5">end</span><span class="w">
</span><span class="k" data-group-id="1428824348-1">end</span></code></pre>
<p>
Notice in particular how we’re fetching the periodic job parameters from app env in every step of the loop. This allows us to reconfigure the behaviour at runtime. Let’s try it out:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">PeriodicJob</span><span class="w"> </span><span class="k" data-group-id="6706167997-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="6706167997-1">end</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="nc">Application</span><span class="o">.</span><span class="n">put_env</span><span class="p" data-group-id="6706167997-2">(</span><span class="w">
        </span><span class="ss">:my_system</span><span class="p">,</span><span class="w">
        </span><span class="ss">:periodic_job</span><span class="p">,</span><span class="w">
        </span><span class="ss">interval</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">seconds</span><span class="p" data-group-id="6706167997-3">(</span><span class="mi">1</span><span class="p" data-group-id="6706167997-3">)</span><span class="p">,</span><span class="w">
        </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Hello, World!&quot;</span><span class="w">
      </span><span class="p" data-group-id="6706167997-2">)</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="nc">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="6706167997-4">(</span><span class="p" data-group-id="6706167997-5">[</span><span class="nc">PeriodicJob</span><span class="p" data-group-id="6706167997-5">]</span><span class="p">,</span><span class="w"> </span><span class="ss">strategy</span><span class="p">:</span><span class="w"> </span><span class="ss">:one_for_one</span><span class="p" data-group-id="6706167997-4">)</span><span class="w">

</span><span class="nc">Hello</span><span class="p">,</span><span class="w"> </span><span class="nc">World</span><span class="o">!</span><span class="w">   </span><span class="c1"># after 1 sec</span><span class="w">
</span><span class="nc">Hello</span><span class="p">,</span><span class="w"> </span><span class="nc">World</span><span class="o">!</span><span class="w">   </span><span class="c1"># after 2 sec</span><span class="w">
</span><span class="n">...</span></code></pre>
<p>
Now, let’s reconfigure the system:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="nc">Application</span><span class="o">.</span><span class="n">put_env</span><span class="p" data-group-id="3592042617-1">(</span><span class="w">
        </span><span class="ss">:my_system</span><span class="p">,</span><span class="w">
        </span><span class="ss">:periodic_job</span><span class="p">,</span><span class="w">
        </span><span class="ss">interval</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">seconds</span><span class="p" data-group-id="3592042617-2">(</span><span class="mi">5</span><span class="p" data-group-id="3592042617-2">)</span><span class="p">,</span><span class="w">
        </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Hi, World!&quot;</span><span class="w">
      </span><span class="p" data-group-id="3592042617-1">)</span><span class="w">

</span><span class="nc">Hello</span><span class="p">,</span><span class="w"> </span><span class="nc">World</span><span class="o">!</span><span class="w">   </span><span class="c1"># after at most 1 sec</span><span class="w">
</span><span class="nc">Hi</span><span class="p">,</span><span class="w"> </span><span class="nc">World</span><span class="o">!</span><span class="w">      </span><span class="c1"># 5 seconds later</span><span class="w">
</span><span class="nc">Hi</span><span class="p">,</span><span class="w"> </span><span class="nc">World</span><span class="o">!</span><span class="w">      </span><span class="c1"># 10 seconds later</span></code></pre>
<p>
So in this example, we were able to reconfigure a running system without restarting it. It’s also worth noting that you can do the same thing in a system running in production, either via a remote <code class="inline">iex</code> shell or using the <code class="inline">:observer</code> tool.</p>
<p>
An important point is that this live reconfiguration works because the code doesn’t cache the app env data in a local variable. Instead, it refetches the configuration in every iteration. This is what gives us runtime configurability.</p>
<p>
In contrast, if a piece of data is fetched from app env only once, then changing it at runtime won’t affect the behaviour of the system. Let’s see an example. Suppose we’re writing a web server, and want to configure it via app env. A simple plug-based code could look like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MySystem.Site</span><span class="w"> </span><span class="k" data-group-id="5483647460-1">do</span><span class="w">
  </span><span class="na">@behaviour</span><span class="w"> </span><span class="nc">Plug</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">child_spec</span><span class="p" data-group-id="5483647460-2">(</span><span class="c">_arg</span><span class="p" data-group-id="5483647460-2">)</span><span class="w"> </span><span class="k" data-group-id="5483647460-3">do</span><span class="w">
    </span><span class="nc">Plug.Adapters.Cowboy2</span><span class="o">.</span><span class="n">child_spec</span><span class="p" data-group-id="5483647460-4">(</span><span class="w">
      </span><span class="ss">scheme</span><span class="p">:</span><span class="w"> </span><span class="ss">:http</span><span class="p">,</span><span class="w">
      </span><span class="ss">plug</span><span class="p">:</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w">
      </span><span class="ss">options</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5483647460-5">[</span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="nc">Application</span><span class="o">.</span><span class="n">fetch_env!</span><span class="p" data-group-id="5483647460-6">(</span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="ss">:http_port</span><span class="p" data-group-id="5483647460-6">)</span><span class="p" data-group-id="5483647460-5">]</span><span class="w">
    </span><span class="p" data-group-id="5483647460-4">)</span><span class="w">
  </span><span class="k" data-group-id="5483647460-3">end</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="5483647460-1">end</span><span class="w">
</span></code></pre>
<p>
Let’s say that the HTTP port is initially set to 4000. We start the system, and try to reconfigure it dynamically by changing the port to 5000:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="nc">Application</span><span class="o">.</span><span class="n">put_env</span><span class="p" data-group-id="5236523139-1">(</span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="ss">:http_port</span><span class="p">,</span><span class="w"> </span><span class="mi">5000</span><span class="p" data-group-id="5236523139-1">)</span></code></pre>
<p>
Unsurprisingly, this will not affect the behavior of the system. The system will still listen on port 4000. To force the change, you need to force restart the parent supervisor. Why the parent supervisor, and not the process? Because in this case the app env is fetched in <code class="inline">child_spec/1</code> which is only invoked while the parent is initializing.</p>
<p>
So, in this plug example, the site can theoretically be dynamically reconfigured, but doing it is quite clumsy. You need a very intimate knowledge of the code to reapply the app env setting. So for all practical intents and purposes, the port app env setting is constant.</p>
<p>
This begs the question: if an app env value is a constant which doesn’t affect the runtime behaviour, why keep it in app env in the first place? It’s one more layer of indirection, and so it has to be justified somehow.</p>
<p>
Some possible reasons for doing it would be:</p>
<ol>
  <li>
Varying configuration between different mix envs (dev, test, prod)  </li>
  <li>
Consolidating system configuration into a single place  </li>
  <li>
Dependency library requires it  </li>
</ol>
<p>
While the third scenario can’t be avoided, I believe that for the first two, app env and config scripts are far from perfect. To understand why, let’s look at some config scripts issues.</p>
<h2>
Context conflation</h2>
<p>
Suppose you need to use an external database in your system, say a PostgreSQL database, and you want to work with it via Ecto. Such scenario is common enough that even Phoenix will by default generate the Ecto repo configuration for you when you invoke <code class="inline">mix phx.new</code>:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># dev.exs</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w">
  </span><span class="ss">adapter</span><span class="p">:</span><span class="w"> </span><span class="nc">Ecto.Adapters.Postgres</span><span class="p">,</span><span class="w">
  </span><span class="ss">username</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;postgres&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">password</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;postgres&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;my_system_dev&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">hostname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;localhost&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">pool_size</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="w">

</span><span class="c1"># test.exs</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w">
  </span><span class="ss">adapter</span><span class="p">:</span><span class="w"> </span><span class="nc">Ecto.Adapters.Postgres</span><span class="p">,</span><span class="w">
  </span><span class="ss">username</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;postgres&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">password</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;postgres&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;my_system_test&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">hostname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;localhost&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">pool</span><span class="p">:</span><span class="w"> </span><span class="nc">Ecto.Adapters.SQL.Sandbox</span><span class="w">

</span><span class="c1"># prod.secret.exs</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w">
  </span><span class="ss">adapter</span><span class="p">:</span><span class="w"> </span><span class="nc">Ecto.Adapters.Postgres</span><span class="p">,</span><span class="w">
  </span><span class="ss">username</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;postgres&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">password</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;postgres&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;my_system_prod&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">pool_size</span><span class="p">:</span><span class="w"> </span><span class="mi">15</span></code></pre>
<p>
You get different database configurations in dev, test, and prod. The <code class="inline">prod.secret.exs</code> file is git-ignored so you can freely point it to the local database, without the fear of compromising production or committing production secrets.</p>
<p>
At first glance this looks great. We have varying configuration for different mix envs, and we have a way of running a prod-compiled version locally. However, this approach is not without its issues.</p>
<p>
One minor annoyance is that, since you can’t commit <code class="inline">prod.secret.exs</code> to the repo, every developer in the team will have to populate it manually. It’s not a big issue, but it is a bit clumsy. Ideally, the development setup would work out of the box.</p>
<p>
A more important issue is the production setup. If you’re running your system as an OTP release (which I strongly advise), you’ll need to host the secret file at the build server, not the production server. If you want to manage a separate staging server which uses a different database, you’ll need to somehow juggle with multiple secret configs on the build server, and separately compile the system for staging and production.</p>
<p>
The approach becomes unusable if you’re deploying your system on client premises, which is a case we have at Aircloak (for a brief description of our system, see <a href="https://elixirforum.com/t/aircloak-anonymized-analitycs/10930">this post</a>). In this scenario, the development team doesn’t know the configuration parameters, while the system admins don’t have the access to the code, nor Elixir/Erlang know-how. Therefore, config scripts can’t really work here.</p>
<p>
Let’s take a step back. The root cause of the mentioned problems is that by setting up different db parameters in different mix envs we’re conflating compilation and runtime contexts. In my view mix env (dev/test/prod) is a compilation concern which determines variations between compiled version. So for example, in dev we might configure auto code recompiling and reloading, while in prod we’ll turn that off. Likewise, in dev and test, we might disable some system services (e.g. fetching from a Twitter feed), or use fake replacements.</p>
<p>
However, a mix env shouldn’t assume anything about the execution context. I want to be able to run a prod compiled version locally, so I can do some local verification or benching for example. Likewise, once I assemble an OTP release for prod, in addition to running it on a production box, I want to run it on a staging server using a separate database.</p>
<p>
These are not scenarios which can be easily handled with config scripts, and so it follows that config scripts are not a good fit for specifying the differences between different execution contexts.</p>
<h2>
Config script execution time</h2>
<p>
A better way to specify these differences is to use an external configuration source, say an OS env, an externally supplied file, or a KV such as etcd.</p>
<p>
Let’s say that we decided to keep connection parameters in an OS env. The configuration code could look like this:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># config.exs</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w">
  </span><span class="ss">adapter</span><span class="p">:</span><span class="w"> </span><span class="nc">Ecto.Adapters.Postgres</span><span class="p">,</span><span class="w">
  </span><span class="ss">username</span><span class="p">:</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">get_env</span><span class="p" data-group-id="9404994089-1">(</span><span class="s">&quot;MY_SYSTEM_DB_USERNAME&quot;</span><span class="p" data-group-id="9404994089-1">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">password</span><span class="p">:</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">get_env</span><span class="p" data-group-id="9404994089-2">(</span><span class="s">&quot;MY_SYSTEM_DB_PASSWORD&quot;</span><span class="p" data-group-id="9404994089-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">get_env</span><span class="p" data-group-id="9404994089-3">(</span><span class="s">&quot;MY_SYSTEM_DB_DATABASE&quot;</span><span class="p" data-group-id="9404994089-3">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">hostname</span><span class="p">:</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">get_env</span><span class="p" data-group-id="9404994089-4">(</span><span class="s">&quot;MY_SYSTEM_DB_HOSTNAME&quot;</span><span class="p" data-group-id="9404994089-4">)</span><span class="w">

</span><span class="c1"># configure other variations in dev/test/prod.exs</span></code></pre>
<p>
And then, we can set different OS env vars on target machines, and now we can compile a prod version once, and run it on different boxes using different databases.</p>
<p>
However, this will lead you to another problem. In the current Elixir (1.6), config scripts are evaluated during compilation, not the runtime. So if you’re using OTP releases and assemble them on a separate build server (which is a practice I recommend for any real-life project), this simply won’t fly today. The env parameters are retrieved during compilation, not during runtime, and so you end up with the same problem.</p>
<p>
Admittedly, the Elixir team has plans to <a href="https://elixirforum.com/t/proposal-moving-towards-discoverable-config-files/14302">move the execution of config scripts to runtime</a>, which means that this issue will be solved in the future. However, if you need to fetch the data from an external source such as a json file or an etcd instance, then this change won’t help you. It’s essentially a chicken-and-egg problem: app env values need to be resolved before the apps are started, and so even at runtime, the config script needs to run before a dependency such as e.g. JSON decoder or an etcd client is loaded. Consequently, if you need to fetch a value using a dependency library, config scripts is not the place to do it.</p>
<p>
The thing is that config scripts are evaluated too soon. In the worst case, they’re evaluated during compilation on a build server, and in the best case they’re evaluated before any dependency is started. In contrast, the services of our system, such as repo, endpoint, or any other process, are started way later, sometimes even conditionally. Consequently, config scripts often force you to fetch the config values much sooner than the moment you actually need them.</p>
<h2>
Configuring at runtime</h2>
<p>
Given the issues outlined above, my strong opinion is that connection parameters to external services don’t belong to config scripts at all. So where do we configure the connection then? Previously, this required some trickery, but luckily Ecto and Phoenix have recently added an explicit support for runtime configuration in the shape of the <code class="inline">init/2</code> callback.</p>
<p>
So here’s one way how we could configure our database connection params:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="w"> </span><span class="k" data-group-id="5653643776-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ecto.Repo</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:my_system</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="5653643776-2">(</span><span class="c">_arg</span><span class="p">,</span><span class="w"> </span><span class="n">app_env_db_params</span><span class="p" data-group-id="5653643776-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w">
    </span><span class="p" data-group-id="5653643776-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">merge</span><span class="p" data-group-id="5653643776-4">(</span><span class="n">app_env_db_params</span><span class="p">,</span><span class="w"> </span><span class="n">db_config</span><span class="p" data-group-id="5653643776-5">(</span><span class="p" data-group-id="5653643776-5">)</span><span class="p" data-group-id="5653643776-4">)</span><span class="p" data-group-id="5653643776-3">}</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">db_config</span><span class="p" data-group-id="5653643776-6">(</span><span class="p" data-group-id="5653643776-6">)</span><span class="w"> </span><span class="k" data-group-id="5653643776-7">do</span><span class="w">
    </span><span class="p" data-group-id="5653643776-8">[</span><span class="w">
      </span><span class="ss">hostname</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="5653643776-9">(</span><span class="s">&quot;MY_SYSTEM_DB_HOST&quot;</span><span class="p" data-group-id="5653643776-9">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">username</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="5653643776-10">(</span><span class="s">&quot;MY_SYSTEM_DB_USER&quot;</span><span class="p" data-group-id="5653643776-10">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">password</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="5653643776-11">(</span><span class="s">&quot;MY_SYSTEM_DB_PASSWORD&quot;</span><span class="p" data-group-id="5653643776-11">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="5653643776-12">(</span><span class="s">&quot;MY_SYSTEM_DB_NAME&quot;</span><span class="p" data-group-id="5653643776-12">)</span><span class="w">
    </span><span class="p" data-group-id="5653643776-8">]</span><span class="w">
  </span><span class="k" data-group-id="5653643776-7">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">os_env!</span><span class="p" data-group-id="5653643776-13">(</span><span class="n">name</span><span class="p" data-group-id="5653643776-13">)</span><span class="w"> </span><span class="k" data-group-id="5653643776-14">do</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">get_env</span><span class="p" data-group-id="5653643776-15">(</span><span class="n">name</span><span class="p" data-group-id="5653643776-15">)</span><span class="w"> </span><span class="k" data-group-id="5653643776-16">do</span><span class="w">
      </span><span class="no">nil</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">raise</span><span class="w"> </span><span class="s">&quot;OS ENV </span><span class="si" data-group-id="5653643776-17">#{</span><span class="n">name</span><span class="si" data-group-id="5653643776-17">}</span><span class="s"> not set!&quot;</span><span class="w">
      </span><span class="n">value</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">value</span><span class="w">
    </span><span class="k" data-group-id="5653643776-16">end</span><span class="w">
  </span><span class="k" data-group-id="5653643776-14">end</span><span class="w">
</span><span class="k" data-group-id="5653643776-1">end</span></code></pre>
<p>
With this approach, we have moved the retrieval of connection params to runtime. When the repo process is starting, Ecto will first read the app config (configured through a config script), and then invoke <code class="inline">init/2</code> which can fill in the blanks. The big gain here is that <code class="inline">init/2</code> is running at runtime, while your application is starting and when your dependencies have already been started. Therefore, you can now freely invoke <code class="inline">System.get_env</code>, or <code class="inline">Jason.decode!</code>, or <code class="inline">EtcdClient.get</code>, or anything else that suits your purposes.</p>
<h2>
Consolidating service configuration</h2>
<p>
One issue with the code above is that it’s now more difficult to use a different database in the test environment. This could be worked around with a <code class="inline">System.put_env</code> call placed in <code class="inline">test_helper.exs</code>. However, that approach won’t fly if the source of truth is a file or an etcd instance. What we really want is the ability to bypass the OS env check in test environment, and enforce the database name in a different way.</p>
<p>
Config script give you a very convenient solution to this problem. You could provide the database name only in <code class="inline">test.exs</code>:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># test.exs</span><span class="w">

</span><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w"> </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;my_system_test&quot;</span></code></pre>
<p>
And then adapt the configuration code:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="w"> </span><span class="k" data-group-id="2206363625-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ecto.Repo</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:my_system</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="2206363625-2">(</span><span class="c">_arg</span><span class="p">,</span><span class="w"> </span><span class="n">app_env_db_params</span><span class="p" data-group-id="2206363625-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w">
    </span><span class="p" data-group-id="2206363625-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">merge</span><span class="p" data-group-id="2206363625-4">(</span><span class="n">app_env_db_params</span><span class="p">,</span><span class="w"> </span><span class="n">db_config</span><span class="p" data-group-id="2206363625-5">(</span><span class="n">app_env_db_params</span><span class="p" data-group-id="2206363625-5">)</span><span class="p" data-group-id="2206363625-4">)</span><span class="p" data-group-id="2206363625-3">}</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">db_config</span><span class="p" data-group-id="2206363625-6">(</span><span class="n">app_env_db_params</span><span class="p" data-group-id="2206363625-6">)</span><span class="w"> </span><span class="k" data-group-id="2206363625-7">do</span><span class="w">
    </span><span class="p" data-group-id="2206363625-8">[</span><span class="w">
      </span><span class="ss">hostname</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="2206363625-9">(</span><span class="s">&quot;MY_SYSTEM_DB_HOST&quot;</span><span class="p" data-group-id="2206363625-9">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">username</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="2206363625-10">(</span><span class="s">&quot;MY_SYSTEM_DB_USER&quot;</span><span class="p" data-group-id="2206363625-10">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">password</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="2206363625-11">(</span><span class="s">&quot;MY_SYSTEM_DB_PASSWORD&quot;</span><span class="p" data-group-id="2206363625-11">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">database</span><span class="p">:</span><span class="w">
        </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">get_lazy</span><span class="p" data-group-id="2206363625-12">(</span><span class="w">
          </span><span class="n">app_env_db_params</span><span class="p">,</span><span class="w">
          </span><span class="ss">:database</span><span class="p">,</span><span class="w">
          </span><span class="k" data-group-id="2206363625-13">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="2206363625-14">(</span><span class="s">&quot;MY_SYSTEM_DB_NAME&quot;</span><span class="p" data-group-id="2206363625-14">)</span><span class="w"> </span><span class="k" data-group-id="2206363625-13">end</span><span class="w">
        </span><span class="p" data-group-id="2206363625-12">)</span><span class="w">
    </span><span class="p" data-group-id="2206363625-8">]</span><span class="w">
  </span><span class="k" data-group-id="2206363625-7">end</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="2206363625-1">end</span></code></pre>
<p>
While this will fix the problem, the solution leaves a lot to be desired. At this point, the database is configured in different config scripts and in the repo module. I personally find this quite confusing. To grasp the database configuration in a particular mix env, you need to consider at least three different files: <code class="inline">config.exs</code>, <code class="inline">“#{Mix.env}.exs”</code>, and the repo module source file. To make matters worse, the config files will be bloated with other unrelated configurations (e.g. endpoint settings), and the database configuration could even be dispersed throughout the config in the shape of:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># config.exs</span><span class="w">

</span><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w">

</span><span class="c1"># tens or hundreds of lines later</span><span class="w">

</span><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w">

</span><span class="n">...</span></code></pre>
<p>
Let’s consider why do we even use config script in the first place. We already pulled database parameters to <code class="inline">init/2</code>, but why are other repo parameters still in config scripts? The reason is because it’s very convenient to encode variations between mix envs through config scripts. You just put stuff in the desired <code class="inline">“#{Mix.env}.exs”</code> and you’re good to go. However, you never get something for nothing, so you pay for this writing convenience by sacrificing the reading experience. Understanding the database configuration becomes much harder.</p>
<p>
A better reading experience would be if the entire database configuration was consolidated in one place. Since we need to determine some parameters at runtime, <code class="inline">init/2</code> has to be that place. But how can we encode variations between different mix envs? Luckilly, this is fairly simple with a light touch of Elixir metaprogramming:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">db_config</span><span class="p" data-group-id="8934386925-1">(</span><span class="p" data-group-id="8934386925-1">)</span><span class="w"> </span><span class="k" data-group-id="8934386925-2">do</span><span class="w">
  </span><span class="p" data-group-id="8934386925-3">[</span><span class="w">
    </span><span class="c1"># ...</span><span class="w">
    </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="n">db_name</span><span class="p" data-group-id="8934386925-4">(</span><span class="p" data-group-id="8934386925-4">)</span><span class="w">
  </span><span class="p" data-group-id="8934386925-3">]</span><span class="w">
</span><span class="k" data-group-id="8934386925-2">end</span><span class="w">

</span><span class="c1"># ...</span><span class="w">

</span><span class="k">if</span><span class="w"> </span><span class="nc">Mix</span><span class="o">.</span><span class="n">env</span><span class="p" data-group-id="8934386925-5">(</span><span class="p" data-group-id="8934386925-5">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:test</span><span class="w"> </span><span class="k" data-group-id="8934386925-6">do</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">db_name</span><span class="p" data-group-id="8934386925-7">(</span><span class="p" data-group-id="8934386925-7">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;my_system_test&quot;</span><span class="w">
</span><span class="k" data-group-id="8934386925-6">else</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">db_name</span><span class="p" data-group-id="8934386925-8">(</span><span class="p" data-group-id="8934386925-8">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="8934386925-9">(</span><span class="s">&quot;MY_SYSTEM_DB_NAME&quot;</span><span class="p" data-group-id="8934386925-9">)</span><span class="w">
</span><span class="k" data-group-id="8934386925-6">end</span></code></pre>
<p>
This code is somewhat more elaborate, but it’s now consolidated, and more explicit. This code clearly states that in the test env the database name is forced to a particular value, i.e. it’s not configurable. In contrast, the previous version is more vague about its constraints, and so leaves room for mistakes. If you’re renaming the repo module but forget to update the config script, you might end up running tests on your dev db and completely mess up your data.</p>
<p>
It’s worth noting that you should only ever invoke <code class="inline">Mix.env</code> during compilation, so either at the module level (i.e. outside of named functions), or inside an <code class="inline">unquote</code> expression. Mix is not available at runtime, and even if it were, <code class="inline">Mix.env</code> can’t possibly give you a meaningful result. Remember, mix env is a compilation context, and so you can’t get it at runtime.</p>
<p>
If you dislike the if/else noise of the last attempt, you can introduce a simple helper macro:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># ...</span><span class="w">

</span><span class="kd">defmacrop</span><span class="w"> </span><span class="nf">env_specific</span><span class="p" data-group-id="4503806593-1">(</span><span class="n">config</span><span class="p" data-group-id="4503806593-1">)</span><span class="w"> </span><span class="k" data-group-id="4503806593-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="4503806593-3">do</span><span class="w">
    </span><span class="k">unquote</span><span class="p" data-group-id="4503806593-4">(</span><span class="w">
      </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">get_lazy</span><span class="p" data-group-id="4503806593-5">(</span><span class="w">
        </span><span class="n">config</span><span class="p">,</span><span class="w">
        </span><span class="nc">Mix</span><span class="o">.</span><span class="n">env</span><span class="p" data-group-id="4503806593-6">(</span><span class="p" data-group-id="4503806593-6">)</span><span class="p">,</span><span class="w">
        </span><span class="k" data-group-id="4503806593-7">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Keyword</span><span class="o">.</span><span class="n">fetch!</span><span class="p" data-group-id="4503806593-8">(</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="ss">:else</span><span class="p" data-group-id="4503806593-8">)</span><span class="w"> </span><span class="k" data-group-id="4503806593-7">end</span><span class="w">
      </span><span class="p" data-group-id="4503806593-5">)</span><span class="w">
    </span><span class="p" data-group-id="4503806593-4">)</span><span class="w">
  </span><span class="k" data-group-id="4503806593-3">end</span><span class="w">
</span><span class="k" data-group-id="4503806593-2">end</span><span class="w">

</span><span class="c1"># ...</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">db_config</span><span class="p" data-group-id="4503806593-9">(</span><span class="p" data-group-id="4503806593-9">)</span><span class="w"> </span><span class="k" data-group-id="4503806593-10">do</span><span class="w">
  </span><span class="p" data-group-id="4503806593-11">[</span><span class="w">
    </span><span class="c1"># ...</span><span class="w">
    </span><span class="ss">database</span><span class="p">:</span><span class="w"> </span><span class="n">env_specific</span><span class="p" data-group-id="4503806593-12">(</span><span class="ss">test</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;my_system_test&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">else</span><span class="p">:</span><span class="w"> </span><span class="n">os_env!</span><span class="p" data-group-id="4503806593-13">(</span><span class="n">...</span><span class="p" data-group-id="4503806593-13">)</span><span class="p" data-group-id="4503806593-12">)</span><span class="w">
  </span><span class="p" data-group-id="4503806593-11">]</span><span class="w">
</span><span class="k" data-group-id="4503806593-10">end</span></code></pre>
<p>
Notice that this doesn’t change the semantics of the compiled code. Since <code class="inline">env_specific</code> is a macro, invoking it will make a compile-time decision to inject one code or another (a constant value or a function call). So for example, in test environment, the code <code class="inline">os_env!(…)</code> won’t be executed, nor even make it to the compiled version. Consequently, you can freely invoke anything you want here, such as json decoding, or fetching from etcd for example, and it will be executed at runtime, only in the desired mix env.</p>
<p>
As an added bonus, the <code class="inline">env_specific</code> macro requires that the value is specified for the current mix env, or that there’s an <code class="inline">:else</code> setting. The macro will complain at compile time if the value is not provided.</p>
<p>
To summarize, with a touch of metaprogramming we achieved the feature parity with config scripts, moved the retrieval of parameters to runtime, consolidated the repo configuration, and expressed variations between mix envs more clearly and with stronger guarantees. Not too shabby :-)</p>
<h2>
Consolidating system configuration</h2>
<p>
One frequent argument for app env and config scripts is that they allow us to consolidate all the parameters of the system in a single place. So, supposedly, config scripts become a go-to place which we can refer to when we want to see how some aspect of the system is configured.</p>
<p>
However, as soon as you want to configure external services, such as a database, you’re left with two choices:</p>
<ol>
  <li>
Shoehorn configuration into config scripts  </li>
  <li>
Move configuration to runtime  </li>
</ol>
<p>
In the first case, you’ll need to resort to all sorts of improvisations to make it work. As soon as you need to support multiple execution contexts, you’re in for a ride, and it won’t be fun :-). You might consider abandoning OTP releases completely, and just run <code class="inline">iex -S mix</code> in prod, which is IMO a very bad idea. Take my advice, and don’t go there :-)</p>
<p>
This leaves you with the second option: some system parameters will be retrieved at runtime. And at this point, config script ceases to be the single place where system parameters are defined.</p>
<p>
That’s not a bad thing though. To be honest, I think that config script is a poor place to consolidate configuration anyway. First of all, config scripts tend to be quite noisy, and contain all sorts of data, including the things which are not a part of system configuration at all.</p>
<p>
Consider the following configuration generated by Phoenix:</p>
<pre><code class="highlight makeup elixir"><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystem.Repo</span><span class="p">,</span><span class="w"> </span><span class="ss">adapter</span><span class="p">:</span><span class="w"> </span><span class="nc">Ecto.Adapters.Postgres</span><span class="p">,</span><span class="w"> </span><span class="n">...</span></code></pre>
<p>
Is database adapter really a configurable thing? Can you just change this to, say, MySql and everything will magically work? In my opinion, unless you’ve explicitly worked to support this scenario it will fail spectacularly. Therefore, the adapter is not a parameter to your system, and hence it doesn’t belong here.</p>
<p>
As an aside, at Aircloak, due to the nature of our system, the database adapter is a configurable parameter. However, what’s configured is not an Ecto adapter, but rather a particular setting specific to our system. That setting will affect how the system works with the database, but the internal variations are way more complex. Supporting different databases required a lot of work, beyond just passing one Ecto adapter or the other. We needed to support this scenario, and so we invested the effort to make it happen. If you don’t have such needs, then you don’t need to invest that effort, and database adapter is not your system’s configuration parameter. In theory you can change it, in practice you can’t :-)</p>
<p>
Here’s another example of a config bloat:</p>
<pre><code class="highlight makeup elixir"><span class="n">config</span><span class="w"> </span><span class="ss">:my_system</span><span class="p">,</span><span class="w"> </span><span class="nc">MySystemWeb.Endpoint</span><span class="p">,</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
  </span><span class="ss">render_errors</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4180883765-1">[</span><span class="ss">view</span><span class="p">:</span><span class="w"> </span><span class="nc">MySystemWeb.ErrorView</span><span class="p">,</span><span class="w"> </span><span class="ss">accepts</span><span class="p">:</span><span class="w"> </span><span class="sx">~w(html json)</span><span class="p" data-group-id="4180883765-1">]</span><span class="p">,</span><span class="w">
  </span><span class="ss">pubsub</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4180883765-2">[</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="nc">MySystem.PubSub</span><span class="p">,</span><span class="w"> </span><span class="ss">adapter</span><span class="p">:</span><span class="w"> </span><span class="nc">Phoenix.PubSub.PG2</span><span class="p" data-group-id="4180883765-2">]</span><span class="p">,</span><span class="w">
  </span><span class="c1"># ...</span></code></pre>
<p>
These things are not configuration parameters. While in theory we could construct a scenario where this needs to be configurable, in most cases it’s just YAGNI. These are the parameters of the library, not of the system, and hence they only add bloat to config scripts and app env.</p>
<p>
Another problem is that config scripts tend to be populated in an arbitrary way. My personal sentiment is that their content becomes a function of arbitrary decisions made by different people at different points in time. At best, developers make a sensible effort to keep things which “feels” like system configuration in config scripts. More often, the content of config scripts is determined the by demands of libraries, the defaults established by the code generators, and convenient ability to vary the values across different mix envs.</p>
<p>
In summary, the place for the supposed consolidated system configuration will contain:</p>
<ul>
  <li>
Some, but not all things which are system parameters  </li>
  <li>
Some things which are not system parameters  </li>
</ul>
<p>
Let’s take a step back here and consider why do we even want a consolidated system configuration.</p>
<p>
One reason could be to make it easier for developers to find the parameters of the system. So if we need to determine database connection parameters, the HTTP port, or a logging level, we can just open up the config script, and find it there.</p>
<p>
Personally, I have a hard time accepting this argument. First of all, the configuration IMO naturally belongs to the place which uses it. So if I’m interested in db connection parameters, I’d first look at the repo module. And if I want to know about the endpoint parameters, then I’d look at the endpoint module.</p>
<p>
Such approach also makes it easier to grasp the configuration. When I read config scripts, I’m spammed with a bunch of unrelated data which I neither care about at the moment, nor can hold together in my head. In contrast, when I read a consolidated repo config in isolation, I can more easily understand it.</p>
<p>
A more important reason for system config consolidation is to assist administration by external administrators. These people might not have the access to the source code, or maybe they’re not fluent in Elixir, so they can’t consult the code to discover system parameters. However, for the reasons I’ve stated above, I feel that config scripts won’t suffice for this task. As mentioned, database connection parameters will likely not be a part of the config script, and so the complete consolidation is already lost. In addition, if external admins are not fluent in Elixir, they could have problems understanding elixir scripts, especially if they are more dynamic.</p>
<p>
If you plan on assisting administration, consider using well understood external configuration sources, such as ini, env, or json files, or KVs such as etcd. If you do that, then app env will not be needed, and config scripts will not suffice anyway, so you’ll likely end up with some variation of the configuration style proposed above, which is performed at runtime.</p>
<p>
As a real-life example, the system we’re building at Aircloak is running on client premises, and has to be configured by the client’s administrators. We don’t have the access to their secrets, and they don’t have the access to our source code. To facilitate administration, we fetch system parameters from a json file which has to be provided by the administrators. We’ve explicitly and carefully cherry picked the parameters which belong to system configuration. Everything else is an implementation detail, and so it doesn’t cause bloat in the config. As a consequence, we know exactly which pieces of data can be provided in the configuration, and so we can validate the config file against a schema and fail fast if some key name is misspelled, or some data is not of the right type.</p>
<h2>
Configuring a Phoenix endpoint</h2>
<p>
Let’s take a look at a more involved example. This blog is powered by Phoenix, and the endpoint is completely configured at runtime. Therefore, the only endpoint-related config piece is the following:</p>
<pre><code class="highlight makeup elixir"><span class="n">config</span><span class="w"> </span><span class="ss">:erlangelist</span><span class="p">,</span><span class="w"> </span><span class="nc">Erlangelist.Web.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0356267433-1">[</span><span class="p" data-group-id="0356267433-1">]</span></code></pre>
<p>
The reason why we need an empty config is because Phoenix requires it.</p>
<p>
All of the endpoint parameters are provided in <code class="inline">init/2</code>:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Erlangelist.Web.Endpoint</span><span class="w"> </span><span class="k" data-group-id="6128288768-1">do</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="6128288768-2">(</span><span class="c">_key</span><span class="p">,</span><span class="w"> </span><span class="n">phoenix_defaults</span><span class="p" data-group-id="6128288768-2">)</span><span class="p">,</span><span class="w">
    </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6128288768-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Erlangelist.Web.EndpointConfig</span><span class="o">.</span><span class="n">config</span><span class="p" data-group-id="6128288768-4">(</span><span class="n">phoenix_defaults</span><span class="p" data-group-id="6128288768-4">)</span><span class="p" data-group-id="6128288768-3">}</span><span class="w">
</span><span class="k" data-group-id="6128288768-1">end</span></code></pre>
<p>
Since there are a lot of parameters and significant variations between different mix envs, I’ve decided to move the code into another module, to separate plug chaining from configuration assembly. The function <code class="inline">Erlangelist.Web.EndpointConfig.config/1</code> looks like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">config</span><span class="p" data-group-id="9208215426-1">(</span><span class="n">phoenix_defaults</span><span class="p" data-group-id="9208215426-1">)</span><span class="w"> </span><span class="k" data-group-id="9208215426-2">do</span><span class="w">
  </span><span class="n">phoenix_defaults</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">DeepMerge</span><span class="o">.</span><span class="n">deep_merge</span><span class="p" data-group-id="9208215426-3">(</span><span class="n">common_config</span><span class="p" data-group-id="9208215426-4">(</span><span class="p" data-group-id="9208215426-4">)</span><span class="p" data-group-id="9208215426-3">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">DeepMerge</span><span class="o">.</span><span class="n">deep_merge</span><span class="p" data-group-id="9208215426-5">(</span><span class="n">env_specific_config</span><span class="p" data-group-id="9208215426-6">(</span><span class="p" data-group-id="9208215426-6">)</span><span class="p" data-group-id="9208215426-5">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">configure_https</span><span class="p" data-group-id="9208215426-7">(</span><span class="p" data-group-id="9208215426-7">)</span><span class="w">
</span><span class="k" data-group-id="9208215426-2">end</span></code></pre>
<p>
Starting with the default values provided by Phoenix, we’ll apply some common settings, and then env-specific settings, and finally do some https specific tuning (which is needed due to auto certification with Let’s Encrypt).</p>
<p>
Note that I’m doing a deep merge here, since env specific settings might partially overlap with the common ones. Since, AFAIK, deep merging is not available in Elixir, I’ve resorted to the <a href="https://github.com/PragTob/deep_merge">DeepMerge</a> library.</p>
<p>
The common config determines the parameters which don’t vary between mix envs:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">common_config</span><span class="p" data-group-id="7500235776-1">(</span><span class="p" data-group-id="7500235776-1">)</span><span class="w"> </span><span class="k" data-group-id="7500235776-2">do</span><span class="w">
  </span><span class="p" data-group-id="7500235776-3">[</span><span class="w">
    </span><span class="ss">http</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7500235776-4">[</span><span class="ss">compress</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="mi">20080</span><span class="p" data-group-id="7500235776-4">]</span><span class="p">,</span><span class="w">
    </span><span class="ss">render_errors</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7500235776-5">[</span><span class="ss">view</span><span class="p">:</span><span class="w"> </span><span class="nc">Erlangelist.Web.ErrorView</span><span class="p">,</span><span class="w"> </span><span class="ss">accepts</span><span class="p">:</span><span class="w"> </span><span class="sx">~w(html json)</span><span class="p" data-group-id="7500235776-5">]</span><span class="p">,</span><span class="w">
    </span><span class="ss">pubsub</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7500235776-6">[</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="nc">Erlangelist.PubSub</span><span class="p">,</span><span class="w"> </span><span class="ss">adapter</span><span class="p">:</span><span class="w"> </span><span class="nc">Phoenix.PubSub.PG2</span><span class="p" data-group-id="7500235776-6">]</span><span class="w">
  </span><span class="p" data-group-id="7500235776-3">]</span><span class="w">
</span><span class="k" data-group-id="7500235776-2">end</span></code></pre>
<p>
Notice how the http port is hardcoded. The reason is because it’s the same in all mix envs, and on all host machines. It always has this particular value, and so it’s a constant, not a config parameter. In production, the request arrive on port 80. However, this is configured outside of Elixir, by using iptables to forward the port 80 to the port 20080. Doing so allows me to run the Elixir system as a non-privileged user.</p>
<p>
Since the variations between different envs are significant, I didn’t use the <code class="inline">env_specific</code> macro trick. Instead, I opted for the plain <code class="inline">Mix.env</code> based switch:</p>
<pre><code class="highlight makeup elixir"><span class="k">case</span><span class="w"> </span><span class="nc">Mix</span><span class="o">.</span><span class="n">env</span><span class="p" data-group-id="0872828679-1">(</span><span class="p" data-group-id="0872828679-1">)</span><span class="w"> </span><span class="k" data-group-id="0872828679-2">do</span><span class="w">
  </span><span class="ss">:dev</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kd">defp</span><span class="w"> </span><span class="nf">env_specific_config</span><span class="p" data-group-id="0872828679-3">(</span><span class="p" data-group-id="0872828679-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="c1"># dev parameters</span><span class="w">
  </span><span class="ss">:test</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kd">defp</span><span class="w"> </span><span class="nf">env_specific_config</span><span class="p" data-group-id="0872828679-4">(</span><span class="p" data-group-id="0872828679-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="c1"># test parameters</span><span class="w">
  </span><span class="ss">:prod</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kd">defp</span><span class="w"> </span><span class="nf">env_specific_config</span><span class="p" data-group-id="0872828679-5">(</span><span class="p" data-group-id="0872828679-5">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="c1"># prod parameters</span><span class="w">
</span><span class="k" data-group-id="0872828679-2">end</span></code></pre>
<p>
The complete version can be seen <a href="https://github.com/sasa1977/erlangelist/blob/70d664e5a7d71638aedb1bc0f12ece15995c49e3/site/lib/erlangelist_web/endpoint_config.ex#L24-L61">here</a>.</p>
<p>
This consolidation allows me to find the complete endpoint configuration in a single place - something which is not the case for config scripts. So now I can clearly see the differences between dev, test, and prod, without needing to simultaneously look at three different files, and a bunch of unrelated noise. It’s worth repeating that this code has the feature parity with config scripts. In particular, the dev- and the test-specific parameters won’t make it into the prod-compiled version.</p>
<h2>
Supporting runtime configurability</h2>
<p>
For fun and experiment, I also added a bit of runtime configurability which allows me to change some behaviour of the system without restarting anything.</p>
<p>
When this site is running, I keep some aggregated usage stats, so I can see the read count per each article. This is implemented in a quick &amp; dirty way using <code class="inline">:erlang.term_to_binary</code> and storing data into a file. I use a separate file for each day, and the system periodically deletes older files.</p>
<p>
The relevant code sits in the <code class="inline">Erlangelist.Core.UsageStats</code> module, which is also responsible for its own configuration. The configuration specifies how often is the in-memory data flushed to disk, how often is the cleanup code invoked, and how many files are preserved during the cleanup. Here are the relevant pieces of the configuration code:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Erlangelist.Core.UsageStats</span><span class="w"> </span><span class="k" data-group-id="8553578773-1">do</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">start_link</span><span class="p" data-group-id="8553578773-2">(</span><span class="c">_arg</span><span class="p" data-group-id="8553578773-2">)</span><span class="w"> </span><span class="k" data-group-id="8553578773-3">do</span><span class="w">
    </span><span class="n">init_config</span><span class="p" data-group-id="8553578773-4">(</span><span class="p" data-group-id="8553578773-4">)</span><span class="w">
    </span><span class="n">...</span><span class="w">
  </span><span class="k" data-group-id="8553578773-3">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">init_config</span><span class="p" data-group-id="8553578773-5">(</span><span class="p" data-group-id="8553578773-5">)</span><span class="p">,</span><span class="w">
    </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">Application</span><span class="o">.</span><span class="n">put_env</span><span class="p" data-group-id="8553578773-6">(</span><span class="ss">:erlangelist</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w"> </span><span class="n">config</span><span class="p" data-group-id="8553578773-7">(</span><span class="p" data-group-id="8553578773-7">)</span><span class="p" data-group-id="8553578773-6">)</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">config</span><span class="p" data-group-id="8553578773-8">(</span><span class="p" data-group-id="8553578773-8">)</span><span class="w"> </span><span class="k" data-group-id="8553578773-9">do</span><span class="w">
    </span><span class="p" data-group-id="8553578773-10">[</span><span class="w">
      </span><span class="ss">flush_interval</span><span class="p">:</span><span class="w">
        </span><span class="n">env_specific</span><span class="p" data-group-id="8553578773-11">(</span><span class="w">
          </span><span class="ss">prod</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">minutes</span><span class="p" data-group-id="8553578773-12">(</span><span class="mi">1</span><span class="p" data-group-id="8553578773-12">)</span><span class="p">,</span><span class="w">
          </span><span class="ss">else</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">seconds</span><span class="p" data-group-id="8553578773-13">(</span><span class="mi">1</span><span class="p" data-group-id="8553578773-13">)</span><span class="w">
        </span><span class="p" data-group-id="8553578773-11">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">cleanup_interval</span><span class="p">:</span><span class="w">
        </span><span class="n">env_specific</span><span class="p" data-group-id="8553578773-14">(</span><span class="w">
          </span><span class="ss">prod</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">hours</span><span class="p" data-group-id="8553578773-15">(</span><span class="mi">1</span><span class="p" data-group-id="8553578773-15">)</span><span class="p">,</span><span class="w">
          </span><span class="ss">else</span><span class="p">:</span><span class="w"> </span><span class="ss">:timer</span><span class="o">.</span><span class="n">minutes</span><span class="p" data-group-id="8553578773-16">(</span><span class="mi">1</span><span class="p" data-group-id="8553578773-16">)</span><span class="w">
        </span><span class="p" data-group-id="8553578773-14">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">retention</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="w">
    </span><span class="p" data-group-id="8553578773-10">]</span><span class="w">
  </span><span class="k" data-group-id="8553578773-9">end</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="8553578773-1">end</span></code></pre>
<p>
Just like with endpoint and repo, the configuration is encapsulated in the relevant module. However, since I want to support dynamic reconfiguration, I’m explicitly storing this config into the app env before I start the process. Finally, I only ever access these parameters by directly invoking <code class="inline">Application.fetch_env!</code> (see <a href="https://github.com/sasa1977/erlangelist/blob/70d664e5a7d71638aedb1bc0f12ece15995c49e3/site/lib/erlangelist/usage_stats.ex#L37">here</a> and <a href="https://github.com/sasa1977/erlangelist/blob/70d664e5a7d71638aedb1bc0f12ece15995c49e3/site/lib/erlangelist/usage_stats.ex#L49-L50">here</a>), without caching the values in variables. Therefore, changing any of these app env settings at runtime will affect the future behaviour of the system.</p>
<p>
As a result of this style of configuration, the config scripts become very lightweight:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># config.exs</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:logger</span><span class="p">,</span><span class="w"> </span><span class="ss">:console</span><span class="p">,</span><span class="w">
  </span><span class="ss">format</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;$time $metadata[$level] $message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">metadata</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3618203224-1">[</span><span class="ss">:user_id</span><span class="p" data-group-id="3618203224-1">]</span><span class="w">

</span><span class="n">config</span><span class="w"> </span><span class="ss">:erlangelist</span><span class="p">,</span><span class="w"> </span><span class="nc">Erlangelist.Web.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3618203224-2">[</span><span class="p" data-group-id="3618203224-2">]</span><span class="w">


</span><span class="c1"># dev.exs</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:logger</span><span class="p">,</span><span class="w"> </span><span class="ss">level</span><span class="p">:</span><span class="w"> </span><span class="ss">:debug</span><span class="p">,</span><span class="w"> </span><span class="ss">console</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3618203224-3">[</span><span class="ss">format</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;[$level] $message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p" data-group-id="3618203224-3">]</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:phoenix</span><span class="p">,</span><span class="w"> </span><span class="ss">:stacktrace_depth</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="w">


</span><span class="c1"># test.exs</span><span class="w">
</span><span class="n">config</span><span class="w"> </span><span class="ss">:logger</span><span class="p">,</span><span class="w"> </span><span class="ss">level</span><span class="p">:</span><span class="w"> </span><span class="ss">:warn</span></code></pre>
<p>
And the full app env of the <code class="inline">:erlangelist</code> app is very small, consisting mostly of parameters which can affect the runtime behaviour of the system:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="nc">Application</span><span class="o">.</span><span class="n">get_all_env</span><span class="p" data-group-id="8133123672-1">(</span><span class="ss">:erlangelist</span><span class="p" data-group-id="8133123672-1">)</span><span class="w">
</span><span class="p" data-group-id="8133123672-2">[</span><span class="w">
  </span><span class="p" data-group-id="8133123672-3">{</span><span class="nc">Erlangelist.Core.UsageStats</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="8133123672-4">[</span><span class="ss">flush_interval</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="ss">cleanup_interval</span><span class="p">:</span><span class="w"> </span><span class="mi">60000</span><span class="p">,</span><span class="w"> </span><span class="ss">retention</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p" data-group-id="8133123672-4">]</span><span class="p" data-group-id="8133123672-3">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="8133123672-5">{</span><span class="nc">Erlangelist.Web.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8133123672-6">[</span><span class="p" data-group-id="8133123672-6">]</span><span class="p" data-group-id="8133123672-5">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="8133123672-7">{</span><span class="ss">:included_applications</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8133123672-8">[</span><span class="p" data-group-id="8133123672-8">]</span><span class="p" data-group-id="8133123672-7">}</span><span class="w">
</span><span class="p" data-group-id="8133123672-2">]</span></code></pre>
<h2>
Libraries and app env</h2>
<p>
Sometimes a dependency will require some app env settings to be provided, and so you’ll need to use config scripts. For example, the logging level of the Logger application is best configured in a config script. Logger actually <a href="https://hexdocs.pm/logger/Logger.html#module-runtime-configuration">supports runtime configuration</a>, so you could set the logger level in your app start callback. However, at the point your app is starting, your dependencies are already started, so the setting might be applied too late. Thus such configuration is best done through a config script.</p>
<p>
There are also many libraries, both Erlang and Elixir ones, which needlessly require the parameters to be provided via app config. If you’re a library author, be very cautious about opting for such interface. In most cases, a plain functional interface, where you take all the options as function parameters, will suffice. Alternatively (or as well), you could support a callback similarly to Ecto and Phoenix, where you invoke the <code class="inline">init</code> callback function, allowing the clients to provide the configuration at runtime.</p>
<p>
There are some cases where requiring app config is the best choice (a good example is the aforementioned Logger), but such scenarios are few and far between. More often than not, a plain functional interface will be a superior option. Besides keeping things simple, and giving maximum flexibility to your users, you’ll also be able to better document and enforce the parameter types via typespecs.</p>
<p>
I’d also like to caution against keeping code references in config scripts. MFAs or atoms which are implicitly tied to modules in the compiled code are an accident waiting to happen. If you rename the module, but forget to update the config, things will break. If you’re lucky, they will break abruptly in tests. If not, they will silently not work in prod, and you might face all sorts of strange issues which will be hard to troubleshoot.</p>
<p>
If you’re a library author, try not to enforce your users to set a <code class="inline">Foo.Bar</code> app env key and define the module of the same name. This is rarely a good approach, if ever. There will be occasional cases where e.g. a module needs to be provided via app config. A good example is plugging custom log backends into the logger. But, again, such situations are not common, so think hard before making that choice. In most cases taking functions or callback modules via parameters will be a better option.</p>
<h2>
Final thoughts</h2>
<p>
In my impression, Elixir projects tend to overuse config scripts and app env. The reasons are likely historic. As far as I remember, even pure Erlang libraries frequently required, or at least promoted, app envs with no particular technical reasons.</p>
<p>
I feel that this overuse is further amplified by Elixir config scripts, which are admittedly very convenient. They simplify the writing process, but they also make it easy to add bloat to app env. Consequently, we end up with config scripts which don’t describe the complete system configuration, but frequently contain things which are not configuration at all. Since they are executed at compile time, the config scripts can cause a lot of confusion, and will not work if you need to fetch parameters from other sources, such as OS env. Even if the Elixir team manages to move config execution to runtime, they will still likely be limited in what they can offer. Fetching from sources such as etcd or external files (json, ini) will require different solutions.</p>
<p>
In my opinion, a better approach is to drive configuration retrieval at runtime, from the place which actually needs it. Fetch the site configuration in the endpoint module, and the repo configuration in the repo module. That will separate different configuration concerns, but will consolidate the parameters which naturally belong together. Most importantly, it will shift the configuration retrieval to runtime, giving you a much higher degree of flexibility.</p>
<p>
Keep in mind that app env is just another data storage, and not a central place for all config parameters. That storage has its pros and cons, and so use it accordingly. If you read the data from app env only once during startup, then why do you need app env in the first place? If you’re copying the data from OS env to app env, why not just skip app env and always read it from an OS env instead? If you need to cache some parameters to avoid frequent roundtrips to an external storage, consider using a dedicated ets table or a caching library such as Cachex.</p>
<p>
Since app env values can be changed at runtime, limit the app env usage to the pieces of data which can be used to change the system behaviour. Even in those cases, you’ll likely be better of without config scripts. Define the configuration data in the place where it is used, not in a common k-v store.</p>
<p>
When your dependency requires an app env during its startup, your best option is to provide it via a config script. If you use config scripts only in such cases, they will be much smaller and easier to grasp. If you feel that the library needlessly requires app env setting, contact the maintainers and see if it can be improved.</p>
<p>
Be careful about using config scripts to vary the behaviour between different mix envs. You can achieve the same effect with bit of Elixir metaprogramming. Doing so will help you consolidate your configuration, and keep the things which are not system parameters outside of app env and config script. Keep in mind that <code class="inline">Mix</code> functions shouldn’t be invoked at runtime, and that <code class="inline">Mix.env</code> has no meaning at runtime.</p>
<p>
Make the distinction between compile time and execution contexts. If you compile with <code class="inline">MIX_ENV=prod</code>, you’ve compiled a production version, not the version that can only run on a production box. A prod compiled code should be easily invokable on a dev box, and on a staging machine. Consequently, variations between execution contexts are not variations between compilation contexts, and thus don’t belong to configuration scripts, nor any other mechanism relying on <code class="inline">Mix.env</code>.</p>
<p>
Finally, if you do want to consolidate your system parameters to assist external administrators, consider using well understood formats, such as env, ini, or json files, or storages such as etcd. Cherry pick the parameters which are relevant, and leave out the ones which are implementation details. Doing so will keep your configuration in check, and make it possible to validate it during startup.</p>
<p>
As a final parting gift, here is some recommended further reading:</p>
<ul>
  <li>
<a href="https://hexdocs.pm/elixir/master/library-guidelines.html#avoid-application-configuration">Avoid application configuration section, library guidelines of the official Elixir docs</a>  </li>
  <li>
<a href="https://michal.muskala.eu/2017/07/30/configuring-elixir-libraries.html">Configuring Elixir libraries, Michał Muskała</a>  </li>
  <li>
<a href="https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/">Best practices for deploying Elixir apps, Jake Morrison</a>  </li>
</ul>
<p>
Happy configuring! :-)</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2018, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/rethinking_app_env">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/rethinking_app_env.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate></item><item><title>To spawn, or not to spawn?</title><link>http://theerlangelist.com//article/spawn_or_not</link><description><![CDATA[<h1>To spawn, or not to spawn?</h1>
<h4 class="right">2017-04-04</h4>

<div class="article-body">
<p>
That is indeed the question! Whether it is better to keep everything in a single process, or to have a separate process for every piece of state we need to manage? In this post I’ll talk a bit about using and not using processes. I’ll also discuss how to separate complex stateful logic from concerns such as temporal behaviour and cross process communication.</p>
<p>
But before starting, since this is going to be a long article, I want to immediately share my main points:</p>
<ul>
  <li>
Use functions and modules to separate thought concerns.  </li>
  <li>
Use processes to separate runtime concerns.  </li>
  <li>
Do not use processes (not even agents) to separate thought concerns.  </li>
</ul>
<p>
The construct “thought concern” here refers to ideas which exist in our mind, such as order, order item, and product for example. If those concepts are more complex, it’s worth implementing them in separate modules and functions to separate different concerns and keep each part of our code focused and concise.</p>
<p>
Using processes (e.g. agents) for this is a mistake I see people make frequently. Such approach essentially sidesteps the functional part of Elixir, and instead attempts to simulate objects with processes. The implementation will very likely be inferior to the plain FP approach (or even an equivalent in an OO language). Keep in mind that there is a price associated with processes (memory and communication overhead). Therefore, reach for processes when there are some tangible benefits which justify that price. Code organization is not among those benefits, so that’s not a good reason for using processes.</p>
<p>
Processes are used to address runtime concerns - properties which can be observed in a running system. For example, you’ll want to reach for multiple processes when you want to prevent a failure of one job to affect other activities in the system. Another motivation is when you want to introduce a potential for parallelism, allowing multiple jobs to run simultaneously. This can improve your performance, and open up potential for scaling in both directions. There are some other, less common cases for using processes, but again - separation of thought concerns is not one of them.</p>
<h2>
An example</h2>
<p>
But how do we manage a complex state then, if not with agents and processes? Let me illustrate the idea through a simple domain model of a reduced, and a slightly modified version of the blackjack game. The code I’ll show you (available <a href="https://github.com/sasa1977/erlangelist/tree/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack">here</a>) powers a single <strong>round</strong> on the blackjack table.</p>
<p>
A round is basically a sequence of <strong>hands</strong>, with each hand belonging to a different player. The round starts with the first hand. The player is initially given two cards and then makes a move: take one more card (a hit), or take a stand. In the former case, another card is given to the player. If the score of the player’s hand is greater than 21, the player is busted. Otherwise, the player can take another move (hit or stand).</p>
<p>
The score of the hand is the sum of all the values of the cards, with numerical ranks (2-10) having their respective values, while jack, queen, and king have the value of 10. An ace card can be valued as 1 or as 11, whichever gives a better (but not busted) score.</p>
<p>
The hand is finished if the player stands or busts. When a hand is finished, the round moves to the next hand. Once all the hands have been played, the winners are non-busted hands with the highest score.</p>
<p>
To keep things simple, I didn’t deal with concepts such as dealer, betting, insurance, splitting, multiple rounds, people joining or leaving the table.</p>
<h2>
Process boundaries</h2>
<p>
So, we need to keep track of different types of states which change over time: a deck of cards, hands of each player, and the state of the round. A naive take on this, would be use multiple processes. We could have one process per each hand, another process for the deck of cards, and the “master” process that drives the entire round. I see people occasionally take similar approach, but I’m not at all convinced that it’s the proper way to go. The main reason is that the game is in its nature highly synchronized. Things happen one by one in a well defined order: I get my cards, I make one or more moves, and when I’m done, you’re next. At any point in time, there’s only one activity happening in a single round.</p>
<p>
Using multiple processes to power a single round is therefore going to do more harm than good. With multiple processes, everything is concurrent, so you need to make additional effort to synchronize all the actions. You’ll also need to pay attention to proper process termination and cleanup. If you stop the round process, you need to stop all the associated processes as well. The same should hold in the case of a crash: an exception in a round, or a deck process should likely terminate everything (because the state is corrupt beyond repair). Maybe a crash of a single hand could be isolated, and that might improve fault-tolerance a bit, but I think this is a too fine level to be concerned about fault isolation.</p>
<p>
So in this case, I see many potential downsides, and not a lot of benefits for using multiple processes to manage the state of a single round. However, different rounds are mutually independent. They have their own separate flows, hold their separate states, share nothing in common. Thus, managing multiple rounds in a single process is counter productive. It will increase our error surface (failure of one round will take everything down), and possibly lead to worse performance (we’re not using multiple cores), or bottlenecks (a long processing in a single round will paralyze all the others). There are clear wins if we’re running different rounds in separate processes, so that decision is a no-brainer :-)</p>
<p>
I frequently say in my talks, that there’s a huge potential for concurrency in complex systems, so we’ll use a lot of processes. But to reap those benefits, we need to use processes where they make sense.</p>
<p>
So, all things considered, I’m pretty certain that a single process for managing the entire state of a single round is the way to go. It would be interesting to see what would change if we introduced the concept of a table, where rounds are played perpetually, and players change over time. I can’t say for certain at this point, but I think it’s an interesting exercise in case you want to explore it :-)</p>
<h2>
Functional modeling</h2>
<p>
So, how can we separate different concerns without using multiple processes? By using functions and modules, of course. If we spread different parts of the logic across different functions, give those functions proper names, and maybe organize them into properly named modules, we can represent our ideas just fine, without needing to simulate objects with agents.</p>
<p>
Let me show you what I mean by walking you through each part of my solution, starting with the simplest one.</p>
<h3>
A deck of cards</h3>
<p>
The first concept I want to capture is a deck of card. We want to model a standard deck of 52 cards. We want to start with a shuffled deck, and then be able to take cards from it, one by one.</p>
<p>
This is certainly a stateful concept. Every time we take a card, the state of the deck changes. Despite that, we can implement the deck with pure functions.</p>
<p>
Let me show you the code. I decided to represent the deck as a list of cards, each card being a map holding a rank and a suit. I can generate all the cards during compilation:</p>
<pre><code class="highlight makeup elixir"><span class="na">@cards</span><span class="w"> </span><span class="p" data-group-id="1248092370-1">(</span><span class="w">
  </span><span class="k">for</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="1248092370-2">[</span><span class="ss">:spades</span><span class="p">,</span><span class="w"> </span><span class="ss">:hearts</span><span class="p">,</span><span class="w"> </span><span class="ss">:diamonds</span><span class="p">,</span><span class="w"> </span><span class="ss">:clubs</span><span class="p" data-group-id="1248092370-2">]</span><span class="p">,</span><span class="w">
      </span><span class="n">rank</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="1248092370-3">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="ss">:jack</span><span class="p">,</span><span class="w"> </span><span class="ss">:queen</span><span class="p">,</span><span class="w"> </span><span class="ss">:king</span><span class="p">,</span><span class="w"> </span><span class="ss">:ace</span><span class="p" data-group-id="1248092370-3">]</span><span class="p">,</span><span class="w">
    </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1248092370-4">%{</span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="n">suit</span><span class="p">,</span><span class="w"> </span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="n">rank</span><span class="p" data-group-id="1248092370-4">}</span><span class="w">
</span><span class="p" data-group-id="1248092370-1">)</span></code></pre>
<p>
Now, I can add the <code class="inline">shuffle/0</code> function to instantiate a shuffled deck:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">shuffled</span><span class="p" data-group-id="1057994286-1">(</span><span class="p" data-group-id="1057994286-1">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w">
  </span><span class="nc">Enum</span><span class="o">.</span><span class="n">shuffle</span><span class="p" data-group-id="1057994286-2">(</span><span class="na">@cards</span><span class="p" data-group-id="1057994286-2">)</span></code></pre>
<p>
And finally, <code class="inline">take/1</code>, which takes the top card from the deck:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">take</span><span class="p" data-group-id="4856078284-1">(</span><span class="p" data-group-id="4856078284-2">[</span><span class="n">card</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">rest</span><span class="p" data-group-id="4856078284-2">]</span><span class="p" data-group-id="4856078284-1">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w">
  </span><span class="p" data-group-id="4856078284-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">card</span><span class="p">,</span><span class="w"> </span><span class="n">rest</span><span class="p" data-group-id="4856078284-3">}</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">take</span><span class="p" data-group-id="4856078284-4">(</span><span class="p" data-group-id="4856078284-5">[</span><span class="p" data-group-id="4856078284-5">]</span><span class="p" data-group-id="4856078284-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w">
  </span><span class="p" data-group-id="4856078284-6">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:empty</span><span class="p" data-group-id="4856078284-6">}</span></code></pre>
<p>
The <code class="inline">take/1</code> function returns either <code class="inline">{:ok, card_taken, rest_of_the_deck}</code>, or <code class="inline">{:error, :empty}</code>. Such interface forces a client (a user of the deck abstraction) to explicitly decide how to deal with each case.</p>
<p>
Here’s how we can use it:</p>
<pre><code class="highlight makeup elixir"><span class="n">deck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">shuffled</span><span class="p" data-group-id="4100365625-1">(</span><span class="p" data-group-id="4100365625-1">)</span><span class="w">

</span><span class="k">case</span><span class="w"> </span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">take</span><span class="p" data-group-id="4100365625-2">(</span><span class="n">deck</span><span class="p" data-group-id="4100365625-2">)</span><span class="w"> </span><span class="k" data-group-id="4100365625-3">do</span><span class="w">
  </span><span class="p" data-group-id="4100365625-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">card</span><span class="p">,</span><span class="w"> </span><span class="n">transformed_deck</span><span class="p" data-group-id="4100365625-4">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="c1"># do something with the card and the transform deck</span><span class="w">
  </span><span class="p" data-group-id="4100365625-5">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:empty</span><span class="p" data-group-id="4100365625-5">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="c1"># deck is empty -&gt; do something else</span><span class="w">
</span><span class="k" data-group-id="4100365625-3">end</span></code></pre>
<p>
This is an example of what I like to call a “functional abstraction”, which is a fancy name for:</p>
<ul>
  <li>
a bunch of related functions,  </li>
  <li>
with descriptive names,  </li>
  <li>
which exhibit no side-effects,  </li>
  <li>
and are maybe extracted in a separate module  </li>
</ul>
<p>
This to me is what corresponds to classes and objects in OO. In an OO language, I might have a <code class="inline">Deck</code> class with corresponding methods, here I have a <code class="inline">Deck</code> module with corresponding functions. Preferably (though not always worth the effort), functions only transform data, without dealing with temporal logic or side-effects (cross-process messaging, database, network requests, timeouts, …).</p>
<p>
It’s less important whether these functions are sitting in a dedicated module. The code for this abstraction is quite simple and it’s used in only one place. Therefore, I could have also defined private <code class="inline">shuffled_deck/0</code> and <code class="inline">take_card/1</code> functions in the client module. This is in fact what I frequently do if the code is small enough. I can always extract later, if things become more complicated.</p>
<p>
The important point is that the deck concept is powered by pure functions. No need to reach for an agent to manage a deck of cards.</p>
<p>
The complete code of the module is available <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/deck.ex">here</a>.</p>
<h3>
A blackjack hand</h3>
<p>
The same technique can be used to manage a hand. This abstraction keeps track of cards in the hand. It also knows how to calculate the score, and determine the hand status (<code class="inline">:ok</code> or <code class="inline">:busted</code>). The implementation resides in the <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/hand.ex">Blackjack.Hand</a> module.</p>
<p>
The module has two functions. We use <code class="inline">new/0</code> to instantiate the hand, and then <code class="inline">deal/2</code> to deal a card to the hand. Here’s an example that combines a hand and a deck:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># create a deck</span><span class="w">
</span><span class="n">deck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">shuffled</span><span class="p" data-group-id="2210322173-1">(</span><span class="p" data-group-id="2210322173-1">)</span><span class="w">

</span><span class="c1"># create a hand</span><span class="w">
</span><span class="n">hand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Hand</span><span class="o">.</span><span class="n">new</span><span class="p" data-group-id="2210322173-2">(</span><span class="p" data-group-id="2210322173-2">)</span><span class="w">

</span><span class="c1"># draw one card from the deck</span><span class="w">
</span><span class="p" data-group-id="2210322173-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">card</span><span class="p">,</span><span class="w"> </span><span class="n">deck</span><span class="p" data-group-id="2210322173-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">take</span><span class="p" data-group-id="2210322173-4">(</span><span class="n">deck</span><span class="p" data-group-id="2210322173-4">)</span><span class="w">

</span><span class="c1"># give the card to the hand</span><span class="w">
</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Hand</span><span class="o">.</span><span class="n">deal</span><span class="p" data-group-id="2210322173-5">(</span><span class="n">hand</span><span class="p">,</span><span class="w"> </span><span class="n">card</span><span class="p" data-group-id="2210322173-5">)</span></code></pre>
<p>
The result of <code class="inline">deal/2</code> will be in shape of <code class="inline">{hand_status, transformed_hand}</code>, where <code class="inline">hand_status</code> is either <code class="inline">:ok</code> or <code class="inline">:busted</code>.</p>
<h3>
Blackjack round</h3>
<p>
This abstraction, powered by the <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/round.ex">Blackjack.Round</a> module, ties everything together. It has following responsibilities:</p>
<ul>
  <li>
keeping the state of the deck  </li>
  <li>
keeping the state of all the hands in a round  </li>
  <li>
deciding who’s the next player to move  </li>
  <li>
accepting and interpreting player moves (hit/stand)  </li>
  <li>
taking cards from the deck and passing them to current hand  </li>
  <li>
computing the winner, once all the hands are resolved  </li>
</ul>
<p>
The round abstraction will follow the same functional approach as deck and hand. However, there’s an additional twist here, which concerns separation of the temporal logic. A round takes some time and requires interaction with players. For example, when the round starts, the first player needs to be informed about the first two card they got, and then they need to be informed that it’s their turn to make a move. The round then needs to wait until the player makes the move, and only then can it step forward.</p>
<p>
My impression is that many people, experienced Erlangers/Elixorians included, would implement the concept of a round directly in a GenServer or <code class="inline">:gen_statem</code>. This would allow them to manage the round state and temporal logic (such as communicating with players) in the same place.</p>
<p>
However, I believe that these two aspects need to be separated, since they are both potentially complex. The logic of a single round is already somewhat involved, and it can only get worse if we want to support additional aspects of the game, such as betting, splitting, or dealer player. Communicating with players has its own challenges if we want to deal with netsplits, crashes, slow or unresponsive clients. In these cases we might need to support retries, maybe add some persistence, event sourcing, or whatnot.</p>
<p>
I don’t want to combine these two complex concerns together, because they’ll become entangled, and it will be harder to work with the code. I want to move temporal concerns somewhere else, and have a pure domain model of a blackjack round.</p>
<p>
So instead I opted for an approach I don’t see that often. I captured the concept of a round in a plain functional abstraction.</p>
<p>
Let me show you the code. To instantiate a new round, I need to call <code class="inline">start/1</code>:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="8953805375-1">{</span><span class="n">instructions</span><span class="p">,</span><span class="w"> </span><span class="n">round</span><span class="p" data-group-id="8953805375-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Round</span><span class="o">.</span><span class="n">start</span><span class="p" data-group-id="8953805375-2">(</span><span class="p" data-group-id="8953805375-3">[</span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p" data-group-id="8953805375-3">]</span><span class="p" data-group-id="8953805375-2">)</span></code></pre>
<p>
The argument I need to pass is the list of player ids. These can be arbitrary terms, and will be used by the abstraction for various purposes:</p>
<ul>
  <li>
instantiating a hand for each player  </li>
  <li>
keeping track of the current player  </li>
  <li>
issuing notifications to players  </li>
</ul>
<p>
The function returns a tuple. The first element of the tuple is a list of instructions. In this example, it will be:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="2953393609-1">[</span><span class="w">
  </span><span class="p" data-group-id="2953393609-2">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2953393609-3">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2953393609-4">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:hearts</span><span class="p" data-group-id="2953393609-4">}</span><span class="p" data-group-id="2953393609-3">}</span><span class="p" data-group-id="2953393609-2">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="2953393609-5">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2953393609-6">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2953393609-7">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:diamonds</span><span class="p" data-group-id="2953393609-7">}</span><span class="p" data-group-id="2953393609-6">}</span><span class="p" data-group-id="2953393609-5">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="2953393609-8">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="ss">:move</span><span class="p" data-group-id="2953393609-8">}</span><span class="w">
</span><span class="p" data-group-id="2953393609-1">]</span></code></pre>
<p>
The instructions are the way the abstraction informs its client what needs to be done. As soon as we start the round, two cards are given to the first hand, and then the round instance awaits for the move by the player. So in this example, the abstraction instructs us to:</p>
<ul>
  <li>
notify player 1 that it got 4 of hearts  </li>
  <li>
notify player 1 that it got 8 of diamonds  </li>
  <li>
notify player 1 that it needs to make a move  </li>
</ul>
<p>
It is the responsibility of the client code to actually deliver these notifications to concerned players. The client code can be say a GenServer, which will send messages to player processes. It will also wait for the players to report back when they want to interact with the game. This is temporal logic, and it’s completely kept outside of the <code class="inline">Round</code> module.</p>
<p>
The second element of the returned tuple, called <code class="inline">round</code>, is the state of the round itself. It’s worth noting that this data is <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/round.ex#L10">typed as opaque</a>. This means that client shouldn’t read the data inside the <code class="inline">round</code> variable. Everything the client needs will be delivered in the <code class="inline">instruction</code> list.</p>
<p>
Let’s take this round instance one step further, by taking another card as player 1:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="7412115519-1">{</span><span class="n">instructions</span><span class="p">,</span><span class="w"> </span><span class="n">round</span><span class="p" data-group-id="7412115519-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Round</span><span class="o">.</span><span class="n">move</span><span class="p" data-group-id="7412115519-2">(</span><span class="n">round</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="ss">:hit</span><span class="p" data-group-id="7412115519-2">)</span></code></pre>
<p>
I need to pass the player id, so the abstraction can verify if the right player is making the move. If I pass the wrong id, the abstraction will instruct me to notify the player that it’s not their turn.</p>
<p>
Here are the instructions I got:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="3484263218-1">[</span><span class="w">
  </span><span class="p" data-group-id="3484263218-2">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3484263218-3">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3484263218-4">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:spades</span><span class="p" data-group-id="3484263218-4">}</span><span class="p" data-group-id="3484263218-3">}</span><span class="p" data-group-id="3484263218-2">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="3484263218-5">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="ss">:busted</span><span class="p" data-group-id="3484263218-5">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="3484263218-6">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3484263218-7">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3484263218-8">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="ss">:ace</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:spades</span><span class="p" data-group-id="3484263218-8">}</span><span class="p" data-group-id="3484263218-7">}</span><span class="p" data-group-id="3484263218-6">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="3484263218-9">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3484263218-10">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3484263218-11">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="ss">:jack</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:spades</span><span class="p" data-group-id="3484263218-11">}</span><span class="p" data-group-id="3484263218-10">}</span><span class="p" data-group-id="3484263218-9">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="3484263218-12">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="ss">:move</span><span class="p" data-group-id="3484263218-12">}</span><span class="w">
</span><span class="p" data-group-id="3484263218-1">]</span></code></pre>
<p>
This list tells me that player 1 got 10 of spades. Since it previously had 4 of hearts and 8 of diamonds, the player is busted, and the round immediately moves to the next hand. The client is instructed to notify player 2 that it got two cards, and that it should make a move.</p>
<p>
Let’s make a move on behalf of player 2:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="6605557394-1">{</span><span class="n">instructions</span><span class="p">,</span><span class="w"> </span><span class="n">round</span><span class="p" data-group-id="6605557394-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blackjack.Round</span><span class="o">.</span><span class="n">move</span><span class="p" data-group-id="6605557394-2">(</span><span class="n">round</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="ss">:stand</span><span class="p" data-group-id="6605557394-2">)</span><span class="w">

</span><span class="c1"># instructions:</span><span class="w">
</span><span class="p" data-group-id="6605557394-3">[</span><span class="w">
  </span><span class="p" data-group-id="6605557394-4">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6605557394-5">{</span><span class="ss">:winners</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6605557394-6">[</span><span class="ss">:player_2</span><span class="p" data-group-id="6605557394-6">]</span><span class="p" data-group-id="6605557394-5">}</span><span class="p" data-group-id="6605557394-4">}</span><span class="w">
  </span><span class="p" data-group-id="6605557394-7">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6605557394-8">{</span><span class="ss">:winners</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6605557394-9">[</span><span class="ss">:player_2</span><span class="p" data-group-id="6605557394-9">]</span><span class="p" data-group-id="6605557394-8">}</span><span class="p" data-group-id="6605557394-7">}</span><span class="w">
</span><span class="p" data-group-id="6605557394-3">]</span></code></pre>
<p>
Player 2 didn’t take another card, and therefore its hand is completed. The abstraction immediately resolves the winner and instructs us to inform both players about the outcome.</p>
<p>
Let’s take a look at how <code class="inline">Round</code> builds nicely on top of <code class="inline">Deck</code> and <code class="inline">Hand</code> abstractions. The following function from the <code class="inline">Round</code> module takes a card from the deck, and gives it to the current hand:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">deal</span><span class="p" data-group-id="8418967347-1">(</span><span class="n">round</span><span class="p" data-group-id="8418967347-1">)</span><span class="w"> </span><span class="k" data-group-id="8418967347-2">do</span><span class="w">
  </span><span class="p" data-group-id="8418967347-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">card</span><span class="p">,</span><span class="w"> </span><span class="n">deck</span><span class="p" data-group-id="8418967347-3">}</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="k">with</span><span class="w"> </span><span class="p" data-group-id="8418967347-4">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:empty</span><span class="p" data-group-id="8418967347-4">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">take</span><span class="p" data-group-id="8418967347-5">(</span><span class="n">round</span><span class="o">.</span><span class="n">deck</span><span class="p" data-group-id="8418967347-5">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w">
      </span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">take</span><span class="p" data-group-id="8418967347-6">(</span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">shuffled</span><span class="p" data-group-id="8418967347-7">(</span><span class="p" data-group-id="8418967347-7">)</span><span class="p" data-group-id="8418967347-6">)</span><span class="w">

  </span><span class="p" data-group-id="8418967347-8">{</span><span class="n">hand_status</span><span class="p">,</span><span class="w"> </span><span class="n">hand</span><span class="p" data-group-id="8418967347-8">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Hand</span><span class="o">.</span><span class="n">deal</span><span class="p" data-group-id="8418967347-9">(</span><span class="n">round</span><span class="o">.</span><span class="n">current_hand</span><span class="p">,</span><span class="w"> </span><span class="n">card</span><span class="p" data-group-id="8418967347-9">)</span><span class="w">

  </span><span class="n">round</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="p" data-group-id="8418967347-10">%</span><span class="nc" data-group-id="8418967347-10">Round</span><span class="p" data-group-id="8418967347-10">{</span><span class="n">round</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="ss">deck</span><span class="p">:</span><span class="w"> </span><span class="n">deck</span><span class="p">,</span><span class="w"> </span><span class="ss">current_hand</span><span class="p">:</span><span class="w"> </span><span class="n">hand</span><span class="p" data-group-id="8418967347-10">}</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">notify_player</span><span class="p" data-group-id="8418967347-11">(</span><span class="n">round</span><span class="o">.</span><span class="n">current_player_id</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8418967347-12">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="n">card</span><span class="p" data-group-id="8418967347-12">}</span><span class="p" data-group-id="8418967347-11">)</span><span class="w">

  </span><span class="p" data-group-id="8418967347-13">{</span><span class="n">hand_status</span><span class="p">,</span><span class="w"> </span><span class="n">round</span><span class="p" data-group-id="8418967347-13">}</span><span class="w">
</span><span class="k" data-group-id="8418967347-2">end</span></code></pre>
<p>
We take a card from the deck, optionally using the new deck if the current one is exhausted. Then we pass the card to the current hand, update the round with the new hand and deck status, add a notification instruction about the given card, and return the hand status (<code class="inline">:ok</code> or <code class="inline">:busted</code>) and the updated round. No extra process is involved in the process :-)</p>
<p>
The <code class="inline">notify_player</code> invocation is a simple one-liner which pushes a lot of complexity away from this module. Without it, we’d need to send a message to some other process (say another GenServer, or a Phoenix channel). We’d have to find that process somehow, and consider cases when this process isn’t running. A lot of extra complexity would have to be bundled together with the code which models the flow of the round.</p>
<p>
But thanks to the instructions mechanism, none of this happens, and the <code class="inline">Round</code> module stays focused on the rules of the game. The <code class="inline">notify_player</code> function will <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/round.ex#L132">store the instruction entry</a>. Then later, before returning, a <code class="inline">Round</code> function will <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/round.ex#L144-L145">pull all pending instructions, and return them separately</a>, forcing the client to interpret those instructions.</p>
<p>
As an added benefit, the code can now be driven by different kinds of drivers (clients). In the examples above, I drove it manually from the session. Another example is <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/test/round_test.exs#L22-L30">driving the code from tests</a>. This abstraction can now be easily tested, without needing to produce or observe side-effects.</p>
<h2>
Process organization</h2>
<p>
With the basic pure model complete, it’s time to turn our attention to the process side of things. As I discussed earlier, I’ll host each round in a separate process. I believe this makes sense, since different rounds have nothing in common. Therefore, running them separately gives us better efficiency, scalability, and error isolation.</p>
<h3>
Round server</h3>
<p>
A single round is managed by the <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/round_server.ex">Blackjack.RoundServer</a> module, which is a <code class="inline">GenServer</code>. An <code class="inline">Agent</code> could also serve the purpose here, but I’m not a fan of agents, so I’ll just stick with <code class="inline">GenServer</code>. Your preferences may differ, of course, and I totally respect that :-)</p>
<p>
In order to start the process, we need to invoke the <code class="inline">start_playing/2</code> function. This name is chosen instead of a more common <code class="inline">start_link</code>, since <code class="inline">start_link</code> by convention links to the caller process. In contrast, <code class="inline">start_playing</code> will start the round somewhere else in the supervision tree, and the process will not be linked to the caller.</p>
<p>
The function takes two arguments: the round id, and the list of players. The round id is an arbitrary unique term which needs to be chosen by the client. The server process will be registered in an internal <code class="inline">Registry</code> using this <code class="inline">id</code>.</p>
<p>
Each entry in the list of players is a map describing a client side of the player:</p>
<pre><code class="highlight makeup elixir"><span class="na">@type</span><span class="w"> </span><span class="n">player</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p" data-group-id="4074458303-1">%{</span><span class="ss">id</span><span class="p">:</span><span class="w"> </span><span class="nc">Round</span><span class="o">.</span><span class="n">player_id</span><span class="p">,</span><span class="w"> </span><span class="ss">callback_mod</span><span class="p">:</span><span class="w"> </span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="ss">callback_arg</span><span class="p">:</span><span class="w"> </span><span class="n">any</span><span class="p" data-group-id="4074458303-1">}</span></code></pre>
<p>
A player is described with its id, a callback module, and a callback arg. The id is going to be passed to the round abstraction. Whenever the abstraction instructs the server to notify some player, the server will invoke <code class="inline">callback_mod.some_function(some_arguments)</code>, where <code class="inline">some_arguments</code> will include round id, player id, <code class="inline">callback_arg</code>, and additional, notification-specific arguments.</p>
<p>
The <code class="inline">callback_mod</code> approach allows us to support different kinds of players such as:</p>
<ul>
  <li>
players connected through HTTP  </li>
  <li>
players connected through a custom TCP protocol  </li>
  <li>
a player in the <code class="inline">iex</code> shell session  </li>
  <li>
automatic (machine) players  </li>
</ul>
<p>
We can easily handle all these players in the same round. The server doesn’t care about any of that, it just invokes callback functions of the callback module, and lets the implementation do the job.</p>
<p>
The functions which must be implement in the callback module are listed <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/notifier.ex#L6-L10">here</a>:</p>
<pre><code class="highlight makeup elixir"><span class="na">@callback</span><span class="w"> </span><span class="n">deal_card</span><span class="p" data-group-id="1780500689-1">(</span><span class="nc">RoundServer</span><span class="o">.</span><span class="n">callback_arg</span><span class="p">,</span><span class="w"> </span><span class="nc">Round</span><span class="o">.</span><span class="n">player_id</span><span class="p">,</span><span class="w">
  </span><span class="nc">Blackjack.Deck</span><span class="o">.</span><span class="n">card</span><span class="p" data-group-id="1780500689-1">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">any</span><span class="w">
</span><span class="na">@callback</span><span class="w"> </span><span class="n">move</span><span class="p" data-group-id="1780500689-2">(</span><span class="nc">RoundServer</span><span class="o">.</span><span class="n">callback_arg</span><span class="p">,</span><span class="w"> </span><span class="nc">Round</span><span class="o">.</span><span class="n">player_id</span><span class="p" data-group-id="1780500689-2">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">any</span><span class="w">
</span><span class="na">@callback</span><span class="w"> </span><span class="n">busted</span><span class="p" data-group-id="1780500689-3">(</span><span class="nc">RoundServer</span><span class="o">.</span><span class="n">callback_arg</span><span class="p">,</span><span class="w"> </span><span class="nc">Round</span><span class="o">.</span><span class="n">player_id</span><span class="p" data-group-id="1780500689-3">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">any</span><span class="w">
</span><span class="na">@callback</span><span class="w"> </span><span class="n">winners</span><span class="p" data-group-id="1780500689-4">(</span><span class="nc">RoundServer</span><span class="o">.</span><span class="n">callback_arg</span><span class="p">,</span><span class="w"> </span><span class="nc">Round</span><span class="o">.</span><span class="n">player_id</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1780500689-5">[</span><span class="nc">Round</span><span class="o">.</span><span class="n">player_id</span><span class="p" data-group-id="1780500689-5">]</span><span class="p" data-group-id="1780500689-4">)</span><span class="w">
  </span><span class="o">::</span><span class="w"> </span><span class="n">any</span><span class="w">
</span><span class="na">@callback</span><span class="w"> </span><span class="n">unauthorized_move</span><span class="p" data-group-id="1780500689-6">(</span><span class="nc">RoundServer</span><span class="o">.</span><span class="n">callback_arg</span><span class="p">,</span><span class="w"> </span><span class="nc">Round</span><span class="o">.</span><span class="n">player_id</span><span class="p" data-group-id="1780500689-6">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">any</span></code></pre>
<p>
These signatures reveal that the implementation can’t manage its state in the server process. This is an intentional decision, which practically forces the players to run outside of the round process. This helps us keeping the round state isolated. If a player crashes or disconnects, the round server still keeps running, and can handle the situation, for example by busting a player if they fail to move within a given time.</p>
<p>
Another nice consequence of this design is that testing of the server is fairly straightforward. The test implements the notifier behaviour by <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/test/integration_test.exs#L40-L53">sending itself messages from every callback</a>. Testing then boils down to <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/test/integration_test.exs#L6-L27">asserting/refuting particular messages, and invoking <code class="inline">RoundServer.move/3</code> to make the move on behalf of the player</a>.</p>
<h3>
Sending notifications</h3>
<p>
When functions from the <code class="inline">Round</code> module return the instruction list to the server process, it will <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/round_server.ex#L69-L70">walk through them, and interpret them</a>.</p>
<p>
The notifications themselves are sent from separate processes. This is an example where we can profit from extra concurrency. Sending notifications is a task which is separate from the task of managing the state of the round. The notifications logic might be burdened by issues such as slow or disconnected clients, so it’s worth doing this outside of the round process. Moreover, notifications to different players have nothing in common, so they can be sent from separate processes. However, we need to preserve the order of notifications for each player, so we need a dedicated notification process per each player.</p>
<p>
This is implemented in the <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/notifier.ex">Blackjack.PlayerNotifier</a> module, a <code class="inline">GenServer</code> based process whose role is to send notification to a single player. When we start the round server with the <code class="inline">start_playing/2</code> function, a <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/round_server.ex#L34-L40">small supervision subtree</a> is started which hosts the round server together with <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/notifier.ex#L19">one notifier server per each player in the round</a>.</p>
<p>
When the round server plays a move, it will get a list of instructions from the round abstraction. The server will then forward each instruction to the corresponding notifier server which will <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack/notifier.ex#L44-L46">interpret the instruction and invoke a corresponding M/F/A</a> to notify the player.</p>
<p>
Hence, if we need to notify multiple players, we’ll do it separately (and possibly in parallel). As a consequence, the total ordering of messages is not preserved. Consider the following sequence of instructions:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="1162759371-1">[</span><span class="w">
  </span><span class="p" data-group-id="1162759371-2">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1162759371-3">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1162759371-4">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:spades</span><span class="p" data-group-id="1162759371-4">}</span><span class="p" data-group-id="1162759371-3">}</span><span class="p" data-group-id="1162759371-2">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="1162759371-5">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_1</span><span class="p">,</span><span class="w"> </span><span class="ss">:busted</span><span class="p" data-group-id="1162759371-5">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="1162759371-6">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1162759371-7">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1162759371-8">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="ss">:ace</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:spades</span><span class="p" data-group-id="1162759371-8">}</span><span class="p" data-group-id="1162759371-7">}</span><span class="p" data-group-id="1162759371-6">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="1162759371-9">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1162759371-10">{</span><span class="ss">:deal_card</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1162759371-11">%{</span><span class="ss">rank</span><span class="p">:</span><span class="w"> </span><span class="ss">:jack</span><span class="p">,</span><span class="w"> </span><span class="ss">suit</span><span class="p">:</span><span class="w"> </span><span class="ss">:spades</span><span class="p" data-group-id="1162759371-11">}</span><span class="p" data-group-id="1162759371-10">}</span><span class="p" data-group-id="1162759371-9">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="1162759371-12">{</span><span class="ss">:notify_player</span><span class="p">,</span><span class="w"> </span><span class="ss">:player_2</span><span class="p">,</span><span class="w"> </span><span class="ss">:move</span><span class="p" data-group-id="1162759371-12">}</span><span class="w">
</span><span class="p" data-group-id="1162759371-1">]</span></code></pre>
<p>
It might happen that <code class="inline">player_2</code> messages arrives before <code class="inline">player_1</code> is informed that it’s busted. But that’s fine, since those are two different players. The ordering of messages per each player is of course preserved, courtesy of player-specific notifier server process.</p>
<p>
Before parting, I want to drive my point again: owing to the design and functional nature of the <code class="inline">Round</code> module, all this notifications complexity is kept outside of the domain model. Likewise, notification part is not concerned with the domain logic.</p>
<h3>
The blackjack service</h3>
<p>
The picture is completed in the form of the <code class="inline">:blackjack</code> OTP application (the <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/blackjack.ex">Blackjack</a> module). When you start the application, a couple of locally registered processes are started: an internal <code class="inline">Registry</code> instance (used to register round and notifier servers), and a <code class="inline">:simple_one_for_one</code> supervisor which will host process subtree for each round.</p>
<p>
This application is now basically a blackjack service that can manage multiple rounds. The service is generic and not depending on a particular interface. You can use it with Phoenix, Cowboy, Ranch (for plain TCP), elli, or whatever else suits your purposes. You implement a callback module, start client processes, and start the round server.</p>
<p>
You can see an example in the <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/demo.ex">Demo</a> module, which implements a <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/demo.ex#L88-L107">simple auto player</a>, a <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/demo.ex#L18">GenServer powered notifier callback</a>, and a <a href="https://github.com/sasa1977/erlangelist/blob/dc7cd1d2c77e52fa0a3a90f269c0f4ca8cca908b/examples/blackjack/lib/demo.ex#L2-L15">starting logic which starts the round with five players</a>:</p>
<pre><code class="text">$ iex -S mix
iex(1)&gt; Demo.run

player_1: 4 of spades
player_1: 3 of hearts
player_1: thinking ...
player_1: hit
player_1: 8 of spades
player_1: thinking ...
player_1: stand

player_2: 10 of diamonds
player_2: 3 of spades
player_2: thinking ...
player_2: hit
player_2: 3 of diamonds
player_2: thinking ...
player_2: hit
player_2: king of spades
player_2: busted

...</code></pre>
<p>
Here’s how a supervision tree looks like when we have five simultaneous rounds, each with five players:</p>
<p>
  <img src="/images/blackjack_observer.png" alt="Supervision tree" />
</p>
<h2>
Conclusion</h2>
<p>
So, can we manage a complex state in a single process? We certainly can! Simple functional abstractions such as <code class="inline">Deck</code> and <code class="inline">Hand</code> allowed me to separate concerns of a more complex round state without needing to resort to agents.</p>
<p>
That doesn’t mean we need to be conservative with processes though. Use processes wherever they make sense and bring some clear benefits. Running different rounds in separate processes improves scalability, fault-tolerance, and the overall performance of the system. The same thing applies for notification processes. These are different runtime concerns, so there’s no need to run them in the same runtime context.</p>
<p>
If temporal and/or domain logic are complex, consider separating them. The approach I took allowed me to implement a more involved runtime behaviour (concurrent notifications) without complicating the business flow of the round. This separation also puts me in a nice spot, since I can now evolve both aspects separately. Adding the support for dealer, split, insurance, and other business concepts should not affect the runtime aspect significantly. Likewise, supporting netsplits, reconnects, player crashes, or timeouts should not require the changes in the domain logic.</p>
<p>
Finally, it’s worth keeping the end goal in mind. While I didn’t go there (yet), I always planned for this code to be hosted in some kind of a web server. So some decisions are taken to support this scenario. In particular, the implementation of <code class="inline">RoundServer</code>, which takes a callback module for each player, allows me to hook up with different kinds of clients powered by various technologies. This keeps the blackjack service agnostic of particular libraries and frameworks (save for standard libraries and OTP of course), and completely flexible.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2017, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/spawn_or_not">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/spawn_or_not.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Tue, 4 Apr 2017 00:00:00 +0000</pubDate></item><item><title>Reducing the maximum latency of a bound buffer</title><link>http://theerlangelist.com//article/reducing_maximum_latency</link><description><![CDATA[<h1>Reducing the maximum latency of a bound buffer</h1>
<h4 class="right">2016-12-19</h4>

<div class="article-body">
<p>
Recently I came across two great articles on the Pusher blog: <a href="https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/">Low latency, large working set, and GHC’s garbage collector: pick two of three</a> and <a href="https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/">Golang’s Real-time GC in Theory and Practice</a>. The articles tell the story of how Pusher engineers reimplemented their message bus. The first take was done in Haskell. During performance tests they noticed some high latencies in the 99 percentile range. After they bared down the code they were able to prove that these spikes are caused by the GHC stop-the-world garbage collector coupled with a large working set (the number of in-memory objects). The team then experimented with Go and got much better results, owing to Go’s concurrent garbage collector.</p>
<p>
I highly recommend both articles. The Pusher test is a great benching example, as it is focused on solving a real challenge, and evaluating a technology based on whether it’s suitable for the job. This is the kind of evaluation I prefer. Instead of comparing technologies through some shallow synthetic benchmarks, such as passing a token through the ring, or benching a web server which returns “200 OK”, I find it much more useful to make a simple implementation of the critical functionality, and then see how it behaves under the desired load. This should provide the answer to the question “Can I solve X efficiently using Y?”. This is the approach I took when I first evaluated Erlang. A 12 hours test of the simulation of the real system with 10 times of the expected load convinced me that the technology is more than capable for what I needed.</p>
<h2>
Challenge accepted</h2>
<p>
Reading the Pusher articles made me wonder how well would the Elixir implementation perform. After all, the underlying Erlang VM (BEAM) has been built with low and predictable latency in mind, so coupled with other properties such as fault-tolerance, massive concurrency, scalability, support for distributed systems, it seems like a compelling choice for the job.</p>
<p>
So let me define the challenge, based on the original articles. I’ll implement a FIFO buffer that can handle two operations: <em>push</em>, and <em>pull</em>. The buffer is bound by some maximum size. If the buffer is full, a push operation will overwrite the oldest item in the queue.</p>
<p>
The goal is to reduce the maximum latency of push and pull operations of a very large buffer (max 200k items). It’s important to keep this final goal in mind. I care about smoothing out latency spikes of buffer operations. I care less about which language gives me better worst-case GC pauses. While the root issue of the Pusher challenge is caused by long GC pauses, that doesn’t mean that I can solve it only by moving to another language. As I’ll demonstrate, relying on a few tricks in Elixir/Erlang, we can bypass GC completely and bring max latency into the microseconds area.</p>
<h2>
Measuring</h2>
<p>
To measure the performance, I decided to run the buffer in a separate <code class="inline">GenServer</code> powered process. You can see the implementation <a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/server.ex">here</a>.</p>
<p>
The measurements are taken using Erlang’s tracing capabilities. A separate process is started, which sets up the trace of the buffer process. It receives start/finish times of push and pull operations as well as buffer’s garbage collections. It collects those times, and when asked, produces the final stats. You can find the implementation <a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer_tracer.ex">here</a>.</p>
<p>
Tracing will cause some slowdowns. The whole bench seems to take about 2x longer when the tracing is used. I can’t say how much does it affect the reported times, but I don’t care that much. If I’m able to get good results with tracing turned on, then the implementation should suffice when the tracing is turned off :-)</p>
<p>
For those of you not familiar with Erlang, the word process here refers to an Erlang process - a lightweight concurrent program that runs in the same OS process and shares nothing with other Erlang processes. At the OS level, we still have just one OS process, but inside it multiple Erlang processes are running separately.</p>
<p>
These processes have nothing in common, share no memory and can only communicate by sending themselves messages. In particular, each process has its own separate heap, and is garbage collected separately to other processes. Therefore, whatever data is allocated by the tracer process code will not put any GC pressure on the buffer. Only the data we’re actually pushing to the buffer will be considered during buffer’s GC, and can thus affect the latency of buffer operations. This approach demonstrates a great benefit of Erlang. By running different things in separate processes, we can prevent GC pressure in one process to affect others in the system. I’m not aware of any other lightweight concurrency platform which provides such guarantees.</p>
<p>
The test first starts with a brief “stretch” warmup. I create the buffer with the maximum capacity of 200k items (the number used in the Pusher benches). Then, I push 200k items, then pull all of them, and then again push 200k items. At the end of the warmup, the buffer is at its maximum capacity.</p>
<p>
Then the bench starts. I’m issuing 2,000,000 requests in cycles of 15 pushes followed by 5 pulls. The buffer therefore mostly operates in the “overflow” mode. In total, 1,000,000 pushes are performed on the full buffer, with further 500,000 pushes on a nearly full buffer. The items being pushed are 1024 bytes Erlang binares, and each item is different from others, meaning the test will create 1,500,000 different items.</p>
<p>
The bench code resides <a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/mix/tasks/buffer_prof.ex">here</a>. The full project is available <a href="https://github.com/sasa1977/erlangelist/tree/master/examples/buffer">here</a>. I’ve benched it using Erlang 19.1 and Elixir 1.3.4, which I installed with the <a href="https://github.com/asdf-vm/asdf">asdf</a> version manager. The tests are performed on my 2011 iMac (3,4 GHz Intel Core i7).</p>
<h2>
Functional implementation</h2>
<p>
First, I’ll try with what I consider an idiomatic approach in Elixir and Erlang - a purely functional implementation, based on the <a href="http://erlang.org/doc/man/queue.html">:queue</a> module. According to docs, this module implements a double-ended FIFO queue in an efficient manner with most operations having an amortized O(1) running time. The API of the module provides most of the things needed. I can use <code class="inline">:queue.in/2</code> and <code class="inline">:queue.out/2</code> to push/pull items. There is no direct support for setting the maximum size, but it’s fairly simple to implement this on top of the <code class="inline">:queue</code> module. You can find my implementation <a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/queue.ex">here</a>.</p>
<p>
When I originally read the Pusher articles, I was pretty certain that such implementation will lead to some larger latency spikes. While there’s no stop-the-world GC in Erlang, there is still stop-the-process GC. An Erlang process starts with a fairly small heap (~ 2 Kb), and if it needs to allocate more than that, then the process is GC-ed and its heap is possibly expanded. For more details on GC, I recommend <a href="https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html">this article</a> and <a href="https://hamidreza-s.github.io/erlang garbage collection memory layout soft realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html">this one</a>.</p>
<p>
In our test, this means that the buffer process will pretty soon expand to some large heap which needs to accommodate 200k items. Then, as we’re pushing more items and create the garbage, the GC will have a lot of work to do. Consequently, we can expect some significant GC pauses which will lead to latency spikes. Let’s verify this:</p>
<pre><code class="text">$ mix buffer.bench -m Buffer.Queue

push/pull (2000000 times, average: 6.9 μs)
  99%: 17 μs
  99.9%: 32 μs
  99.99%: 74 μs
  99.999%: 21695 μs
  100%: 37381 μs
  Longest 10 (μs): 27134 27154 27407 27440 27566 27928 28138 28899 33616 37381

gc (274 times, average: 8514.46 μs)
  99%: 22780 μs
  99.9%: 23612 μs
  99.99%: 23612 μs
  99.999%: 23612 μs
  100%: 23612 μs
  Longest 10 (μs): 21220 21384 21392 21516 21598 21634 21949 22233 22780 23612

Buffer process memory: 35396 KB
Total memory used: 330 MB</code></pre>
<p>
There’s a lot of data here, so I’ll highlight a few numbers I find most interesting.</p>
<p>
I’ll start with the average latency of buffer operations. Averages get some bad reputation these days, but I still find them a useful metric. The observed average latency of 6.9 microseconds tells me that this implementation can cope with roughly 145,000 operations/sec without lagging, even if the buffer is completely full. If I can tolerate some latency variations, and don’t expect requests at a higher rate, then the <code class="inline">:queue</code> implementation should suit my needs.</p>
<p>
Looking at the latency distributions, we can see that the max latency is ~ 37 milliseconds. That might be unacceptable, or it may be just fine, depending on the particular use case. It would be wrong to broadly extrapolate that this <code class="inline">:queue</code> powered buffer always sucks, or to proclaim that it works well for all cases. We can only interpret these numbers if we know the specifications and requirements of the particular problem at hand.</p>
<p>
If you look closer at latency distributions of push/pull operations, you’ll see that the latency grows rapidly between four and five nines, where it transitions from two digits microseconds into a two digits milliseconds area. With 2M operations, that means we experience latency spikes for less than 200 of them. Again, whether that’s acceptable or not depends on constraints of the particular problem.</p>
<p>
The printed GC stats are related only to the buffer process. We can see that 274 GCs took place in that buffer process, with high percentile latencies being in the two-digit milliseconds range. Unsurprisingly, there seems to be a strong correlation between GC times and latency spikes which start in the 4-5 nines percentile range.</p>
<p>
Finally, notice how the buffer process heap size is 35 MB. You might expect it to be more around 200 MB, since the buffer holds 200k items, each being 1024 bytes. However, in this bench, the items are so called <a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#id67990">refc binaries</a>, which means they are stored on the separate heap. The buffer process heap holds only references to these binaries, not the data itself.</p>
<p>
Of course, the buffer process still has 200k live references on its heap, together with any garbage from the removed messages, and this is what causes latency spikes. So if I was just looking at worst-case GC times comparing them to other languages, Erlang wouldn’t fare well, and I might wrongly conclude that it’s not suitable for the job.</p>
<h2>
ETS based implementation</h2>
<p>
However, I can work around the GC limitation with ETS tables. ETS tables come in a couple of shapes, but for this article I’ll keep it simple by saying they can serve as an in-process in-memory key-value store. When it comes to semantics, ETS tables don’t bring anything new to the table (no pun intended). You could implement the same functionality using plain Erlang processes and data structure.</p>
<p>
However, ETS tables have a couple of interesting properties which can make them perform very well in some cases. First, ETS table data is stored in a separate memory space outside of the process heap. Hence, if we use ETS table to store items, the buffer process doesn’t need to hold a lot of live references anymore, which should reduce its GC times. Moreover, the data in ETS tables is released immediately on removal. This means that we can completely remove GCs of a large set.</p>
<p>
My implementation of an ETS based buffer is based on the Pusher’s Go implementation. Basically, I’m using ETS table to simulate a mutable array, by storing k-v pairs of <code class="inline">(index, value)</code> into the table. I’m maintaining two indices, one determines where I’m going to push the next item, another does the same for the pull operation. Originally they both start with the value of zero. Then, each push stores a <code class="inline">(push_index, value)</code> pair to the table, and increases the push index by one. If the push index reaches the maximum buffer size, it’s set to zero. Likewise, when pulling the data, I read the value associated with the <code class="inline">pull_index</code> key, and then increment the pull index. If the buffer is full, a push operation will overwrite the oldest value and increment both indices, thus making sure that the next pull operation will read from the proper location. The full implementation is available <a href="https://github.com/sasa1977/erlangelist/blob/master/examples/buffer/lib/buffer/ets.ex">here</a>.</p>
<p>
Let’s see how it performs:</p>
<pre><code class="text">$ mix buffer.bench -m Buffer.Ets

push/pull (2000000 times, average: 6.53 μs)
  99%: 27 μs
  99.9%: 37 μs
  99.99%: 50 μs
  99.999%: 66 μs
  100%: 308 μs
  Longest 10 (μs): 76 80 83 86 86 96 106 186 233 308

gc (97062 times, average: 5.16 μs)
  99%: 10 μs
  99.9%: 20 μs
  99.99%: 30 μs
  99.999%: 44 μs
  100%: 44 μs
  Longest 10 (μs): 30 30 34 34 34 39 43 44 44 44

Buffer process memory: 30 KB
Total memory used: 312 MB</code></pre>
<p>
The average time of 6.53 microseconds is not radically better than the <code class="inline">:queue</code> powered implementation. However, the latency spikes are now much smaller. The longest observed latency is 308 microseconds, while in the five nines range, we’re already in the two-digits microseconds area. In fact, out of 2,000,000 pushes, only 4 of them took longer than 100 microseconds. Not too shabby :-)</p>
<p>
Full disclosure: these results are the best ones I got after a couple of runs. On my machine, the max latency sometimes goes slightly above 1ms, while other numbers don’t change significantly. In particular, 99.999% is always below 100 μs.</p>
<p>
Looking at GC stats, you can see a large increase in the number of GCs of the buffer process. In the <code class="inline">:queue</code> implementation, the buffer process triggered 274 GCs, while in this implementation we observe about 97,000 GCs. What’s the reason for this? Keep in mind that the buffer process still manages some data in its own heap. This includes indices for next push/pull operation, as well as temporary references to items which have just been pushed/pulled. Since a lot of requests arrive to the buffer process, it’s going to generate a lot of garbage. However, given that buffer items are stored in a separate heap of the ETS table, the buffer will never maintain a large live set. This corresponds to Pusher’s conclusions. The GC spike problem is not related to the amount of generated garbage, but rather to the amount of live working set. In this implementation we reduced that set, keeping the buffer process heap pretty small. Consequently, although we’ll trigger a lot of GCs, these will be pretty short. The longest observed GC of the buffer process took only 44 microseconds.</p>
<h2>
Final thoughts</h2>
<p>
Given Erlang’s stop-the-process GC properties, we might sometimes experience large pauses in some processes. However, there are some options at our disposal which can help us trim down large spikes. The main trick to control these pauses is to keep the process heap small. A large active heap coupled with frequent incoming requests is going to put more pressure on the GC, and latency is going to increase.</p>
<p>
In this particular example, using ETS helped me reduce the heap size of the buffer process. Although the number of GCs has increased dramatically, the GC pauses were pretty short keeping the overall latency stable. While Erlang is certainly not the fastest platform around, it allows me to keep my latency predictable. I build the system, fine-tune it to reach desired performance, and I can expect less surprises in production.</p>
<p>
It’s worth mentioning two other techniques that might help you reduce your GC spikes. One approach is to split the process that manages a big heap into multiple processes with smaller working sets. This will lead to fragmented GCs, and possibly remove spikes.</p>
<p>
In some cases you can capitalize on the fact that the process memory is immediately released when the process terminates. If you need to perform a one-off job which allocates a lot of temporary memory, you can consider using <a href="https://hexdocs.pm/elixir/Process.html#spawn/2">Process.spawn</a> which allows you to explicitly preallocate a larger heap when starting the process. That might completely prevent GC from happening in that process. You do your calculation, spit out the result, and finally terminate the process so all of its memory gets immediately reclaimed without ever being GC-ed.</p>
<p>
Finally, if you can’t make some critical part of your system efficient in Erlang, you can always resort to <a href="http://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/">in-process C with NIFs</a> or <a href="http://theerlangelist.com/article/outside_elixir">out-process anything with ports</a>, keeping Elixir/Erlang as your main platform and the “controller plane” of the system. Many options are on the table, which gives me a lot of confidence that I’ll be able to handle any challenge I encounter, no matter how tricky it might be.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2016, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/reducing_maximum_latency">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/reducing_maximum_latency.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 19 Dec 2016 00:00:00 +0000</pubDate></item><item><title>Observing low latency in Phoenix with wrk</title><link>http://theerlangelist.com//article/phoenix_latency</link><description><![CDATA[<h1>Observing low latency in Phoenix with wrk</h1>
<h4 class="right">2016-06-12</h4>

<div class="article-body">
<p>
Recently there were a couple of questions on <a href="http://elixirforum.com">Elixir Forum</a> about observed performance of a simple Phoenix based server (see <a href="http://elixirforum.com/t/evaluating-elixir-phoenix-for-a-web-scale-performance-critical-application/832">here</a> for example). People reported some unspectacular numbers, such as a throughput of only a few thousand requests per second and a latency in the area of a few tens of milliseconds.</p>
<p>
While such results are decent, a simple server should be able to give us better numbers. In this post I’ll try to demonstrate how you can easily get some more promising results. I should immediately note that this is going to be a shallow experiment. I won’t go into deeper analysis, and I won’t deal with tuning of VM or OS parameters. Instead, I’ll just pick a few low-hanging fruits, and rig the load test by providing the input which gives me good numbers. The point of this post is to demonstrate that it’s fairly easy to get (near) sub-ms latencies with a decent throughput. Benching a more real-life like scenario is more useful, but also requires a larger effort.</p>
<h2>
Building the server</h2>
<p>
I’m going to load test a simple JSON API:</p>
<pre><code class="bash">$ curl -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -d &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39; \
    localhost:4000/api/sum

{&quot;result&quot;:3}</code></pre>
<p>
It’s not spectacular but it will serve the purpose. The server code will read and decode the body, then perform the computation, and produce an encoded JSON response. This makes the operation mostly CPU bound, so under load I expect to see CPU usage near 100%.</p>
<p>
So let’s build the server. First, I’ll create a basic mix skeleton:</p>
<pre><code class="highlight makeup elixir"><span class="err">$</span><span class="w"> </span><span class="n">mix</span><span class="w"> </span><span class="n">phoenix</span><span class="o">.</span><span class="n">new</span><span class="w"> </span><span class="n">bench_phoenix</span><span class="w"> </span><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">ecto</span><span class="w"> </span><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">brunch</span><span class="w"> </span><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">html</span></code></pre>
<p>
I don’t need ecto, brunch, or html support, since I’ll be exposing only a simple API interface.</p>
<p>
Next, I need to implement the controller:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">BenchPhoenix.ApiController</span><span class="w"> </span><span class="k" data-group-id="6235691334-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">BenchPhoenix.Web</span><span class="p">,</span><span class="w"> </span><span class="ss">:controller</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">sum</span><span class="p" data-group-id="6235691334-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6235691334-3">%{</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="6235691334-3">}</span><span class="p" data-group-id="6235691334-2">)</span><span class="w"> </span><span class="k" data-group-id="6235691334-4">do</span><span class="w">
    </span><span class="n">json</span><span class="p" data-group-id="6235691334-5">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6235691334-6">%{</span><span class="ss">result</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="6235691334-6">}</span><span class="p" data-group-id="6235691334-5">)</span><span class="w">
  </span><span class="k" data-group-id="6235691334-4">end</span><span class="w">
</span><span class="k" data-group-id="6235691334-1">end</span></code></pre>
<p>
And add a route:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">BenchPhoenix.Router</span><span class="w"> </span><span class="k" data-group-id="4406964086-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">BenchPhoenix.Web</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:api</span><span class="w"> </span><span class="k" data-group-id="4406964086-2">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4406964086-3">[</span><span class="s">&quot;json&quot;</span><span class="p" data-group-id="4406964086-3">]</span><span class="w">
  </span><span class="k" data-group-id="4406964086-2">end</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/api&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">BenchPhoenix</span><span class="w"> </span><span class="k" data-group-id="4406964086-4">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:api</span><span class="w">

    </span><span class="n">post</span><span class="w"> </span><span class="s">&quot;/sum&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ApiController</span><span class="p">,</span><span class="w"> </span><span class="ss">:sum</span><span class="w">
  </span><span class="k" data-group-id="4406964086-4">end</span><span class="w">
</span><span class="k" data-group-id="4406964086-1">end</span></code></pre>
<p>
Now I need to change some settings to make the server perform better. In <code class="inline">prod.exs</code>, I’ll increase the logger level to <code class="inline">:warn</code>:</p>
<pre><code class="highlight makeup elixir"><span class="n">config</span><span class="w"> </span><span class="ss">:logger</span><span class="p">,</span><span class="w"> </span><span class="ss">level</span><span class="p">:</span><span class="w"> </span><span class="ss">:warn</span></code></pre>
<p>
By default, the logger level is set to <code class="inline">:info</code> meaning that each request will be logged. This leads to a lot of logging under load, which will cause the <code class="inline">Logger</code> to start applying back pressure. Consequently, logging will become a bottleneck, and you can get crappy results. Therefore, when measuring, make sure to avoid logging all requests, either by increasing the logger level in prod, or by changing the log level of the request to <code class="inline">:debug</code> in your endpoint (with <code class="inline">plug Plug.Logger, log: :debug</code>).</p>
<p>
Another thing I’ll change is the value of the <code class="inline">max_keepalive</code> Cowboy option. This number specifies the maximum number of requests that can be served on a single connection. The default value is 100, meaning that the test would have to open new connections frequently. Increasing this value to something large will allow the test to establish the connections only once and reuse them throughout the entire test. Here’s the relevant setting in <code class="inline">prod.exs</code>:</p>
<pre><code class="highlight makeup elixir"><span class="n">config</span><span class="w"> </span><span class="ss">:bench_phoenix</span><span class="p">,</span><span class="w"> </span><span class="nc">BenchPhoenix.Endpoint</span><span class="p">,</span><span class="w">
  </span><span class="ss">http</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7116205648-1">[</span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="mi">4000</span><span class="p">,</span><span class="w">
    </span><span class="ss">protocol_options</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7116205648-2">[</span><span class="ss">max_keepalive</span><span class="p">:</span><span class="w"> </span><span class="mi">5_000_000</span><span class="p" data-group-id="7116205648-2">]</span><span class="w">
  </span><span class="p" data-group-id="7116205648-1">]</span><span class="p">,</span><span class="w">
  </span><span class="ss">url</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7116205648-3">[</span><span class="ss">host</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;example.com&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="mi">80</span><span class="p" data-group-id="7116205648-3">]</span><span class="p">,</span><span class="w">
  </span><span class="ss">cache_static_manifest</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;priv/static/manifest.json&quot;</span></code></pre>
<p>
Notice that I have also hardcoded the <code class="inline">port</code> setting to <code class="inline">4000</code> so I don’t need to specify it through the environment.</p>
<p>
I also need to tell Phoenix to start the server when the system starts:</p>
<pre><code class="highlight makeup elixir"><span class="n">config</span><span class="w"> </span><span class="ss">:bench_phoenix</span><span class="p">,</span><span class="w"> </span><span class="nc">BenchPhoenix.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="ss">server</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre>
<p>
I plan to run the system as the OTP release. This is a recommended way of running Erlang in production, and it should give me better performance than <code class="inline">iex -S mix</code>. To make this work, I need to add <code class="inline">exrm</code> as a dependency:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">deps</span><span class="w"> </span><span class="k" data-group-id="2632779776-1">do</span><span class="w">
  </span><span class="p" data-group-id="2632779776-2">[</span><span class="n">...</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2632779776-3">{</span><span class="ss">:exrm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;~&gt; 1.0&quot;</span><span class="p" data-group-id="2632779776-3">}</span><span class="p" data-group-id="2632779776-2">]</span><span class="w">
</span><span class="k" data-group-id="2632779776-1">end</span></code></pre>
<p>
Finally, I need to setup the load-test script. I’ll be using the <a href="https://github.com/wg/wrk">wrk tool</a>, so I’ll create the <code class="inline">wrk.lua</code> script:</p>
<pre><code class="lua">request = function()
  a = math.random(100)
  b = math.random(100)
  wrk.method = &quot;POST&quot;
  wrk.headers[&quot;Content-Type&quot;] = &quot;application/json&quot;
  wrk.body = &#39;{&quot;a&quot;:&#39; .. a .. &#39;,&quot;b&quot;:&#39; .. b .. &#39;}&#39;
  return wrk.format(nil, &quot;/api/sum&quot;)
end</code></pre>
<p>
And that’s it! The server is now ready to be load tested. You can find the complete code <a href="https://github.com/sasa1977/erlangelist/tree/master/examples/bench_phoenix">here</a>.</p>
<h2>
Running the test</h2>
<p>
I’ll be running tests on my 2011 iMac:</p>
<pre><code class="text">Model Name: iMac
Model Identifier: iMac12,2
Processor Name: Intel Core i7
Processor Speed:  3,4 GHz
Number of Processors: 1
Total Number of Cores:  4
Memory: 8 GB</code></pre>
<p>
Let’s start the OTP release:</p>
<pre><code class="bash">$ MIX_ENV=prod mix do deps.get, compile, release &amp;&amp; \
    rel/bench_phoenix/bin/bench_phoenix foreground</code></pre>
<p>
First, I’ll quickly verify that the server works:</p>
<pre><code class="bash">$ curl -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -d &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39; \
    localhost:4000/api/sum

{&quot;result&quot;:3}</code></pre>
<p>
And now I’m ready to start the test:</p>
<pre><code class="bash">$ wrk -t12 -c12 -d60s --latency -s wrk.lua &quot;http://localhost:4000&quot;</code></pre>
<p>
The parameters here are rigged to make the results attractive. I’m using as few connections as needed (the number was chosen after a couple of trial runs) to get close to the server’s max capacity. Adding more connections would cause the test to issue more work than the server can cope with, so consequently the latency would suffer. If you’re running the test on your own machine, you might need to tweak these numbers a bit to get the best results.</p>
<p>
Let’s see the output:</p>
<pre><code class="text">Running 1m test @ http://localhost:4000
  12 threads and 12 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   477.31us  123.80us   3.05ms   75.66%
    Req/Sec     2.10k   198.83     2.78k    62.43%
  Latency Distribution
     50%  450.00us
     75%  524.00us
     90%  648.00us
     99%    0.87ms
  1435848 requests in 1.00m, 345.77MB read
Requests/sec:  23931.42
Transfer/sec:      5.76MB</code></pre>
<p>
I’ve observed a throughput of ~ 24k requests/sec, with 99th percentile latency below 1ms, and the maximum observed latency at 3.05ms. I also started <code class="inline">htop</code> and confirmed that all cores were near 100% usage, meaning the system was operating near its capacity.</p>
<p>
For good measure, I also ran a 5 minute test, to verify that the results are consistent:</p>
<pre><code class="text">Running 5m test @ http://localhost:4000
  12 threads and 12 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   484.19us  132.26us  12.98ms   76.35%
    Req/Sec     2.08k   204.89     2.80k    70.10%
  Latency Distribution
     50%  454.00us
     75%  540.00us
     90%  659.00us
     99%    0.89ms
  7090793 requests in 5.00m, 1.67GB read
Requests/sec:  23636.11
Transfer/sec:      5.69MB</code></pre>
<p>
The results seems similar to a 1 minute run, with a bit worrying difference in the maximum latency, which is now 13ms.</p>
<p>
It’s also worth verifying how the latency is affected when the system is overloaded. Let’s use a bit more connections:</p>
<pre><code class="text">$ wrk -t100 -c100 -d1m --latency -s wrk.lua &quot;http://localhost:4000&quot;

Running 1m test @ http://localhost:4000
  100 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    13.40ms   24.24ms 118.92ms   90.16%
    Req/Sec   256.22    196.73     2.08k    74.35%
  Latency Distribution
     50%    4.50ms
     75%    9.35ms
     90%   36.13ms
     99%  100.02ms
  1462818 requests in 1.00m, 352.26MB read
Requests/sec:  24386.51
Transfer/sec:      5.87MB</code></pre>
<p>
Looking at <code class="inline">htop</code>, I observed that CPU is fully maxed out, so the system is completely using all the available hardware and operating at its max capacity. Reported latencies are quite larger now, since we’re issuing more work than the system can handle on the given machine.</p>
<p>
Assuming the code is optimized, the solution could be to scale up and put the system on a more powerful machine, which should restore the latency. I don’t have such machine available, so I wasn’t able to prove it.</p>
<p>
It’s also worth considering guarding the system against overloads by making it refuse more work than it can handle. Although that doesn’t seem like a perfect solution, it can allow the system to operate within its limits and thus maintain the latency within bounds. This approach would make sense if you have some fix upper bound on the acceptable latency. Accepting requests which can’t be served within the given time frame doesn’t make much sense, so it’s better to refuse them upfront.</p>
<h2>
Conclusion</h2>
<p>
I’d like to stress again that this was a pretty shallow test. The main purpose was to prove that we can get some nice latency numbers with a fairly small amount of effort. The results look promising, especially since they were obtained on my personal box, where both the load tester and the server were running, as well as other applications (mail client, browser, editor, …).</p>
<p>
However, don’t be tempted to jump to conclusions too quickly. A more exhaustive test would require a dedicated server, tuning of OS parameters, and playing with the <a href="http://erlang.org/doc/man/erl.html#emu_flags">emulator flags</a> such as <code class="inline">+K</code> and <code class="inline">+s</code>. It’s also worth pointing out that synthetic tests can easily be misleading, so be sure to construct an example which resembles the real use case you’re trying to solve.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2016, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/phoenix_latency">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/phoenix_latency.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate></item><item><title>Phoenix is modular</title><link>http://theerlangelist.com//article/phoenix_is_modular</link><description><![CDATA[<h1>Phoenix is modular</h1>
<h4 class="right">2016-02-22</h4>

<div class="article-body">
<p>
A few days ago I saw this question on #elixir-lang channel:</p>
<blockquote>
  <p>
Have any of you had the initial cringe at the number of moving parts Phoenix needs to get you to just “Hello World” ?  </p>
</blockquote>
<p>
Coincidentally, on that same day I received a mail where a developer briefly touched on Phoenix:</p>
<blockquote>
  <p>
I really like Elixir, but can’t seem to find happiness with Phoenix. Too much magic happening there and lots of DSL syntax, diverts from the simplicity of Elixir while not really giving a clear picture of how things work under the hood. For instance, they have endpoints, routers, pipelines, controllers. Can we not simplify endpoints, pipelines and controllers into one thing - say controllers…  </p>
</blockquote>
<p>
I can sympathize with such sentiments. When I first looked at Phoenix, I was myself overwhelmed by the amount of concepts one needs to grasp. But after spending some time with the framework, it started making sense to me, and I began to see the purpose of all these concepts. I quickly became convinced that Phoenix provides reasonable building blocks which should satisfy most typical needs.</p>
<p>
Furthermore, <a href="https://twitter.com/sasajuric/status/664570309929000960">I’ve learned that Phoenix is actually quite modular</a>. This is nice because we can trim it down to our own preferences (though in my opinion that’s usually not needed). In fact, it is possible to run a Phoenix powered server without a router, controller, view, and template. In this article I’ll show you how, and then I’ll provide some tips on learning Phoenix. But first, I’ll briefly touch on the relationship between Phoenix and Plug.</p>
<h2>
Phoenix and Plug</h2>
<p>
Phoenix owes its modularity to <a href="https://github.com/elixir-lang/plug">Plug</a>. Many Phoenix abstractions, such as endpoint, router, or controller, are implemented as <em>plugs</em>, so let’s quickly recap the idea of Plug.</p>
<p>
When a request arrives, the Plug library will create a <code class="inline">Plug.Conn</code> struct (aka <em>conn</em>). This struct bundles various fields describing the request (e.g. the IP address of the client, the path, headers, cookies) together with the fields describing the response (e.g. status, body, headers). Once the conn struct is initialized, Plug will call our function to handle the request. The task of our code is to take the conn struct and return the transformed version of it with populated output fields. The Plug library then uses the underlying HTTP library (for example Cowboy) to return the response. There are some fine-print variations to this concept, but they’re not relevant for this discussion.</p>
<p>
So essentially, our request handler is a function that takes a conn and transforms it. In particular, each function that takes two arguments (a conn and arbitrary options) is called a <em>plug</em>. Additionally, a plug can be a module that implements two functions <code class="inline">init/1</code> which provides the options, and <code class="inline">call/2</code> which takes a conn and options, and returns the transformed conn.</p>
<p>
Request handlers can be implemented as a chain of such plugs, with the help of <a href="http://hexdocs.pm/plug/Plug.Builder.html">Plug.Builder</a>. Since a plug is basically a function, your request handler boils down to a chain of functions threading the conn struct. Each function takes a conn, does it’s own processing, and produces a transformed version of it. Then the next function in the chain is invoked to do its job.</p>
<p>
Each plug in the chain can do various tasks, such as logging (<code class="inline">Plug.Logger</code>), converting the input (for example <code class="inline">Plug.Head</code> which transforms a <code class="inline">HEAD</code> request into <code class="inline">GET</code>), or producing the output (e.g. <code class="inline">Plug.Static</code> which serves files from the disk). It is also easy to write your own plugs, for example to authenticate users, or to perform some other custom action. For example, for this site <a href="https://github.com/sasa1977/erlangelist/blob/master/site/web/plugs/visit.ex">I implemented a plug which counts visits, measures the processing time, and sends stats to graphite</a>. Typically, the last function in the chain will be the “core” handler which performs some request-specific processing, such as data manipulation, or some computation, and produces the response.</p>
<p>
When it comes to Phoenix, endpoint, router, and controllers are all plugs. Your request arrives to the endpoint which specifies some common plugs (e.g. serving of static files, logging, session handling). By default, the last plug listed in the endpoint is the router where request path is mapped to some controller, which is itself yet another plug in the chain.</p>
<h2>
Trimming down Phoenix</h2>
<p>
Since all the pieces in Phoenix are plugs, and plugs are basically functions, nothing stops you from removing any part out of the chain. The only thing you need for a basic Phoenix web app is the endpoint. Let’s see an example. I’ll create a simple “Hello World” web server based on Phoenix. This server won’t rely on router, controllers, views, and templates.</p>
<p>
First, I need to generate a new Phoenix project with <code class="inline">mix phoenix.new simple_server –no-ecto –no-brunch –no-html</code>. The options specify I want to omit Ecto, Brunch, and HTML views from the generated project. This already makes the generated code thinner than the default version.</p>
<p>
There are still some pieces that can be removed, and I’ve done that in <a href="https://github.com/sasa1977/erlangelist/commit/964f52eddd01610f729e2bd988e203428291cf82">this commit</a>. The most important change is that I’ve purged all the plugs from the endpoint, reducing it to:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">SimpleServer.Endpoint</span><span class="w"> </span><span class="k" data-group-id="2682208660-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:simple_server</span><span class="w">
</span><span class="k" data-group-id="2682208660-1">end</span></code></pre>
<p>
All requests will end up in an endpoint which does nothing, so every request will result in a 500 error. This is a consequence of removing all the default stuff. There are no routers, controllers, views, or templates anymore, and there’s no default behaviour. The “magic” has disappeared and it’s up to us to recreate it manually.</p>
<p>
Handling a request can now be as simple as:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">SimpleServer.Endpoint</span><span class="w"> </span><span class="k" data-group-id="1784849870-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:simple_server</span><span class="w">

  </span><span class="n">plug</span><span class="w"> </span><span class="ss">:render</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">render</span><span class="p" data-group-id="1784849870-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_opts</span><span class="p" data-group-id="1784849870-2">)</span><span class="w"> </span><span class="k" data-group-id="1784849870-3">do</span><span class="w">
    </span><span class="nc">Plug.Conn</span><span class="o">.</span><span class="n">send_resp</span><span class="p" data-group-id="1784849870-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World!&quot;</span><span class="p" data-group-id="1784849870-4">)</span><span class="w">
  </span><span class="k" data-group-id="1784849870-3">end</span><span class="w">
</span><span class="k" data-group-id="1784849870-1">end</span></code></pre>
<p>
And there you have it! A Phoenix-powered “Hello World” in less than 10 lines of code. Not so bad :-)</p>
<h2>
Reusing desired Phoenix pieces</h2>
<p>
Since Phoenix is modular, it’s fairly easy to reintroduce some parts of it if needed. For example, if you want to log requests, you can simply add the following plugs to your endpoint:</p>
<pre><code class="highlight makeup elixir"><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.RequestId</span><span class="w">
</span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Logger</span></code></pre>
<p>
If you want to use the Phoenix router, you can add <code class="inline">plug MyRouter</code> where <code class="inline">MyRouter</code> is built on top of <a href="http://hexdocs.pm/phoenix/Phoenix.Router.html">Phoenix.Router</a>. Perhaps you prefer the Plug router? Simply implement <code class="inline">MyRouter</code> as <a href="http://hexdocs.pm/plug/Plug.Router.html">Plug.Router</a>.</p>
<p>
Let’s see a different example. Instead of shaping strings manually, I’ll reuse Phoenix templates support, so I can write EEx templates.</p>
<p>
First, I’ll create the <code class="inline">web/templates/index.html.eex</code> file:</p>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    Hello World!
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>
Then, relying on <a href="http://hexdocs.pm/phoenix/Phoenix.Template.html">Phoenix.Template</a>, I’ll compile all templates from the <code class="inline">web/templates</code> folder into a single module:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">SimpleServer.View</span><span class="w"> </span><span class="k" data-group-id="3095661383-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Template</span><span class="p">,</span><span class="w"> </span><span class="ss">root</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;web/templates&quot;</span><span class="w">
</span><span class="k" data-group-id="3095661383-1">end</span></code></pre>
<p>
Now, I can call <code class="inline">SimpleServer.View.render(“index.html”)</code> to produce the output string:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">SimpleServer.Endpoint</span><span class="w"> </span><span class="k" data-group-id="5147928919-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:simple_server</span><span class="w">

  </span><span class="n">plug</span><span class="w"> </span><span class="ss">:render</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">render</span><span class="p" data-group-id="5147928919-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_opts</span><span class="p" data-group-id="5147928919-2">)</span><span class="w"> </span><span class="k" data-group-id="5147928919-3">do</span><span class="w">
    </span><span class="n">conn</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Plug.Conn</span><span class="o">.</span><span class="n">put_resp_content_type</span><span class="p" data-group-id="5147928919-4">(</span><span class="s">&quot;text/html&quot;</span><span class="p" data-group-id="5147928919-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Plug.Conn</span><span class="o">.</span><span class="n">send_resp</span><span class="p" data-group-id="5147928919-5">(</span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="nc">SimpleServer.View</span><span class="o">.</span><span class="n">render</span><span class="p" data-group-id="5147928919-6">(</span><span class="s">&quot;index.html&quot;</span><span class="p" data-group-id="5147928919-6">)</span><span class="p" data-group-id="5147928919-5">)</span><span class="w">
  </span><span class="k" data-group-id="5147928919-3">end</span><span class="w">
</span><span class="k" data-group-id="5147928919-1">end</span></code></pre>
<p>
Finally, I need to set the encoder for the HTML format in <code class="inline">config.exs</code>:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># config.exs</span><span class="w">

</span><span class="n">config</span><span class="w"> </span><span class="ss">:phoenix</span><span class="p">,</span><span class="w"> </span><span class="ss">:format_encoders</span><span class="p">,</span><span class="w"> </span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="nc">Phoenix.HTML.Engine</span><span class="w">

</span><span class="c1"># ...</span></code></pre>
<p>
And that’s it! The output is now rendered through a precompiled EEx template. And still, no router, controller, or Phoenix view has been used. You can find the complete solution <a href="https://github.com/sasa1977/erlangelist/tree/b31cd0dbcf222bc737d59951157077d8127535aa/examples/simple_server">here</a>.</p>
<p>
It’s worth noting that by throwing most of the default stuff out, we also lost many benefits of Phoenix. This simple server doesn’t serve static files, log requests, handle sessions, or parse the request body. Live reload also won’t work. You can of course reintroduce these features if you need them.</p>
<h2>
What’s the point?</h2>
<p>
To be honest, I usually wouldn’t recommend this fully sliced-down approach. My impression is that the default code generated with <code class="inline">mix phoenix.new</code> is a sensible start for most web projects. Sure, you have to spend some time understanding the flow of a request, and roles of endpoint, router, view, and template, but I think it will be worth the effort. At the end of the day, as Chris frequently said, Phoenix aims to provide the “batteries included” experience, so the framework is bound to have some inherent complexity. I wouldn’t say it’s super complex though. You need to take some time to let it sink in, and you’re good to go. It’s a one off investment, and not a very expensive one.</p>
<p>
That being said, if you have simpler needs, or you’re overwhelmed by many different Phoenix concepts, throwing some stuff out might help. Hopefully it’s now obvious that Phoenix is quite tunable. Once you understand Plug it’s fairly easy to grasp how a request is handled in Phoenix. Tweaking the server to your own needs is just a matter of removing the plugs you don’t want. In my opinion, this is the evidence of a good and flexible design. All the steps are spelled out for you in your project’s code, so everything is explicit and you can tweak it as you please.</p>
<h2>
Learning tips</h2>
<p>
Learning Phoenix is still not a small task, especially if you’re new to Elixir and OTP. If your Elixir journey starts with Phoenix, you’ll need to learn the new language, adapt to functional programming, understand BEAM concurrency, become familiar with OTP, and learn Plug, Phoenix, and probably Ecto. While none of these tasks is a “rocket science”, there’s obviously quite a lot of ground to cover. Taking so many new things at once can overwhelm even the best of us.</p>
<p>
So what can be done about it?</p>
<p>
One possible approach is a full “bottom-up”, where you focus first on Elixir, learn its building blocks and familiarize yourself with functional programming. Then you can move to vanilla processes, then to OTP behaviours (most notably <code class="inline">GenServer</code> and <code class="inline">Supervisor</code>), and finally OTP applications. Once you gain some confidence there, you “only” need to understand Plug and Phoenix specifics, which should be easier if you built solid foundations. I’m not suggesting you need to fully master one phase before moving to the next one. But I do think that building some solid understanding of basic concepts will make it easier to focus on the next stage.</p>
<p>
The benefit of this approach is that you get a steady incremental progress. Understanding concurrency is easier if you don’t have to wrestle with the language. Grasping Phoenix is easier if you’re already confident with Elixir, OTP, and Plug. The downside is that you’ll reach the final goal at the very end. You’re probably interested in Phoenix because you want to build scalable, distributed, real-time web servers, but you’ll spend a lot of time transforming lists with plain recursion, or passing messages between processes, before you’re even able to handle a basic request. It takes some commitment to endure this first period.</p>
<p>
If you prefer to see some tangible results immediately, you could consider a “two-pass bottom-up” approach. In this version, you could first go through excellent official getting started guides on Elixir and Phoenix sites. These should get you up to speed more swiftly than reading a few hundred pages book(s), though you won’t get as much depth. On the plus side, you’ll be able to experiment and prototype much earlier in the learning process. Then you can start refining your knowledge in the second pass, perhaps by reading some books, watching videos, or reading the official docs.</p>
<p>
There are of course many other strategies you can take, so it’s up to you to choose what works best for you. Whichever way you choose, don’t be overwhelmed by the amount of material. Try to somehow split the learning path into smaller steps, and take new topics gradually. It’s hard if not impossible to learn everything at once. It’s a process that takes some time, but in my opinion, the effort is definitely worth the gain. I’m a very happy customer of Erlang/OTP/Elixir/Phoenix, and I don’t think any other stack can give me the same benefits.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2016, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/phoenix_is_modular">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/phoenix_is_modular.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate></item><item><title>Driving Phoenix sockets</title><link>http://theerlangelist.com//article/driving_phoenix_sockets</link><description><![CDATA[<h1>Driving Phoenix sockets</h1>
<h4 class="right">2016-01-25</h4>

<div class="article-body">
<p>
A few months ago, we’ve witnessed Phoenix team establishing 2 millions simultaneous connections on a single server. In the process, they also discovered and removed some bottlenecks. The whole process is documented in <a href="http://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections">this excellent post</a>. This achievement is definitely great, but reading the story begs a question: do we really need a bunch of expensive servers to study the behaviour of our system under load?</p>
<p>
In my opinion, many issues can be discovered and tackled on a developer’s machine, and in this post, I’ll explain how. In particular, I’ll discuss how to programmatically “drive” a Phoenix socket, talk a bit about the transport layer, and cap it off by creating a half million of Phoenix sockets on my dev machine and explore the effects of process hibernation on memory usage.</p>
<h2>
The goal</h2>
<p>
The main idea is fairly simple. I’ll develop a helper <code class="inline">SocketDriver</code> module, which will allow me to create a Phoenix socket in a separate Erlang process, and then control it by sending it channel-specific messages.</p>
<p>
Assuming we have a Phoenix application with <a href="https://github.com/sasa1977/erlangelist/blob/eb3c8d8cc76572b26ee3cb9c84791304a3aeee54/examples/socket_driver/web/channels/user_socket.ex">a socket</a> and <a href="https://github.com/sasa1977/erlangelist/blob/eb3c8d8cc76572b26ee3cb9c84791304a3aeee54/examples/socket_driver/web/channels/ping_channel.ex">a channel</a>, we’ll be able to create a socket in a separate process by invoking:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="p" data-group-id="8889792343-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">socket_pid</span><span class="p" data-group-id="8889792343-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SocketDriver</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="8889792343-2">(</span><span class="w">
          </span><span class="nc">SocketDriver.Endpoint</span><span class="p">,</span><span class="w">
          </span><span class="nc">SocketDriver.UserSocket</span><span class="p">,</span><span class="w">
          </span><span class="ss">receiver</span><span class="p">:</span><span class="w"> </span><span class="n">self</span><span class="w">
        </span><span class="p" data-group-id="8889792343-2">)</span></code></pre>
<p>
The <code class="inline">receiver: self</code> bit specifies that all outgoing messages (the ones sent by the socket to the other side) will be sent as plain Erlang messages to the caller process.</p>
<p>
Now I can ask the socket process to join the channel:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="nc">SocketDriver</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="8315278484-1">(</span><span class="n">socket_pid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ping_topic&quot;</span><span class="p" data-group-id="8315278484-1">)</span></code></pre>
<p>
Then, I can verify that the socket sent the response back:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(3)&gt; </span><span class="n">flush</span><span class="w">

</span><span class="p" data-group-id="0326120298-1">{</span><span class="ss">:message</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="0326120298-2">%</span><span class="nc" data-group-id="0326120298-2">Phoenix.Socket.Reply</span><span class="p" data-group-id="0326120298-2">{</span><span class="ss">payload</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0326120298-3">%{</span><span class="s">&quot;response&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p" data-group-id="0326120298-3">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">ref</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0326120298-4">#</span><span class="nc" data-group-id="0326120298-4">Reference</span><span class="p" data-group-id="0326120298-4">&lt;</span><span class="mf">0.0</span><span class="o">.</span><span class="mf">4.1584</span><span class="p" data-group-id="0326120298-4">&gt;</span><span class="p">,</span><span class="w"> </span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="ss">topic</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;ping_topic&quot;</span><span class="p" data-group-id="0326120298-2">}</span><span class="p" data-group-id="0326120298-1">}</span></code></pre>
<p>
Finally, I can also push a message to the socket and verify the outgoing message:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(4)&gt; </span><span class="nc">SocketDriver</span><span class="o">.</span><span class="n">push</span><span class="p" data-group-id="3407632012-1">(</span><span class="n">socket_pid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ping_topic&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ping&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3407632012-2">%{</span><span class="p" data-group-id="3407632012-2">}</span><span class="p" data-group-id="3407632012-1">)</span><span class="w">

</span><span class="gp unselectable">iex(5)&gt; </span><span class="n">flush</span><span class="w">
</span><span class="p" data-group-id="3407632012-3">{</span><span class="ss">:message</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="3407632012-4">%</span><span class="nc" data-group-id="3407632012-4">Phoenix.Socket.Message</span><span class="p" data-group-id="3407632012-4">{</span><span class="ss">event</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;pong&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">payload</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3407632012-5">%{</span><span class="p" data-group-id="3407632012-5">}</span><span class="p">,</span><span class="w"> </span><span class="ss">ref</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w">
  </span><span class="ss">topic</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;ping_topic&quot;</span><span class="p" data-group-id="3407632012-4">}</span><span class="p" data-group-id="3407632012-3">}</span></code></pre>
<p>
With such driver I can now easily create a bunch of sockets from the iex shell and play with them. Later on you’ll see a simple demo, but let’s first explore how can such driver be developed.</p>
<h2>
Possible approaches</h2>
<p>
Creating and controlling sockets can easily be done with the help of the <a href="http://hexdocs.pm/phoenix/Phoenix.ChannelTest.html">Phoenix.ChannelTest</a> module. Using macros and functions, such as <code class="inline">connect/2</code>, <code class="inline">subscribe_and_join/4</code> and <code class="inline">push/3</code>, you can easily create sockets, join channels, and push messages. After all, these macros are made precisely for the purpose of programmatically driving sockets in unit tests.</p>
<p>
This approach should work nicely in unit tests, but I’m not sure it’s appropriate for load testing. The most important reason is that these functions are meant to be invoked from within the test process. This is actually perfect for unit tests, but in a load test I’d like to be closer to the real thing. Namely I’d like to run each socket in a separate process, and at that point the amount of housekeeping I need to do increases, and I’m practically implementing a Phoenix socket transport (I’ll explain what this means in a minute).</p>
<p>
In addition, <code class="inline">Phoenix.ChannelTest</code> seems to rely on some internals of sockets and channels, and its functions create one <code class="inline">%Socket{}</code> struct per each connected client, something which is not done by currently existing Phoenix transports.</p>
<p>
So instead, I’ll implement <code class="inline">SocketDriver</code> as a partial Phoenix transport, namely a <code class="inline">GenServer</code> that can be used to create and control a socket. This will allow me to be closer to existing transports. Moreover, it’s an interesting exercise to learn something about Phoenix internals. Finally, such socket driver can be used beyond load testing purposes, for example to expose different access points which can exist outside of Cowboy and Ranch.</p>
<h2>
Sockets, channels, transports, and socket driver</h2>
<p>
Before going further, let’s discuss some terminology.</p>
<p>
The idea of sockets and channels is pretty simple, yet very elegant. A <strong>socket</strong> is an abstracted long-running connection between the client and the server. Messages can be wired through websocket, long polling, or practically anything else.</p>
<p>
Once the socket is established, the client and the server can use it to hold multiple conversations on various topic. These conversations are called <strong>channels</strong>, and they amount to exchanging messages and managing channel-specific state on each side.</p>
<p>
The corresponding process model is pretty reasonable. One process is used for the socket, and one for each channel. If a client opens 2 sockets and joins 20 topics on each socket, we’ll end up with 42 processes: <code class="inline">2 * (1 socket process + 20 channel processes)</code>.</p>
<p>
A Phoenix socket <strong>transport</strong> is the thing that powers the long running connection. Owing to transports, <code class="inline">Phoenix.Socket</code>, <code class="inline">Phoenix.Channel</code>, and your own channels, can safely assume they’re operating on a stateful, long-running connection regardless of how this connection is actually powered.</p>
<p>
You can implement your own transports, and thus expose various communication mechanisms to your clients. On the flip side, implementing a transport is somewhat involved, because various concerns are mixed in this layer. In particular, a transport has to:</p>
<ul>
  <li>
Manage a two-way stateful connection  </li>
  <li>
Accept incoming messages and dispatch them to channels  </li>
  <li>
React to channel messages and dispatch responses to the client  </li>
  <li>
Manage the mapping of topics to channel processes in a <code class="inline">HashDict</code> (and usually the reverse mapping as well)  </li>
  <li>
Trap exits, react to exits of channel processes  </li>
  <li>
Provide adapters for underlying http server libraries, such as Cowboy  </li>
</ul>
<p>
In my opinion that’s a lot of responsibilities bundled together, which makes the implementation of a transport more complex than it should be, introduces some code duplication, and makes transports less flexible than they could be. I shared these concerns with Chris and José, so there are chances this might be improved in the future.</p>
<p>
As it is, if you want to implement a transport, you need to tackle the points above, save possibly one: in case your transport doesn’t need to be exposed through an http endpoint, you can skip the last point, i.e. you don’t need to implement Cowboy (or some other web library) adapter. This effectively means you’re not a Phoenix transport anymore (because you can’t be accessed through the endpoint), but you’re still able to create and control a Phoenix socket. This is what I’m calling a <strong>socket driver</strong>.</p>
<h2>
The implementation</h2>
<p>
Given the list above, the implementation of <code class="inline">SocketDriver</code> is fairly straightforward, but somewhat involved, so I’ll refrain from step-by-step explanation. You can find the full code <a href="https://github.com/sasa1977/erlangelist/blob/eb3c8d8cc76572b26ee3cb9c84791304a3aeee54/examples/socket_driver/lib/socket_driver.ex">here</a>, with some basic comments included.</p>
<p>
The gist of it is, you need to invoke some <code class="inline">Phoenix.Socket.Transport</code> functions at proper moments. First, you need to invoke <code class="inline">connect/6</code> to create the socket. Then, for every incoming message (i.e. a message that was sent by the client), you need to invoke <code class="inline">dispatch/3</code>. In both cases, you’ll get some channel-specific response which you must handle.</p>
<p>
Additionally, you need to react to messages sent from channel processes and the PubSub layer. Finally, you need to detect terminations of channel processes and remove corresponding entries from your internal state.</p>
<p>
I should mention that this <code class="inline">SocketDriver</code> uses a non-documented <code class="inline">Phoenix.ChannelTest.NoopSerializer</code> - a serializer that doesn’t encode/decode messages. This will keep things simple, but it will also remove the encoding/decoding job out of the tests.</p>
<h2>
Creating 500k sockets &amp; channels</h2>
<p>
With <code class="inline">SocketDriver</code> in place, we can now easily create a bunch of sockets locally. I’ll do this in the <code class="inline">prod</code> environment to mimic the production more closely.</p>
<p>
A basic Phoenix server with a simple socket/channel can be found <a href="https://github.com/sasa1977/erlangelist/tree/eb3c8d8cc76572b26ee3cb9c84791304a3aeee54/examples/socket_driver">here</a>. I need to compile it in prod (<code class="inline">MIX_ENV=prod mix compile</code>), and then I can start it with:</p>
<pre><code class="bash">MIX_ENV=prod PORT=4000 iex --erl &quot;+P 10000000&quot; -S mix phoenix.server</code></pre>
<p>
The <code class="inline">–erl “+P 10000000”</code> option increases the default maximum number of processes to 10 millions. I plan to create 500k sockets, so I need a bit more than a million of processes, but to be on the safe side, I’ve chosen a much larger number. Creating sockets is now as simple as:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="o">.</span><span class="o">.</span><span class="mi">500_000</span><span class="w"> </span><span class="k" data-group-id="7845607247-1">do</span><span class="w">
          </span><span class="c1"># Start the socket driver process</span><span class="w">
          </span><span class="p" data-group-id="7845607247-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="7845607247-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SocketDriver</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="7845607247-3">(</span><span class="w">
            </span><span class="nc">SocketDriver.Endpoint</span><span class="p">,</span><span class="w">
            </span><span class="nc">SocketDriver.UserSocket</span><span class="w">
          </span><span class="p" data-group-id="7845607247-3">)</span><span class="w">

          </span><span class="c1"># join the channel</span><span class="w">
          </span><span class="nc">SocketDriver</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="7845607247-4">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ping_topic&quot;</span><span class="p" data-group-id="7845607247-4">)</span><span class="w">
        </span><span class="k" data-group-id="7845607247-1">end</span></code></pre>
<p>
It takes about a minute on my machine to create all these sockets and then I can fire up the observer. Looking at the System tab, I can see that about a million of processes are running, as expected:</p>
<p>
  <img src="/images/500k_sockets_no_hibernation.png" alt="Observer results" />
</p>
<p>
I should also mention that <a href="https://github.com/sasa1977/erlangelist/blob/eb3c8d8cc76572b26ee3cb9c84791304a3aeee54/examples/socket_driver/config/prod.exs#L20">I’ve changed the default logger level setting to <code class="inline">:warn</code> in prod</a>. By default, this setting is <code class="inline">:info</code> which will dump a bunch of logs to the console. This in turn might affect the throughput of your load generator, so I raised this level to mute needless messages.</p>
<p>
Also, to make the code runnable out of the box, <a href="https://github.com/sasa1977/erlangelist/blob/eb3c8d8cc76572b26ee3cb9c84791304a3aeee54/examples/socket_driver/config/prod.exs#L65">I removed the need for the <code class="inline">prod.secret.exs</code> file</a>. Obviously a very bad practice, but this is just a demo, so we should be fine. Just keep in mind to avoid developing any production on top of my (or your own) hacky experiments :-)</p>
<h2>
Hibernating processes</h2>
<p>
If you take a closer look at the image above, you’ll see that the memory usage of about 6GB is somewhat high, though I wouldn’t call it excessive for so many created sockets. I’m not sure whether Phoenix team did some memory optimizations, so there’s possibility this overhead might be reduced in future versions.</p>
<p>
As it is, let’s see whether process hibernation can help us reduce this memory overhead. Note that this is a shallow experiment, so don’t draw any hard conclusions. This will be more like a simple demo of how we can quickly gain some insights by creating a bunch of sockets on our dev box, and explore various routes locally.</p>
<p>
First a bit of theory. You can reduce the memory usage of the process by hibernating it with <a href="http://erlang.org/doc/man/erlang.html#hibernate-3">:erlang.hibernate/3</a>. This will trigger the garbage collection of the process, shrink the heap, truncate the stack, and put the process in the waiting state. The process will be awoken when it receives a message.</p>
<p>
When it comes to <code class="inline">GenServer</code>, you can request the hibernation by appending the <code class="inline">:hibernate</code> atom to most of return tuples in your callback functions. So for example instead of <code class="inline">{:ok, state}</code> or <code class="inline">{:reply, response, state}</code>, you can return <code class="inline">{:ok, state, :hibernate}</code> and <code class="inline">{:reply, response, state, :hibernate}</code> from <code class="inline">init/1</code> and <code class="inline">handle_call/3</code> callbacks.</p>
<p>
Hibernation can help reducing memory usage of processes which are not frequently active. You pay some CPU price, but you get some memory in return. Like most other things in life, hibernation is a tool, not a silver bullet.</p>
<p>
So let’s see whether we can gain something by hibernating socket and channel processes. First, I’ll modify <code class="inline">SocketDriver</code> by adding <code class="inline">:hibernate</code> to <code class="inline">init</code>, <code class="inline">handle_cast</code>, and <code class="inline">handle_info</code> callbacks in <code class="inline">SocketDriver</code>. With these changes, I get following results:</p>
<p>
  <img src="/images/500k_sockets_hibernation.png" alt="Observer results" />
</p>
<p>
This is about 40% less memory used, which seems promising. It’s worth mentioning that this is not a conclusive test. I’m hibernating my own socket driver, so I’m not sure whether the same saving would happen in the websocket transport, which is not <code class="inline">GenServer</code> based. However, I’m somewhat more certain that hibernating might help with long polling, where a socket is <a href="https://github.com/phoenixframework/phoenix/blob/v1.1.3/lib/phoenix/transports/long_poll_server.ex#L18-L21">driven by a GenServer process</a>, which is similar to <code class="inline">SocketDriver</code> (in fact, I consulted Phoenix code a lot while developing <code class="inline">SocketDriver</code>).</p>
<p>
In any case, these tests should be retried with real transports, which is one reason why this experiment is somewhat contrived and non-conclusive.</p>
<p>
Regardless, let’s move on and try to hibernate channel processes. I modified <code class="inline">deps/phoenix/lib/phoenix/channel/server.ex</code> to make the channel processes hibernate. After recompiling deps and creating 500k sockets, I noticed additional memory saving of 800MB:</p>
<p>
  <img src="/images/500k_sockets_channel_hibernation.png" alt="Observer results" />
</p>
<p>
After hibernating sockets and channels, the memory usage is reduced by more than 50%. Not too shabby :-)</p>
<p>
Of course, it’s worth repeating that the hibernation comes with a price which is CPU usage. By hibernating, we force some work to be done immediately, so it should be used carefully and the effects on performance should be measured.</p>
<p>
Also, let me stress again that this is a very shallow test. At best these results can serve as an indication, a clue as to whether hibernation might help. Personally, I think it’s a useful hint. In a real system the state of your channels might be more complex, and they might perform various transformations. Thus, in some cases, occasional hibernation might bring some nice savings. Therefore, I think Phoenix should allow us to request hibernation of our channel processes through callback tuples.</p>
<h2>
Conclusion</h2>
<p>
The main point of this article is that by driving Phoenix sockets, you can quickly gain some insights on how your system behaves under a more significant load. You can start the server, kick off some synthetic loader, and observe the system’s behaviour. You can gather feedback and try some alternatives more quickly, and in the process you don’t need to shell out tons of money for beefy servers, nor spend a lot of time tweaking the OS settings to accommodate a lot of open network sockets.</p>
<p>
Of course, don’t mistake this for a full test. While driving sockets can help you get some insights, it doesn’t paint the whole picture, because network I/O is bypassed. Moreover, since the loader and the server are running on the same machine, thus competing for the same resources, the results might be skewed. An intensive loader might affect the performance of the server.</p>
<p>
To get the whole picture, you’ll probably want to run final end-to-end tests on production-like server with separate client machines. But you can do this less often and be more confident that you’ve handled most problems before you moved to the more complicated stage of testing. In my experience, a lot of low-hanging fruit can be picked by exercising the system locally.</p>
<p>
Finally, don’t put too much faith in synthetic tests, because they will not be able to completely simulate the chaotic and random patterns of the real life. That doesn’t mean such tests are useless, but they’re definitely not conclusive. As the old saying goes: “There’s no test like production!” :-)</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2016, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/driving_phoenix_sockets">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/driving_phoenix_sockets.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate></item><item><title>Elixir 1.2 and Elixir in Action</title><link>http://theerlangelist.com//article/eia_elixir_12</link><description><![CDATA[<h1>Elixir 1.2 and Elixir in Action</h1>
<h4 class="right">2016-01-06</h4>

<div class="article-body">
<p>
<a href="http://elixir-lang.org/blog/2016/01/03/elixir-v1-2-0-released/">Elixir 1.2 is out</a>, and this is the second minor release since Elixir in Action has been published, so I wanted to discuss some consequences of new releases on the book’s material.</p>
<p>
Since the book focuses on concurrency and OTP principles, most of its content is still up to date. OTP is at this point pretty stable and not likely to be significantly changed. Moreover, Elixir 1.2 is mostly downwards compatible, meaning that the code written for earlier 1.x versions should compile and work on 1.2. In some cases, some minor modifications might be required, in which case the compiler should emit a corresponding error/warning.</p>
<p>
 All that said, some information in the book is not completely accurate anymore, so I’d like to point out a few things.</p>
<h2>
Updated code examples</h2>
<p>
Some minor changes had to be made to make the code examples work, most notably <a href="https://github.com/sasa1977/elixir-in-action/commit/05b6fb3a73db893727a5b9b43da4087af878f058">relaxing the versioning requirement in mix.exs</a>. You can find the 1.2 compliant code examples <a href="https://github.com/sasa1977/elixir-in-action/tree/Elixir-v1.2">here</a>.</p>
<h2>
Deprecating Dict and Set</h2>
<p>
Elixir 1.2 requires Erlang 18.x which brings a couple of big changes. You can see the highlights <a href="http://www.erlang.org/download_release/29">here</a>, but in the context of EiA, the most important improvement deals with maps which now perform well for large datasets. Consequently, <code class="inline">HashDict</code> and <code class="inline">HashSet</code> are becoming redundant.</p>
<p>
Therefore the Elixir core team decided to deprecate following k-v and set related modules: <code class="inline">Dict</code>, <code class="inline">Set</code>, <code class="inline">HashDict</code>, and <code class="inline">HashSet</code>. These modules are <strong>soft</strong> deprecated, meaning that they will in fact still work, but their usage is discouraged as they are marked for subsequent removal. If you’re developing for Elixir 1.2+ you’re encouraged to use plain maps for k-v structure, and the new type <a href="https://hexdocs.pm/elixir/MapSet.html">MapSet</a> (internally also powered by maps) for sets.</p>
<p>
There’s one important caveat: if your code must work on Elixir 1.0 and 1.1, then you should in fact still prefer <code class="inline">HashDict</code> and <code class="inline">HashSet</code>. The reason is that the older Elixir version can run on Erlang 17, so if your code uses large maps, the performance might suffer.</p>
<p>
For Elixir in Action, this means that all the code that’s using <code class="inline">HashDict</code> should be changed to use maps. Most notably, the <code class="inline">Todo.List</code> abstraction should internally use maps to maintain the <code class="inline">entries</code> field. You can see the changes in <a href="https://github.com/sasa1977/elixir-in-action/commit/51bc04bf48730bfbb6141ad781f8300cc6e91db5">this commit</a>.</p>
<h2>
Protocol consolidation</h2>
<p>
Starting Elixir 1.2, protocols are consolidated by default in all build environments (you can change this by setting <code class="inline">consolidate_protocols: false</code> in the project config). As a result, the subsection “Protocol Consolidation” (page 326) becomes redundant. With new Elixir you don’t need to worry about consolidation.</p>
<h2>
Embedded build and permanent applications</h2>
<p>
This change has been introduced way back in Elixir 1.0.4, and there’s <a href="http://blog.plataformatec.com.br/2015/04/build-embedded-and-start-permanent-in-elixir-1-0-4/">a nice post by José Valim on the subject</a>.</p>
<p>
The gist of the story is that two mix properties are introduced which allow you to configure the “embedded build” and “permanent applications”. By default, new projects generated with Elixir 1.0.4+ will have these properties set to true for <code class="inline">prod</code> mix environment. If you generated your project before 1.0.4, you should add the following options to your <code class="inline">mix.exs</code> (in the <code class="inline">project/0</code>):</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">project</span><span class="w"> </span><span class="k" data-group-id="4504825061-1">do</span><span class="w">
  </span><span class="p" data-group-id="4504825061-2">[</span><span class="w">
    </span><span class="c1"># ...</span><span class="w">
    </span><span class="ss">build_embedded</span><span class="p">:</span><span class="w"> </span><span class="nc">Mix</span><span class="o">.</span><span class="n">env</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:prod</span><span class="p">,</span><span class="w">
    </span><span class="ss">start_permanent</span><span class="p">:</span><span class="w"> </span><span class="nc">Mix</span><span class="o">.</span><span class="n">env</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:prod</span><span class="w">
  </span><span class="p" data-group-id="4504825061-2">]</span><span class="w">
</span><span class="k" data-group-id="4504825061-1">end</span></code></pre>
<p>
When the <code class="inline">:build_embedded</code> option is set to true, the target folder will not contain symlinks. Instead, all data that needs to be in that folder (e.g. the content of the <code class="inline">priv</code> folder) will be copied.</p>
<p>
The <code class="inline">start_permanent</code> option, if set to true, will cause the OTP application to be started as permanent. If the application crashes, that is if the top-level supervisor terminates, the whole BEAM node will be terminated. This makes sense in the production, because it allows you to to detect application crash in another OS process, and do something about it.</p>
<p>
As José explains, it’s sensible to set both options to true for production environment. In contrast, you probably want to have them unset during development for convenience.</p>
<h2>
That’s all folks :-)</h2>
<p>
Yep, nothing else of the book content is affected by new changes to Elixir. However, many cool features have been introduced since Elixir 1.0, such as the <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1">with special form</a>, or the <a href="https://hexdocs.pm/mix/Mix.Tasks.Profile.Fprof.html">mix profile.fprof</a> task. Therefore, I suggest reading through the <a href="https://github.com/elixir-lang/elixir/releases">changelogs of recent releases</a> :-)</p>
<p>
Happy coding!</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2016, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/eia_elixir_12">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/eia_elixir_12.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Wed, 6 Jan 2016 00:00:00 +0000</pubDate></item><item><title>Open-sourcing Erlangelist</title><link>http://theerlangelist.com//article/opensourcing_erlangelist</link><description><![CDATA[<h1>Open-sourcing Erlangelist</h1>
<h4 class="right">2015-11-01</h4>

<div class="article-body">
<p>
It is a great pleasure to announce that <a href="https://github.com/sasa1977/erlangelist">The Erlangelist is now open-sourced</a>. Last week I have made the switch to the completely rewritten, new version of the site, and with this post I’m also making the repository public.</p>
<h2>
Changelog</h2>
<p>
From the end user’s perspective there aren’t many changes:</p>
<ul>
  <li>
Comments are now powered by Disqus.  </li>
  <li>
Some of the past articles are not migrated to the new site. You can still find them at the <a href="http://theerlangelist.blogspot.com">old blogger site</a>.  </li>
  <li>
All articles are now licensed under a under a <a href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.  </li>
  <li>
<a href="/privacy_policy.html">Privacy policy</a> is now included.  </li>
  <li>
The UI went through some minor cosmetic changes (though sadly it still reflects how much I suck at UI/UX).  </li>
  <li>
Article links have changed, but old urls still work. If your site points to this blog (thanks for the plug), the link should still work (even if pointing to a non-migrated article)  </li>
</ul>
<h2>
Internals</h2>
<p>
The Erlangelist site was previously hosted on Blogger, but now it’s fully rewritten from scratch and self-hosted on a cheap VPS. I plan on writing more in-depth posts in the future, but here’s a general technical overview.</p>
<p>
The site is powered by Elixir and Phoenix. All requests are accepted directly in the Erlang VM, i.e. there’s no nginx or something similar in front.</p>
<p>
PostgreSQL is used to store some data about each request, so I can later get some basic server usage stats (views, visitors, referers).</p>
<p>
In addition, I’m running a local instance of the <a href="https://github.com/fiorix/freegeoip">freegeoip.net</a> site, which allows me to determine your geolocation. Currently, only your country information is used. This is stored in the database request log, because I’d like to know where my visitors come from. In addition, I use this information to explicitly ask EU based users to allow usage of cookies.</p>
<p>
Finally, Graphite is used to visualize some general stats. I use collectd to gather system metrics, and Exometer for some basic Erlang VM information.</p>
<p>
All of the components (save collectd) are running inside Docker containers which are started as systemd units. The initial server setup is done with Ansible, and the deploy is performed with <code class="inline">git push</code> to the server.</p>
<h2>
Why?</h2>
<p>
First of all, I want to point out the obvious: implementing a web server from scratch is clearly a wrong approach to write a blog.</p>
<p>
It requires a lot of time and energy in dealing with the whole stack: backend implementation, frontend &amp; UI, server administration, deployment, monitoring, and whatnot. And still, the final product is in many ways, if not all, inferior to alternatives such as Medium, GitHub pages, or Blogger. Such solutions allow you to focus on your writing without worrying about anything else. Furthermore, they are surely more stable and battle-tested, offer better reliability and higher capacity.</p>
<p>
My implementation of the Erlangelist site lacks in all of these properties, being ridden with all the typical developer sins: NIH, over- and under- engineering, ad-hoc hacky shortcuts, home-grown patterns, wheel reinvention, poor testing, bash scripts (full confession: I love bash scripts), and many more. Also, hosting the blog on a single cheap VPS doesn’t really boost its availability.</p>
<p>
So, why did I do it then? Because I wanted to try out Phoenix and The Erlangelist was a good lab rat candidate. It’s a pretty simple service and it’s used in real life. Much to my surprise, people read these articles, and occasionally even mention some of them in their own posts. On the other hand, the blog receives only a few hundred views per day, so the site is really not highly loaded, nor super critical. Occasional shorter downtime shouldn’t cause much disturbance, and it might even go completely unnoticed.</p>
<p>
The challenge was thus manageable in the little extra time I was able to spare, and so far the system seems to be doing well. As an added bonus, now I’m able to see all the requests, something that was not possible on Blogger. One thing I immediately learned after switching to the new site is that people seem to use the RSS feed of the blog. I had no idea this was still a thing, and almost forgot to port the feed. Thanks to Janis Miezitis for providing <a href="http://codingwithaxe.com/how-to-write-rss-feed-in-phoenix/">nice RSS on Phoenix guide</a>.</p>
<h2>
The experience</h2>
<p>
I had a great time implementing this little site. The server code is fairly simple, and doesn’t really use a lot of Phoenix. The site boils down to hosting a few static pages, so there wasn’t much need for some fancy features such as channels. Regardless, I was quite impressed with what I’ve seen so far. It was pretty easy to get started, especially owing to <a href="http://www.phoenixframework.org/docs/overview">excellent online guides</a> by <a href="https://twitter.com/lance_halvorsen">Lance Halvorsen</a>.</p>
<p>
Working on the “devops” tasks related to producing and deploying the release was another interesting thing. This is where I spent most of the effort, but I’ve also learned a lot in the process.</p>
<p>
So altogether, the experience so far has been pretty nice, and I’m very excited that this blog is finally powered by the same technology it promotes :-)</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2015, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/opensourcing_erlangelist">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/opensourcing_erlangelist.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Sun, 1 Nov 2015 00:00:00 +0000</pubDate></item><item><title>Outside Elixir: running external programs with ports</title><link>http://theerlangelist.com//article/outside_elixir</link><description><![CDATA[<h1>Outside Elixir: running external programs with ports</h1>
<h4 class="right">2015-08-18</h4>

<div class="article-body">
<p>
Occasionally it might be beneficial to implement some part of the system in something other than Erlang/Elixir. I see at least two reasons for doing this. First, it might happen that a library for some particular functionality is not available, or not as mature as its counterparts in other languages, and creating a proper Elixir implementation might require a lot of effort. Another reason could be raw CPU speed, something which is not Erlang’s forte, although in my personal experience that rarely matters. Still, if there are strong speed requirement in some CPU intensive part of the system, and every microsecond is important, Erlang might not suffice.</p>
<p>
There may exist some other situations where Erlang is possibly not the best tool for the job. Still, that’s not necessarily the reason to dismiss it completely. Just because it’s not suitable for some features, doesn’t mean it’s not a good choice to power most of the system. Moreover, even if you stick with Erlang you still can resort to other languages to implement some parts of it. Erlang provides a couple of techniques to do this, but in my personal opinion the most compelling option is to start external programs from Erlang via <a href="http://erlang.org/doc/reference_manual/ports.html">ports</a>. This is the approach I’d consider first, and then turn to other alternatives in some special cases. So in this article, I’ll talk about ports but before parting, I’ll briefly mention other options and discuss some trade-offs.</p>
<h2>
Basic theory</h2>
<p>
An Erlang port is a process-specific resource. It is owned by some process and that process is the only one that can talk to it. If the owner process terminates, the port will be closed. You can create many ports in the system, and a single process can own multiple ports. It’s worth mentioning that a process can hand over the ownership of the port to another process.</p>
<p>
An examples of ports are file handles and network sockets which are connected to the owner process and closed if that process terminates. This allows proper cleanup in an well structured OTP application. Whenever you take down some part of the supervision tree, all resources owned by terminated processes will be closed.</p>
<p>
From the implementation standpoint, ports come in two flavors. They can either be powered by a code which runs directly in the VM itself (port driver), or they can run as an external OS process outside of the BEAM. Either way, the principles above hold and you use mostly the same set of functions exposed in the <a href="https://hexdocs.pm/elixir/Port.html">Port module</a> - tiny wrappers around port related functions from the <code class="inline">:erlang</code> module. In this article I’ll focus on ports as external processes. While not the fastest option, I believe this is often a sensible approach because it preserves fault-tolerance properties.</p>
<p>
Before starting, I should also mention the <a href="https://github.com/alco/porcelain">Porcelain</a> library, by Alexei Sholik, which can simplify working with ports in some cases. You should definitely check it out, but in this article I will just use the <code class="inline">Port</code> module to avoid the extra layer of abstraction.</p>
<h2>
First take</h2>
<p>
Let’s see a simple example. In this exercise we’ll introduce the support for running Ruby code from the Erlang VM. Under the scene, we’ll start a Ruby process from Erlang and send it Ruby commands. The process will eval those commands and optionally send back responses to Erlang. We’ll also make the Ruby interpreter stateful, allowing Ruby commands to share the same state. Of course, it will be possible to start multiple Ruby instances and achieve isolation as well.</p>
<p>
The initial take is simple. To run an external program via port, you need to open a port via <code class="inline">Port.open/2</code>, providing a command to start the external program. Then you can use <code class="inline">Port.command/2</code> to issue requests to the program. If the program sends something back, the owner process will receive a message. This is pretty resemblant to the classic message passing approach.</p>
<p>
On the other side, the external program uses standard input/output to talk to its owner process. Basically, it needs to read from stdin, decode the input, do its stuff, and optionally print the response on stdout which will result in a message back to the Erlang process. When the program detects EOF on stdin, it can assume that the owner process has closed the port.</p>
<p>
Let’s see this in action. First, we’ll define the command to start the external program, in this case a Ruby interpreter:</p>
<pre><code class="highlight makeup elixir"><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">~S&quot;&quot;&quot;
  ruby -e &#39;
    STDOUT.sync = true
    context = binding

    while (cmd = gets) do
      eval(cmd, context)
    end
  &#39;
&quot;&quot;&quot;</span></code></pre>
<p>
This is a simple program that reads lines from stdin and evals them in the same context, thus ensuring that the side effect of the previous commands is visible to the current one. The <code class="inline">STDOUT.sync = true</code> bit ensures that whatever we output is immediately flushed, and thus sent back to the owner Erlang process.</p>
<p>
Now we can start the port:</p>
<pre><code class="highlight makeup elixir"><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Port</span><span class="o">.</span><span class="n">open</span><span class="p" data-group-id="7319468024-1">(</span><span class="p" data-group-id="7319468024-2">{</span><span class="ss">:spawn</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p" data-group-id="7319468024-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7319468024-3">[</span><span class="ss">:binary</span><span class="p" data-group-id="7319468024-3">]</span><span class="p" data-group-id="7319468024-1">)</span></code></pre>
<p>
The second argument contains port options. For now, we’ll just provide the <code class="inline">:binary</code> option to specify that we want to receive data from the external program as binaries. We’ll use a couple of more options later on, but you’re advised to read the <a href="http://www.erlang.org/doc/man/erlang.html#open_port-2">official documentation</a> to learn about all the available options.</p>
<p>
Assuming you have a Ruby interpreter somewhere in the path, the code above should start a corresponding OS process, and you can now use <code class="inline">Port.command/2</code> to talk to it:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Port</span><span class="o">.</span><span class="n">command</span><span class="p" data-group-id="5792747933-1">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a = 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p" data-group-id="5792747933-1">)</span><span class="w">
</span><span class="nc">Port</span><span class="o">.</span><span class="n">command</span><span class="p" data-group-id="5792747933-2">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a += 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p" data-group-id="5792747933-2">)</span><span class="w">
</span><span class="nc">Port</span><span class="o">.</span><span class="n">command</span><span class="p" data-group-id="5792747933-3">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;puts a</span><span class="se">\n</span><span class="s">&quot;</span><span class="p" data-group-id="5792747933-3">)</span></code></pre>
<p>
This is fairly straightforward. We just send some messages to the port, inserting newlines to make sure the other side gets them (since it uses <code class="inline">gets</code> to read line by line). The Ruby program will eval these expressions (since we’ve written it that way). In the very last expression, we print the contents of the variable. This last statement will result in a message to the owner process. We can <code class="inline">receive</code> this message as usual:</p>
<pre><code class="highlight makeup elixir"><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="6409999455-1">do</span><span class="w">
  </span><span class="p" data-group-id="6409999455-2">{</span><span class="o">^</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6409999455-3">{</span><span class="ss">:data</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="6409999455-3">}</span><span class="p" data-group-id="6409999455-2">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="6409999455-4">(</span><span class="s">&quot;Elixir got: </span><span class="si" data-group-id="6409999455-5">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="6409999455-5">}</span><span class="s">&quot;</span><span class="p" data-group-id="6409999455-4">)</span><span class="w">
</span><span class="k" data-group-id="6409999455-1">end</span><span class="w">

</span><span class="c1"># Elixir got: &quot;3\n&quot;</span></code></pre>
<p>
The full code is available <a href="https://gist.github.com/sasa1977/36c91befb96412e244c6">here</a>.</p>
<h2>
Program termination</h2>
<p>
It’s worth noting again, that a port is closed when the owner process terminates. In addition, the owner process can close the port explicitly with <code class="inline">Port.close/1</code>. When a port is closed the external program is not automatically terminated, but pipes used for communication will be closed. When the external program reads from stdin it will get EOF and can do something about it, for example terminate.</p>
<p>
This is what we already do in our Ruby program:</p>
<pre><code class="ruby">while (cmd = gets) do
  eval(cmd, context)
end</code></pre>
<p>
By stopping the loop when <code class="inline">gets</code> returns nil we ensure that the program will terminate when the port is closed.</p>
<p>
There are a few caveats though. Notice how we eval inside the loop. If the code in <code class="inline">cmd</code> takes a long time to run, the external program might linger after the port is closed. This is simply due to the fact that the program is busy processing the current request, so it can’t detect that the other side has closed the port. If you want to ensure immediate termination, you can consider doing processing in a separate thread, while keeping the main thread focused on the communication part.</p>
<p>
Another issue is the fact that closing the port closes both pipes. This may present a problem if you want to directly use tools which produce their output only after they receive EOF. In the context of port, when this happens, both pipes are already closed, so the tool can’t send anything back via stdout. There are quite a few discussion on this issue (see <a href="http://erlang.org/pipermail/erlang-questions/2013-July/074905.html">here</a> for example). Essentially, you shouldn’t worry about it if you implement your program to act as a server which waits for requests, does some processing, and optionally spits out the result. However, if you’re trying to reuse a program which is not originally written to run as a port, you may need to wrap it in some custom script, or resort to libraries which offer some workarounds, such as the aforementioned Porcelain.</p>
<h2>
Packing messages</h2>
<p>
The communication between the owner process and the port is by default streamed, which means there are no guarantees about message chunks, so you need to somehow parse messages yourself, character by character.</p>
<p>
In the previous example the Ruby code relies on newlines to serve as command separators (by using <code class="inline">gets</code>). This is a quick solution, but it prevents us from running multiline commands. Moreover, when receiving messages in Elixir, we don’t have any guarantees about chunking. Data is streamed back to us as it is printed, so a single message might contain multiple responses, or a single response might span multiple messages.</p>
<p>
A simple solution for this is to include the information about the message size in the message itself. This can be done by providing the <code class="inline">{:packet, n}</code> option to <code class="inline">Port.open/2</code>:</p>
<pre><code class="highlight makeup elixir"><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Port</span><span class="o">.</span><span class="n">open</span><span class="p" data-group-id="3313882681-1">(</span><span class="p" data-group-id="3313882681-2">{</span><span class="ss">:spawn</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p" data-group-id="3313882681-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3313882681-3">[</span><span class="ss">:binary</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3313882681-4">{</span><span class="ss">:packet</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="3313882681-4">}</span><span class="p" data-group-id="3313882681-3">]</span><span class="p" data-group-id="3313882681-1">)</span></code></pre>
<p>
Each message sent to the port will start with <code class="inline">n</code> bytes (in this example 4) which represent the byte size of the rest of the message. The size is encoded as an unsigned big-endian integer.</p>
<p>
The external program then needs to read this 4 bytes integer, and then get the corresponding number of bytes to obtain the message payload:</p>
<pre><code class="ruby">def receive_input
  encoded_length = STDIN.read(4)                # get message size
  return nil unless encoded_length

  length = encoded_length.unpack(&quot;N&quot;).first     # convert to int
  STDIN.read(length)                            # read message
end</code></pre>
<p>
Now we can use <code class="inline">receive_input</code> in the eval loop:</p>
<pre><code class="ruby">while (cmd = receive_input) do
  eval(cmd, context)
end</code></pre>
<p>
These changes allow the Elixir client to send multi-line statements:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Port</span><span class="o">.</span><span class="n">command</span><span class="p" data-group-id="2921416300-1">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a = 1&quot;</span><span class="p" data-group-id="2921416300-1">)</span><span class="w">
</span><span class="nc">Port</span><span class="o">.</span><span class="n">command</span><span class="p" data-group-id="2921416300-2">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">~S&quot;&quot;&quot;
  while a &lt; 10 do
    a *= 3
  end
&quot;&quot;&quot;</span><span class="p" data-group-id="2921416300-2">)</span></code></pre>
<p>
When the Ruby program needs to send a message back to Erlang, it must also include the size of the message:</p>
<pre><code class="ruby">def send_response(value)
  response = value.inspect
  STDOUT.write([response.bytesize].pack(&quot;N&quot;))
  STDOUT.write(response)
  true
end</code></pre>
<p>
Elixir code can then use <code class="inline">send_response</code> to make the Ruby code return something. To prove that responses are properly chunked, let’s send two responses:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Port</span><span class="o">.</span><span class="n">command</span><span class="p" data-group-id="3547356702-1">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">~S&quot;&quot;&quot;
  send_response(&quot;response&quot;)
  send_response(a)
&quot;&quot;&quot;</span><span class="p" data-group-id="3547356702-1">)</span></code></pre>
<p>
Which will result in two messages on the Elixir side:</p>
<pre><code class="highlight makeup elixir"><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="8547968786-1">do</span><span class="w">
  </span><span class="p" data-group-id="8547968786-2">{</span><span class="o">^</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8547968786-3">{</span><span class="ss">:data</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="8547968786-3">}</span><span class="p" data-group-id="8547968786-2">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="8547968786-4">(</span><span class="s">&quot;Elixir got: </span><span class="si" data-group-id="8547968786-5">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="8547968786-5">}</span><span class="s">&quot;</span><span class="p" data-group-id="8547968786-4">)</span><span class="w">
</span><span class="k" data-group-id="8547968786-1">end</span><span class="w">

</span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="8547968786-6">do</span><span class="w">
  </span><span class="p" data-group-id="8547968786-7">{</span><span class="o">^</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8547968786-8">{</span><span class="ss">:data</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="8547968786-8">}</span><span class="p" data-group-id="8547968786-7">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="8547968786-9">(</span><span class="s">&quot;Elixir got: </span><span class="si" data-group-id="8547968786-10">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="8547968786-10">}</span><span class="s">&quot;</span><span class="p" data-group-id="8547968786-9">)</span><span class="w">
</span><span class="k" data-group-id="8547968786-6">end</span><span class="w">

</span><span class="c1"># Elixir got: &quot;\&quot;response\&quot;&quot;</span><span class="w">
</span><span class="c1"># Elixir got: &quot;27&quot;</span></code></pre>
<p>
The complete code is available <a href="https://gist.github.com/sasa1977/9c43d54f6065ecaea992">here</a>.</p>
<h2>
Encoding/decoding messages</h2>
<p>
The examples so far use plain string as messages. In more involved scenarios you may need to deal with various data types. There’s no special support for this. Essentially a process and a port exchange byte sequences, and it is up to you to implement some encoding/decoding scheme to facilitate data typing. You can resort to popular formats such as JSON for this purpose.</p>
<p>
In this example, I’ll use <a href="http://erlang.org/doc/apps/erts/erl_ext_dist.html">Erlang’s External Term Format (ETF)</a>. You can easily encode/decode any Erlang term to ETF via <code class="inline">:erlang.term_to_binary/1</code> and <code class="inline">:erlang.binary_to_term/1</code>. A nice benefit of this is that you don’t need any third party library on the Elixir side.</p>
<p>
Let’s see this in action. Instead of plain strings, we’ll send <code class="inline">{:eval, command}</code> tuples to the Ruby side. The Ruby program will execute the command only if it receives <code class="inline">:eval</code> tagged tuple. In addition, when responding back, we’ll again send the message as tuple in form of <code class="inline">{:response, value}</code>, where value will also be an Erlang term.</p>
<p>
On the Elixir side we’ll introduce a helper lambda to send <code class="inline">{:eval, command}</code> tuples to the port. It will simply pack the command into a tuple and encode it to ETF binary:</p>
<pre><code class="highlight makeup elixir"><span class="n">send_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="4099196364-1">fn</span><span class="p" data-group-id="4099196364-2">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">command</span><span class="p" data-group-id="4099196364-2">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="nc">Port</span><span class="o">.</span><span class="n">command</span><span class="p" data-group-id="4099196364-3">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="ss">:erlang</span><span class="o">.</span><span class="n">term_to_binary</span><span class="p" data-group-id="4099196364-4">(</span><span class="p" data-group-id="4099196364-5">{</span><span class="ss">:eval</span><span class="p">,</span><span class="w"> </span><span class="n">command</span><span class="p" data-group-id="4099196364-5">}</span><span class="p" data-group-id="4099196364-4">)</span><span class="p" data-group-id="4099196364-3">)</span><span class="w">
</span><span class="k" data-group-id="4099196364-1">end</span></code></pre>
<p>
The function can then be used as:</p>
<pre><code class="highlight makeup elixir"><span class="n">send_eval</span><span class="o">.</span><span class="p" data-group-id="8303725785-1">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a = 1&quot;</span><span class="p" data-group-id="8303725785-1">)</span><span class="w">
</span><span class="n">send_eval</span><span class="o">.</span><span class="p" data-group-id="8303725785-2">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">~S&quot;&quot;&quot;
  while a &lt; 10 do
    a *= 3
  end
&quot;&quot;&quot;</span><span class="p" data-group-id="8303725785-2">)</span><span class="w">
</span><span class="n">send_eval</span><span class="o">.</span><span class="p" data-group-id="8303725785-3">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;send_response(a)&quot;</span><span class="p" data-group-id="8303725785-3">)</span></code></pre>
<p>
On the Ruby side, we need to decode ETF byte sequence. For this, we need to resort to some 3rd party library. After a quick (and very shallow) research, I opted for <a href="https://github.com/potatosalad/erlang-etf">erlang-etf</a>. We need to create a <code class="inline">Gemfile</code> with the following content:</p>
<pre><code class="ruby">source &quot;https://rubygems.org&quot;

gem &#39;erlang-etf&#39;</code></pre>
<p>
And then run <code class="inline">bundle install</code> to fetch gems.</p>
<p>
Now, in our Ruby code, we can require necessary gems:</p>
<pre><code class="ruby">require &quot;bundler&quot;
require &quot;erlang/etf&quot;
require &quot;stringio&quot;</code></pre>
<p>
Then, we can modify the <code class="inline">read_input</code> function to decode the byte sequence:</p>
<pre><code class="ruby">def receive_input
  # ...

  Erlang.binary_to_term(STDIN.read(length))
end</code></pre>
<p>
The eval loop now needs to check that the input message is a tuple and that it contains the <code class="inline">:eval</code> atom as the first element:</p>
<pre><code class="ruby">while (cmd = receive_input) do
  if cmd.is_a?(Erlang::Tuple) &amp;&amp; cmd[0] == :eval
    eval(cmd[1], context)
  end
end</code></pre>
<p>
Then we need to adapt the <code class="inline">send_response</code> function to encode the response message as <code class="inline">{:response, value}</code>:</p>
<pre><code class="ruby">def send_response(value)
  response = Erlang.term_to_binary(Erlang::Tuple[:response, value])
  # ...
end</code></pre>
<p>
Going back to the Elixir side, we now need to decode the response message with <code class="inline">:erlang.binary_to_term/1</code>:</p>
<pre><code class="highlight makeup elixir"><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="5251307307-1">do</span><span class="w">
  </span><span class="p" data-group-id="5251307307-2">{</span><span class="o">^</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5251307307-3">{</span><span class="ss">:data</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="5251307307-3">}</span><span class="p" data-group-id="5251307307-2">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="5251307307-4">(</span><span class="s">&quot;Elixir got: </span><span class="si" data-group-id="5251307307-5">#{</span><span class="n">inspect</span><span class="w"> </span><span class="ss">:erlang</span><span class="o">.</span><span class="n">binary_to_term</span><span class="p" data-group-id="5251307307-6">(</span><span class="n">result</span><span class="p" data-group-id="5251307307-6">)</span><span class="si" data-group-id="5251307307-5">}</span><span class="s">&quot;</span><span class="p" data-group-id="5251307307-4">)</span><span class="w">
</span><span class="k" data-group-id="5251307307-1">end</span><span class="w">

</span><span class="c1"># Elixir got: {:response, 27}</span></code></pre>
<p>
Take special note how the received value is now an integer (previously it was a string). This happens because the response is now encoded to ETF on the Ruby side.</p>
<p>
The complete code is available <a href="https://gist.github.com/sasa1977/c03f3b86382d19ef4ec3">here</a>.</p>
<h2>
Bypassing stdio</h2>
<p>
Communication via stdio is somewhat unfortunate. If in the external program we want to print something, perhaps for debugging purposes, the output will just be sent back to Erlang. Luckily, this can be avoided by instructing Erlang to use file descriptors 3 and 4 for communication with the program. Possible caveat: I’m not sure if this feature will work on Windows.</p>
<p>
The change is simple enough. We need to provide the <code class="inline">:nouse_stdio</code> option to <code class="inline">Port.open/2</code>:</p>
<pre><code class="highlight makeup elixir"><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Port</span><span class="o">.</span><span class="n">open</span><span class="p" data-group-id="7053060991-1">(</span><span class="p" data-group-id="7053060991-2">{</span><span class="ss">:spawn</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p" data-group-id="7053060991-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7053060991-3">[</span><span class="ss">:binary</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7053060991-4">{</span><span class="ss">:packet</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="7053060991-4">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:nouse_stdio</span><span class="p" data-group-id="7053060991-3">]</span><span class="p" data-group-id="7053060991-1">)</span></code></pre>
<p>
Then, in Ruby, we need to open files 3 and 4, making sure that the output file is not buffered:</p>
<pre><code class="ruby">@input = IO.new(3)
@output = IO.new(4)
@output.sync = true</code></pre>
<p>
Finally, we can simply replace references to <code class="inline">STDIN</code> and <code class="inline">STDOUT</code> with <code class="inline">@input</code> and <code class="inline">@output</code> respectively. The code is omitted for the sake of brevity.</p>
<p>
After these changes, we can print debug messages from the Ruby process:</p>
<pre><code class="ruby">while (cmd = receive_input) do
  if cmd.is_a?(Erlang::Tuple) &amp;&amp; cmd[0] == :eval
    puts &quot;Ruby: #{cmd[1]}&quot;
    res = eval(cmd[1], context)
    puts &quot;Ruby: =&gt; #{res.inspect}\n\n&quot;
  end
end

puts &quot;Ruby: exiting&quot;</code></pre>
<p>
Which gives the output:</p>
<pre><code class="highlight makeup elixir"><span class="ss">Ruby</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="ss">Ruby</span><span class="p">:</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">

</span><span class="ss">Ruby</span><span class="p">:</span><span class="w">   </span><span class="n">while</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k" data-group-id="7376119890-1">do</span><span class="w">
    </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w">
  </span><span class="k" data-group-id="7376119890-1">end</span><span class="w">
</span><span class="ss">Ruby</span><span class="p">:</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="no">nil</span><span class="w">

</span><span class="ss">Ruby</span><span class="p">:</span><span class="w"> </span><span class="n">send_response</span><span class="p" data-group-id="7376119890-2">(</span><span class="n">a</span><span class="p" data-group-id="7376119890-2">)</span><span class="w">
</span><span class="ss">Ruby</span><span class="p">:</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">

</span><span class="nc">Elixir</span><span class="w"> </span><span class="ss">got</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7376119890-3">{</span><span class="ss">:response</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p" data-group-id="7376119890-3">}</span><span class="w">
</span><span class="ss">Ruby</span><span class="p">:</span><span class="w"> </span><span class="n">exiting</span></code></pre>
<p>
The code is available <a href="https://gist.github.com/sasa1977/d862a8107071651b34d0">here</a>.</p>
<h2>
Wrapping the port in a server process</h2>
<p>
Since the communication with the port relies heavily on message passing, it’s worth managing the port inside a <code class="inline">GenServer</code>. This gives us some nice benefits:</p>
<ul>
  <li>
The server process can provide an abstract API to its clients. For example, we could expose <code class="inline">RubyServer.cast</code> and <code class="inline">RubyServer.call</code>. The first operation just issues a command without producing the output. The second one will instruct Ruby program to invoke <code class="inline">send_response</code> and send the response back. In addition, the server process will handle the response message by notifying the client process. The coupling between Erlang and the program remains in the code of the server process.  </li>
  <li>
The server process can include additional unique id in each request issued to the port. Ruby program will include this id in the response message, so the server can reliably match the response to a particular client request.  </li>
  <li>
The server process can be notified if the Ruby program crashes, and in turn crash itself.  </li>
</ul>
<p>
Let’s see an example usage of such server:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="1481643762-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">server</span><span class="p" data-group-id="1481643762-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RubyServer</span><span class="o">.</span><span class="n">start_link</span><span class="w">

</span><span class="nc">RubyServer</span><span class="o">.</span><span class="n">cast</span><span class="p" data-group-id="1481643762-2">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a = 1&quot;</span><span class="p" data-group-id="1481643762-2">)</span><span class="w">
</span><span class="nc">RubyServer</span><span class="o">.</span><span class="n">cast</span><span class="p" data-group-id="1481643762-3">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="s">~S&quot;&quot;&quot;
  while a &lt; 10 do
    a *= 3
  end
&quot;&quot;&quot;</span><span class="p" data-group-id="1481643762-3">)</span><span class="w">

</span><span class="nc">RubyServer</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="1481643762-4">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Erlang::Tuple[:response, a]&quot;</span><span class="p" data-group-id="1481643762-4">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="w">

</span><span class="c1"># {:response, 27}</span></code></pre>
<p>
Of course, nothing stops you from creating another Ruby interpreter:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="2217070764-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">another_server</span><span class="p" data-group-id="2217070764-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RubyServer</span><span class="o">.</span><span class="n">start_link</span><span class="w">
</span><span class="nc">RubyServer</span><span class="o">.</span><span class="n">cast</span><span class="p" data-group-id="2217070764-2">(</span><span class="n">another_server</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a = 42&quot;</span><span class="p" data-group-id="2217070764-2">)</span><span class="w">
</span><span class="nc">RubyServer</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="2217070764-3">(</span><span class="n">another_server</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Erlang::Tuple[:response, a]&quot;</span><span class="p" data-group-id="2217070764-3">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="w">

</span><span class="c1"># {:response, 42}</span></code></pre>
<p>
These two servers communicate with different interpreter instances so there’s no overlap:</p>
<pre><code class="highlight makeup elixir"><span class="nc">RubyServer</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="5775952772-1">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Erlang::Tuple[:response, a]&quot;</span><span class="p" data-group-id="5775952772-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="w">

</span><span class="c1"># {:response, 27}</span></code></pre>
<p>
Finally, a crash in the Ruby program will be noticed by the <code class="inline">GenServer</code> which will in turn crash itself:</p>
<pre><code class="highlight makeup elixir"><span class="nc">RubyServer</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="8094844496-1">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1/0&quot;</span><span class="p" data-group-id="8094844496-1">)</span><span class="w">

</span><span class="c1"># ** (EXIT from #PID&lt;0.48.0&gt;) an exception was raised:</span><span class="w">
</span><span class="c1">#     ** (ErlangError) erlang error: {:port_exit, 1}</span><span class="w">
</span><span class="c1">#         ruby_server.ex:43: RubyServer.handle_info/2</span><span class="w">
</span><span class="c1">#         (stdlib) gen_server.erl:593: :gen_server.try_dispatch/4</span><span class="w">
</span><span class="c1">#         (stdlib) gen_server.erl:659: :gen_server.handle_msg/5</span><span class="w">
</span><span class="c1">#         (stdlib) proc_lib.erl:237: :proc_lib.init_p_do_apply/3</span></code></pre>
<p>
The implementation is mostly a rehash of the previously mentioned techniques, so I won’t explain it here. The only new thing is providing of the <code class="inline">:exit_status</code> option to <code class="inline">Port.open/2</code>. With this option, we ensure that the owner process will receive the <code class="inline">{port, {:exit_status, status}}</code> message, and do something about the port crash. You’re advised to try and implement such <code class="inline">GenServer</code> yourself, or analyze <a href="https://gist.github.com/sasa1977/3bf1753675a77f18805a">my basic solution</a>.</p>
<h2>
Alternatives to ports</h2>
<p>
Like everything else, ports come with some associated trade-offs. The most obvious one is the performance hit due to encoding and communicating via pipes. If the actual processing in the port is very short, this overhead might not be tolerable. With a lot of hand waving I’d say that ports are more appropriate when the external program will do some “significant” amount of work, something that’s measured at least in milliseconds.</p>
<p>
In addition, ports are coupled to the owner (and vice-versa). If the owner stops, you probably want to stop the external program. Otherwise the restarted owner will start another instance of the program, while the previous instance won’t be able to talk to Erlang anymore.</p>
<p>
If these issues are relevant for your specific case, you might consider some alternatives:</p>
<ul>
  <li>
<a href="http://www.erlang.org/doc/man/erl_driver.html">Port drivers</a> (sometimes called linked-in drivers) have characteristics similar to ports, but there is no external program involved. Instead, the code, implemented in C/C++, is running directly in the VM.  </li>
  <li>
<a href="http://www.erlang.org/doc/man/erl_nif.html">NIFs</a> (native implemented functions) can be used to implement Erlang functions in C and run them inside the BEAM. Unlike port drivers, NIFs are not tied to a particular process.  </li>
  <li>
It is also possible to make your program look like an Erlang node. Some helper libraries are provided for <a href="http://www.erlang.org/doc/tutorial/overview.html#id60360">C and Java</a>. Your Erlang node can then communicate with the program, just like it would do with any other node in the cluster.  </li>
  <li>
Of course, you can always go the “microservices” style: start a separate program, and expose some HTTP interface so your Erlang system can talk to it.  </li>
</ul>
<p>
The first two alternatives might give you significant speed improvement at the cost of safety. An unhandled exception in a NIF or port driver will crash the entire BEAM. Moreover, both NIFs and port-drivers are running in scheduler threads, so you need to keep your computations short (&lt;= 1ms), otherwise you may end up compromising the scheduler. This can be worked around with threads and usage of dirty schedulers, but the implementation might be significantly more involved.</p>
<p>
The third option provides looser coupling between two parties, allowing them to restart separately. Since distributed Erlang is used, you should still be able to detect crashes of the other side.</p>
<p>
A custom HTTP interface is more general than an Erlang-like node (since it doesn’t require an Erlang client), but you lose the ability to detect crashes. If one party needs to detect that the other party has crashed, you’ll need to roll your own health checking (or reuse some 3rd party component for that).</p>
<p>
I’d say that nodes and separate services seem suitable when two parties are more like peers, and each one can exist without the other. On the other hand, ports are more interesting when the external program makes sense only in the context of the whole system, and should be taken down if some other part of the system terminates.</p>
<p>
As you can see, there are various options available, so I think it’s safe to say that Erlang is not an island. Moving to Erlang/Elixir doesn’t mean you lose the ability to implement some parts of the system in other languages. So if for whatever reasons you decide that something else is more suitable to power a particular feature, you can definitely take that road and still enjoy the benefits of Erlang/Elixir in the rest of your system.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2015, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/outside_elixir">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/outside_elixir.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate></item><item><title>Optimizing a function with the help of Elixir macros</title><link>http://theerlangelist.com//article/tallakt_macros</link><description><![CDATA[<h1>Optimizing a function with the help of Elixir macros</h1>
<h4 class="right">2015-08-06</h4>

<div class="article-body">
<h2>
Author: Tallak Tveide</h2>
<p>
<em>Today I have a pleasure of hosting a post by <a href="https://twitter.com/tallakt">Tallak Tveide</a>, who dived into Elixir macros, came back alive, and decided to share his experience with us. This is his story.</em></p>
<p>
In this blog post we will cover optimizing an existing function for certain known inputs, using macros. The function that we are going to optimize is 2D matrix rotation. The problem was chosen for it’s simplicity. When I first used these techniques there were a few extra complexities that have been left out, please keep this in mind if the code seems like overkill.</p>
<p>
If you are unfamiliar with macros, this blog post may be difficult to read. In that case one tip is to read <a href="macros_1">Saša Jurić’s articles about Elixir macros</a> first, then revisit this post.</p>
<h2>
Two dimensional vector rotation</h2>
<p>
We want to take a vector <code class="inline">{x, y}</code> and apply any number of translate and rotate transforms on it. We want to end up with code looking like:</p>
<pre><code class="highlight makeup elixir"><span class="n">transformed_point</span><span class="w"> </span><span class="o">=</span><span class="w">
  </span><span class="p" data-group-id="9603129416-1">{</span><span class="mf">10.0</span><span class="p">,</span><span class="w"> </span><span class="mf">10.0</span><span class="p" data-group-id="9603129416-1">}</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">rotate</span><span class="p" data-group-id="9603129416-2">(</span><span class="mf">90.0</span><span class="p" data-group-id="9603129416-2">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">translate</span><span class="p" data-group-id="9603129416-3">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p" data-group-id="9603129416-3">)</span></code></pre>
<p>
The <code class="inline">translate</code> function would simply look something like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD</span><span class="w"> </span><span class="k" data-group-id="2471182576-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">translate</span><span class="p" data-group-id="2471182576-2">(</span><span class="p" data-group-id="2471182576-3">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="2471182576-3">}</span><span class="p">,</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">dy</span><span class="p" data-group-id="2471182576-2">)</span><span class="w"> </span><span class="k" data-group-id="2471182576-4">do</span><span class="w">
    </span><span class="p" data-group-id="2471182576-5">{</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy</span><span class="p" data-group-id="2471182576-5">}</span><span class="w">
  </span><span class="k" data-group-id="2471182576-4">end</span><span class="w">
</span><span class="k" data-group-id="2471182576-1">end</span></code></pre>
<p>
And then the <code class="inline">rotate</code> function might look like:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD</span><span class="w"> </span><span class="k" data-group-id="8875689711-1">do</span><span class="w">
  </span><span class="na">@deg_to_rad</span><span class="w"> </span><span class="mf">180.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">pi</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="8875689711-2">(</span><span class="p" data-group-id="8875689711-3">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="8875689711-3">}</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="8875689711-2">)</span><span class="w"> </span><span class="k" data-group-id="8875689711-4">do</span><span class="w">
    </span><span class="n">radians</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="na">@deg_to_rad</span><span class="w">
    </span><span class="p" data-group-id="8875689711-5">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="8875689711-6">(</span><span class="n">radians</span><span class="p" data-group-id="8875689711-6">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="8875689711-7">(</span><span class="n">radians</span><span class="p" data-group-id="8875689711-7">)</span><span class="p">,</span><span class="w">
      </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="8875689711-8">(</span><span class="n">radians</span><span class="p" data-group-id="8875689711-8">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="8875689711-9">(</span><span class="n">radians</span><span class="p" data-group-id="8875689711-9">)</span><span class="w"> </span><span class="p" data-group-id="8875689711-5">}</span><span class="w">
  </span><span class="k" data-group-id="8875689711-4">end</span><span class="w">
</span><span class="k" data-group-id="8875689711-1">end</span></code></pre>
<p>
The first subtle macro magic is already happening at this point. We are precalculating the module attribute <code class="inline">@deg_to_rad</code> at compile time to avoid calling <code class="inline">:math.pi</code> and performing a division at runtime.</p>
<p>
I have left out <code class="inline">translate</code> from here on for clarity.</p>
<h2>
The idea</h2>
<p>
When I first started to look at these transforms, most of my rotations were in multiples of 90 degrees. For these operations, <code class="inline">:math.sin(x)</code> and <code class="inline">math.cos(x)</code> will return the values <code class="inline">-1.0</code>, <code class="inline">0.0</code> or <code class="inline">1.0</code>, and the rotate function is reduced to reordering and changing signs of the vector tuple values in <code class="inline">{x, y}</code>.</p>
<p>
If we spelled the code out, it would look something like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD</span><span class="w"> </span><span class="k" data-group-id="4713768295-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="4713768295-2">(</span><span class="p" data-group-id="4713768295-3">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="4713768295-3">}</span><span class="p">,</span><span class="w"> </span><span class="mf">90.0</span><span class="p" data-group-id="4713768295-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4713768295-4">{</span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="4713768295-4">}</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="4713768295-5">(</span><span class="p" data-group-id="4713768295-6">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="4713768295-6">}</span><span class="p">,</span><span class="w"> </span><span class="mf">180.0</span><span class="p" data-group-id="4713768295-5">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4713768295-7">{</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">y</span><span class="p" data-group-id="4713768295-7">}</span><span class="w">
  </span><span class="c1"># ... more optimized versions here</span><span class="w">

  </span><span class="c1"># failing an optimized match, use the generic rotate</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="4713768295-8">(</span><span class="p" data-group-id="4713768295-9">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="4713768295-9">}</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="4713768295-8">)</span><span class="w"> </span><span class="k" data-group-id="4713768295-10">do</span><span class="w">
    </span><span class="n">radians</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="na">@deg_to_rad</span><span class="w">
    </span><span class="p" data-group-id="4713768295-11">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="4713768295-12">(</span><span class="n">radians</span><span class="p" data-group-id="4713768295-12">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="4713768295-13">(</span><span class="n">radians</span><span class="p" data-group-id="4713768295-13">)</span><span class="p">,</span><span class="w">
      </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="4713768295-14">(</span><span class="n">radians</span><span class="p" data-group-id="4713768295-14">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="4713768295-15">(</span><span class="n">radians</span><span class="p" data-group-id="4713768295-15">)</span><span class="w"> </span><span class="p" data-group-id="4713768295-11">}</span><span class="w">
  </span><span class="k" data-group-id="4713768295-10">end</span><span class="w">
</span><span class="k" data-group-id="4713768295-1">end</span></code></pre>
<p>
For this particular problem, the code above, without macros, is most readable, maintainable and is also as efficient as any other code.</p>
<h2>
The first attempt</h2>
<p>
There are basically just four variants at <code class="inline">[0, 90, 180, 270]</code> degrees that are interesting to us as <code class="inline">sin</code> and <code class="inline">cos</code> are cyclic. Our initial approach will select one of these four variants based on a parameter, and then inject some code into the <code class="inline">TwoD</code> module:</p>
<pre><code class="highlight makeup elixir"><span class="w">  </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="w"> </span><span class="k" data-group-id="8768234600-1">do</span><span class="w">
    </span><span class="na">@deg_to_rad</span><span class="w"> </span><span class="mf">180.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">pi</span><span class="w">

    </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="8768234600-2">(</span><span class="p" data-group-id="8768234600-3">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="8768234600-3">}</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="8768234600-2">)</span><span class="w"> </span><span class="k" data-group-id="8768234600-4">do</span><span class="w">
      </span><span class="n">radians</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="na">@deg_to_rad</span><span class="w">
      </span><span class="p" data-group-id="8768234600-5">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="8768234600-6">(</span><span class="n">radians</span><span class="p" data-group-id="8768234600-6">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="8768234600-7">(</span><span class="n">radians</span><span class="p" data-group-id="8768234600-7">)</span><span class="p">,</span><span class="w">
        </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="8768234600-8">(</span><span class="n">radians</span><span class="p" data-group-id="8768234600-8">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="8768234600-9">(</span><span class="n">radians</span><span class="p" data-group-id="8768234600-9">)</span><span class="w"> </span><span class="p" data-group-id="8768234600-5">}</span><span class="w">
    </span><span class="k" data-group-id="8768234600-4">end</span><span class="w">

    </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">def_optimized_rotate</span><span class="p" data-group-id="8768234600-10">(</span><span class="n">angle_quoted</span><span class="p" data-group-id="8768234600-10">)</span><span class="w"> </span><span class="k" data-group-id="8768234600-11">do</span><span class="w">
      </span><span class="c1"># angle is still code, so it must be evaluated to get a number</span><span class="w">
      </span><span class="p" data-group-id="8768234600-12">{</span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="8768234600-12">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="8768234600-13">(</span><span class="n">angle_quoted</span><span class="p" data-group-id="8768234600-13">)</span><span class="w">

      </span><span class="n">x_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="8768234600-14">(</span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="8768234600-14">)</span><span class="w">
      </span><span class="n">y_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="8768234600-15">(</span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="8768234600-15">)</span><span class="w">
      </span><span class="n">neg_x_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8768234600-16">(</span><span class="o">-</span><span class="k">unquote</span><span class="p" data-group-id="8768234600-17">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="8768234600-18">(</span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="8768234600-18">)</span><span class="p" data-group-id="8768234600-17">)</span><span class="p" data-group-id="8768234600-16">)</span><span class="w">
      </span><span class="n">neg_y_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8768234600-19">(</span><span class="o">-</span><span class="k">unquote</span><span class="p" data-group-id="8768234600-20">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="8768234600-21">(</span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="8768234600-21">)</span><span class="p" data-group-id="8768234600-20">)</span><span class="p" data-group-id="8768234600-19">)</span><span class="w">

      </span><span class="c1"># normalize to 0..360; must add 360 in case of negative angle values</span><span class="w">
      </span><span class="n">normalized</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">rem</span><span class="p" data-group-id="8768234600-22">(</span><span class="mi">360</span><span class="p" data-group-id="8768234600-22">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Kernel</span><span class="o">.</span><span class="o">+</span><span class="p" data-group-id="8768234600-23">(</span><span class="mi">360</span><span class="p" data-group-id="8768234600-23">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">rem</span><span class="p" data-group-id="8768234600-24">(</span><span class="mi">360</span><span class="p" data-group-id="8768234600-24">)</span><span class="w">

      </span><span class="n">result_vars_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">normalized</span><span class="w"> </span><span class="k" data-group-id="8768234600-25">do</span><span class="w">
        </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="8768234600-26">[</span><span class="n">x_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">y_quoted</span><span class="p" data-group-id="8768234600-26">]</span><span class="w">
        </span><span class="mi">90</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="8768234600-27">[</span><span class="n">neg_y_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">x_quoted</span><span class="p" data-group-id="8768234600-27">]</span><span class="w">
        </span><span class="mi">180</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="8768234600-28">[</span><span class="n">neg_x_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">neg_y_quoted</span><span class="p" data-group-id="8768234600-28">]</span><span class="w">
        </span><span class="mi">270</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="8768234600-29">[</span><span class="n">y_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">neg_x_quoted</span><span class="p" data-group-id="8768234600-29">]</span><span class="w">
        </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="k">raise</span><span class="w"> </span><span class="s">&quot;Optimized angles must be right or straight&quot;</span><span class="w">
      </span><span class="k" data-group-id="8768234600-25">end</span><span class="w">

      </span><span class="c1"># at last return a quoted function definition</span><span class="w">
      </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8768234600-30">do</span><span class="w">
        </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="8768234600-31">(</span><span class="p" data-group-id="8768234600-32">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="8768234600-32">}</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8768234600-33">(</span><span class="n">angle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1.0</span><span class="p" data-group-id="8768234600-33">)</span><span class="p" data-group-id="8768234600-31">)</span><span class="w"> </span><span class="k" data-group-id="8768234600-34">do</span><span class="w">
          </span><span class="p" data-group-id="8768234600-35">{</span><span class="k">unquote_splicing</span><span class="p" data-group-id="8768234600-36">(</span><span class="n">result_vars_quoted</span><span class="p" data-group-id="8768234600-36">)</span><span class="p" data-group-id="8768234600-35">}</span><span class="w">
        </span><span class="k" data-group-id="8768234600-34">end</span><span class="w">
      </span><span class="k" data-group-id="8768234600-30">end</span><span class="w">
    </span><span class="k" data-group-id="8768234600-11">end</span><span class="w">
  </span><span class="k" data-group-id="8768234600-1">end</span><span class="w">

  </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD</span><span class="w"> </span><span class="k" data-group-id="8768234600-37">do</span><span class="w">
    </span><span class="kn">require</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="w">

    </span><span class="c1"># Optimized versions of the code</span><span class="w">
    </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8768234600-38">(</span><span class="o">-</span><span class="mi">270</span><span class="p" data-group-id="8768234600-38">)</span><span class="w">
    </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8768234600-39">(</span><span class="o">-</span><span class="mi">180</span><span class="p" data-group-id="8768234600-39">)</span><span class="w">
    </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8768234600-40">(</span><span class="o">-</span><span class="mi">90</span><span class="p" data-group-id="8768234600-40">)</span><span class="w">
    </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8768234600-41">(</span><span class="mi">0</span><span class="p" data-group-id="8768234600-41">)</span><span class="w">
    </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8768234600-42">(</span><span class="mi">90</span><span class="p" data-group-id="8768234600-42">)</span><span class="w">
    </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8768234600-43">(</span><span class="mi">180</span><span class="p" data-group-id="8768234600-43">)</span><span class="w">
    </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8768234600-44">(</span><span class="mi">270</span><span class="p" data-group-id="8768234600-44">)</span><span class="w">

    </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="8768234600-45">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="8768234600-45">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8768234600-46">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="8768234600-46">)</span><span class="w">
  </span><span class="k" data-group-id="8768234600-37">end</span></code></pre>
<p>
The <code class="inline">rotate</code> function has been moved to the <code class="inline">TwoD.Helpers</code> module, and then replaced with a simple forwarding call. It will be useful when we later want to test our optimized function towards the unoptimized one.</p>
<p>
When I first implemented <code class="inline">def_optimized_rotate</code> I was caught a bit off guard as the parameters to the macro are not available as the simple numbers that I passed them. The parameter <code class="inline">angle_quoted</code> is actually passed as a block of code.  So in order for the macro to be able to precalculate the code, we have to add <code class="inline">{angle, _} = Code.eval_quoted angle_quoted</code> at the top of our macro to expand the code for the number into an actual value.</p>
<p>
Please note that I would not recommend using <code class="inline">Code.eval_quoted</code> for reasons that will hopefully become clear later.</p>
<p>
For this particular problem, I am quite happy spelling out all the seven values that I want to optimize. But if there were many more interesting optimizations (for instance if the rotation was in 3D), spelling all of these out is not a good option. Let’s wrap the macro call in a <code class="inline">for</code> comprehension instead.</p>
<h2>
Inserting dynamic module definitions</h2>
<p>
Before writing the for comprehension, let’s look at how a function may be defined dynamically. We’ll start by making a function that simply returns it’s name, but that name is assigned to a variable at compile time, before the function is defined:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="8307248852-1">do</span><span class="w">
  </span><span class="n">function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_test_function&quot;</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8307248852-2">(</span><span class="n">function_name</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_atom</span><span class="p" data-group-id="8307248852-2">)</span><span class="p" data-group-id="8307248852-3">(</span><span class="p" data-group-id="8307248852-3">)</span><span class="w"> </span><span class="k" data-group-id="8307248852-4">do</span><span class="w">
    </span><span class="k">unquote</span><span class="p" data-group-id="8307248852-5">(</span><span class="n">function_name</span><span class="p" data-group-id="8307248852-5">)</span><span class="w">
  </span><span class="k" data-group-id="8307248852-4">end</span><span class="w">
</span><span class="k" data-group-id="8307248852-1">end</span></code></pre>
<p>
And when run it in IEx, we get:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="nc">Test</span><span class="o">.</span><span class="n">my_test_function</span><span class="w">
</span><span class="s">&quot;my_test_function&quot;</span></code></pre>
<p>
The thing to note is that when we are defining a module, we are in a way already inside an implicit <code class="inline">quote</code> statement, and that we may use <code class="inline">unquote</code> to expand dynamic code into our module. The first <code class="inline">unquote</code> inserts an atom containing the function name, the second inserts the return value.</p>
<p>
Actually, I have yet to see <code class="inline">unquote</code> used like this in a module definition. Normally you would prefer to use module attributes as often as possible, as they will automatically <code class="inline">unquote</code> their values. On the other hand, it seems <code class="inline">unquote</code> offers a bit more flexibility.</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="6257107758-1">do</span><span class="w">
  </span><span class="na">@function_name</span><span class="w"> </span><span class="s">&quot;my_test_function&quot;</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6257107758-2">(</span><span class="na">@function_name</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_atom</span><span class="p" data-group-id="6257107758-2">)</span><span class="p" data-group-id="6257107758-3">(</span><span class="p" data-group-id="6257107758-3">)</span><span class="w"> </span><span class="k" data-group-id="6257107758-4">do</span><span class="w">
    </span><span class="na">@function_name</span><span class="w">
  </span><span class="k" data-group-id="6257107758-4">end</span><span class="w">
</span><span class="k" data-group-id="6257107758-1">end</span></code></pre>
<p>
Our next step is to let the for comprehension enumerate all the angles that we want to optimize. Our <code class="inline">TwoD</code> module now looks like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD</span><span class="w"> </span><span class="k" data-group-id="8731222873-1">do</span><span class="w">
  </span><span class="kn">require</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="w">

  </span><span class="na">@angles</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="o">-</span><span class="mi">360</span><span class="o">.</span><span class="o">.</span><span class="mi">360</span><span class="p">,</span><span class="w"> </span><span class="n">rem</span><span class="p" data-group-id="8731222873-2">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">90</span><span class="p" data-group-id="8731222873-2">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">n</span><span class="w">

  </span><span class="c1"># Optimized versions of the code</span><span class="w">
  </span><span class="k">for</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="na">@angles</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">def_optimized_rotate</span><span class="p" data-group-id="8731222873-3">(</span><span class="n">angle</span><span class="p" data-group-id="8731222873-3">)</span><span class="w">

  </span><span class="c1"># This general purpose implementation will serve any other angle</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="8731222873-4">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="8731222873-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8731222873-5">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="8731222873-5">)</span><span class="w">
</span><span class="k" data-group-id="8731222873-1">end</span></code></pre>
<p>
This introduces a new problem to our code. Our macro <code class="inline">def_optimized_rotate</code> now receives the quoted reference to <code class="inline">angle</code> which is not possible to evaluate in the macro context. Actually our first implementation implicitly required that the <code class="inline">angle</code> parameter be spelled out as a number. It seems wrong that the user of our macro has to know that the parameter must have a particular form.</p>
<p>
This is the first time we will see a pattern with macro programming, and one reason to be wary of using macros: The macro might work well in one instance, but changes made in code outside of the macro could easily break it. To paraphrase a saying: The code is far from easy to reason about.</p>
<h2>
Delaying the macro logic</h2>
<p>
<em>If the mountain will not come to Muhammad, Muhammad must go to the mountain.</em></p>
<p>
There are two ways to use the angle values from the <code class="inline">for</code> comprehension in our macro:</p>
<ul>
  <li>
move the <code class="inline">for</code> comprehension into our macro, thus hardcoding the optimized angles  </li>
  <li>
inject everything into the resulting module definition  </li>
</ul>
<p>
We’ll choose the latter option beacuse I think it is more clear that the
optimized angles are stated in the <code class="inline">TwoD</code> module rather than in the macro.</p>
<p>
There is no way to evaluate the code in the macro parameter correctly inside the macro. Instead we must move all the code into a context where the parameter may be evaluated correctly.</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="w"> </span><span class="k" data-group-id="9826523973-1">do</span><span class="w">
  </span><span class="na">@deg_to_rad</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">pi</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="9826523973-2">(</span><span class="p" data-group-id="9826523973-3">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="9826523973-3">}</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="9826523973-2">)</span><span class="w"> </span><span class="k" data-group-id="9826523973-4">do</span><span class="w">
    </span><span class="n">radians</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="na">@deg_to_rad</span><span class="w">
    </span><span class="p" data-group-id="9826523973-5">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="9826523973-6">(</span><span class="n">radians</span><span class="p" data-group-id="9826523973-6">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="9826523973-7">(</span><span class="n">radians</span><span class="p" data-group-id="9826523973-7">)</span><span class="p">,</span><span class="w">
      </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">sin</span><span class="p" data-group-id="9826523973-8">(</span><span class="n">radians</span><span class="p" data-group-id="9826523973-8">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ss">:math</span><span class="o">.</span><span class="n">cos</span><span class="p" data-group-id="9826523973-9">(</span><span class="n">radians</span><span class="p" data-group-id="9826523973-9">)</span><span class="w"> </span><span class="p" data-group-id="9826523973-5">}</span><span class="w">
  </span><span class="k" data-group-id="9826523973-4">end</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">def_optimized_rotate</span><span class="p" data-group-id="9826523973-10">(</span><span class="n">angle</span><span class="p" data-group-id="9826523973-10">)</span><span class="w"> </span><span class="k" data-group-id="9826523973-11">do</span><span class="w">
    </span><span class="k">quote</span><span class="p" data-group-id="9826523973-12">(</span><span class="ss">bind_quoted</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9826523973-13">[</span><span class="ss">angle_copy</span><span class="p">:</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="9826523973-13">]</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="9826523973-12">)</span><span class="w"> </span><span class="k" data-group-id="9826523973-14">do</span><span class="w">
      </span><span class="n">x_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="9826523973-15">(</span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="9826523973-15">)</span><span class="w">
      </span><span class="n">y_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="9826523973-16">(</span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="9826523973-16">)</span><span class="w">
      </span><span class="n">neg_x_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9826523973-17">(</span><span class="o">-</span><span class="k">unquote</span><span class="p" data-group-id="9826523973-18">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="9826523973-19">(</span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="9826523973-19">)</span><span class="p" data-group-id="9826523973-18">)</span><span class="p" data-group-id="9826523973-17">)</span><span class="w">
      </span><span class="n">neg_y_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9826523973-20">(</span><span class="o">-</span><span class="k">unquote</span><span class="p" data-group-id="9826523973-21">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="9826523973-22">(</span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="9826523973-22">)</span><span class="p" data-group-id="9826523973-21">)</span><span class="p" data-group-id="9826523973-20">)</span><span class="w">

      </span><span class="c1"># normalize to 0..360; must add 360 in case of negative angle values</span><span class="w">
      </span><span class="n">normalized</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angle_copy</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">rem</span><span class="p" data-group-id="9826523973-23">(</span><span class="mi">360</span><span class="p" data-group-id="9826523973-23">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Kernel</span><span class="o">.</span><span class="o">+</span><span class="p" data-group-id="9826523973-24">(</span><span class="mi">360</span><span class="p" data-group-id="9826523973-24">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">rem</span><span class="p" data-group-id="9826523973-25">(</span><span class="mi">360</span><span class="p" data-group-id="9826523973-25">)</span><span class="w">

      </span><span class="n">result_vars_quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">normalized</span><span class="w"> </span><span class="k" data-group-id="9826523973-26">do</span><span class="w">
        </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="9826523973-27">[</span><span class="n">x_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">y_quoted</span><span class="p" data-group-id="9826523973-27">]</span><span class="w">
        </span><span class="mi">90</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="9826523973-28">[</span><span class="n">neg_y_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">x_quoted</span><span class="p" data-group-id="9826523973-28">]</span><span class="w">
        </span><span class="mi">180</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="9826523973-29">[</span><span class="n">neg_x_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">neg_y_quoted</span><span class="p" data-group-id="9826523973-29">]</span><span class="w">
        </span><span class="mi">270</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="9826523973-30">[</span><span class="n">y_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">neg_x_quoted</span><span class="p" data-group-id="9826523973-30">]</span><span class="w">
        </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="k">raise</span><span class="w"> </span><span class="s">&quot;Optimized angles must be right or straight&quot;</span><span class="w">
      </span><span class="k" data-group-id="9826523973-26">end</span><span class="w">

      </span><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="9826523973-31">(</span><span class="p" data-group-id="9826523973-32">{</span><span class="k">unquote_splicing</span><span class="p" data-group-id="9826523973-33">(</span><span class="p" data-group-id="9826523973-34">[</span><span class="n">x_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">y_quoted</span><span class="p" data-group-id="9826523973-34">]</span><span class="p" data-group-id="9826523973-33">)</span><span class="p" data-group-id="9826523973-32">}</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9826523973-35">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">angle_copy</span><span class="p" data-group-id="9826523973-35">)</span><span class="p" data-group-id="9826523973-31">)</span><span class="w"> </span><span class="k" data-group-id="9826523973-36">do</span><span class="w">
        </span><span class="p" data-group-id="9826523973-37">{</span><span class="k">unquote_splicing</span><span class="p" data-group-id="9826523973-38">(</span><span class="n">result_vars_quoted</span><span class="p" data-group-id="9826523973-38">)</span><span class="p" data-group-id="9826523973-37">}</span><span class="w">
      </span><span class="k" data-group-id="9826523973-36">end</span><span class="w">
    </span><span class="k" data-group-id="9826523973-14">end</span><span class="w">
  </span><span class="k" data-group-id="9826523973-11">end</span><span class="w">
</span><span class="k" data-group-id="9826523973-1">end</span></code></pre>
<p>
Compared to the initial <code class="inline">rotate</code> function, this code is admittedly quite dense. This is where I gradually realize why everyone warns against macro overuse.</p>
<p>
The first thing to note is that all the generated code is contained inside a giant quote statement. Because we want to insert <code class="inline">unquote</code> calls into our result (to be evaluated inside the module definition), we have to use the option <code class="inline">unquote: false</code>.</p>
<p>
We may no longer use <code class="inline">unquote</code> to insert the <code class="inline">angle</code> parameter quoted. To mend this, we add the option <code class="inline">bind_quoted: [angle_copy: angle]</code>. The result of adding the <code class="inline">bind_quoted</code> option is best shown with an example:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">4.0</span><span class="w">
</span><span class="p" data-group-id="1530598284-1">{</span><span class="ss">:*</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1530598284-2">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="1530598284-2">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1530598284-3">[</span><span class="mi">90</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p" data-group-id="1530598284-3">]</span><span class="p" data-group-id="1530598284-1">}</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="nc">Macro</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="1530598284-4">(</span><span class="k">quote</span><span class="p" data-group-id="1530598284-5">(</span><span class="ss">bind_quoted</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1530598284-6">[</span><span class="ss">angle_copy</span><span class="p">:</span><span class="w"> </span><span class="n">angle</span><span class="p" data-group-id="1530598284-6">]</span><span class="p" data-group-id="1530598284-5">)</span><span class="w"> </span><span class="k" data-group-id="1530598284-7">do</span><span class="w">
</span><span class="gp unselectable">...(2)&gt; </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">prepare_observed_vector</span><span class="w"> </span><span class="p" data-group-id="1530598284-8">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="1530598284-8">}</span><span class="p">,</span><span class="w"> </span><span class="n">angle_copy</span><span class="p">,</span><span class="w"> </span><span class="ss">:x</span><span class="w">
</span><span class="gp unselectable">...(2)&gt; </span><span class="c1"># more code</span><span class="w">
</span><span class="gp unselectable">...(2)&gt; </span><span class="k" data-group-id="1530598284-7">end</span><span class="p" data-group-id="1530598284-4">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w">
</span><span class="p" data-group-id="1530598284-9">(</span><span class="w">
  </span><span class="n">angle_copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">4.0</span><span class="w">
  </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">prepare_observed_vector</span><span class="p" data-group-id="1530598284-10">(</span><span class="p" data-group-id="1530598284-11">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="1530598284-11">}</span><span class="p">,</span><span class="w"> </span><span class="n">angle_copy</span><span class="p">,</span><span class="w"> </span><span class="ss">:x</span><span class="p" data-group-id="1530598284-10">)</span><span class="w">
</span><span class="p" data-group-id="1530598284-9">)</span><span class="w">
</span><span class="ss">:ok</span></code></pre>
<p>
<code class="inline">bind_quoted</code> is really quite simple. It just adds an assignment before any other code. This also has the benefit of ensuring that the parameter code is only evaluated once. Seems we should be using <code class="inline">bind_quoted</code> rather than inline unquoting in most circumstances.</p>
<p>
As we don’t really use the angle in the macro anymore, we no longer need <code class="inline">Code.eval_quoted</code>. I admit using it was a bad idea in the first place.</p>
<p>
This is the second time the macro stopped working due to changes in the calling code. It seems the first version of out macro worked more or less by accident. The code:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="5572624441-1">(</span><span class="p" data-group-id="5572624441-2">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="5572624441-2">}</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5572624441-3">(</span><span class="n">angle_copy</span><span class="p" data-group-id="5572624441-3">)</span><span class="p" data-group-id="5572624441-1">)</span><span class="w"> </span><span class="k" data-group-id="5572624441-4">do</span><span class="w">
  </span><span class="p" data-group-id="5572624441-5">{</span><span class="k">unquote_splicing</span><span class="p" data-group-id="5572624441-6">(</span><span class="n">result_vars_quoted</span><span class="p" data-group-id="5572624441-6">)</span><span class="p" data-group-id="5572624441-5">}</span><span class="w">
</span><span class="k" data-group-id="5572624441-4">end</span></code></pre>
<p>
had to be replaced with:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p" data-group-id="1583363929-1">(</span><span class="p" data-group-id="1583363929-2">{</span><span class="k">unquote_splicing</span><span class="p" data-group-id="1583363929-3">(</span><span class="p" data-group-id="1583363929-4">[</span><span class="n">x_quoted</span><span class="p">,</span><span class="w"> </span><span class="n">y_quoted</span><span class="p" data-group-id="1583363929-4">]</span><span class="p" data-group-id="1583363929-3">)</span><span class="p" data-group-id="1583363929-2">}</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="1583363929-5">(</span><span class="n">angle_copy</span><span class="p" data-group-id="1583363929-5">)</span><span class="p" data-group-id="1583363929-1">)</span><span class="w"> </span><span class="k" data-group-id="1583363929-6">do</span><span class="w">
  </span><span class="p" data-group-id="1583363929-7">{</span><span class="k">unquote_splicing</span><span class="p" data-group-id="1583363929-8">(</span><span class="n">result_vars_quoted</span><span class="p" data-group-id="1583363929-8">)</span><span class="p" data-group-id="1583363929-7">}</span><span class="w">
</span><span class="k" data-group-id="1583363929-6">end</span></code></pre>
<p>
The reason for this being that the quoted code for the result did not, due to macro hygiene, map directly to <code class="inline">{x,y}</code>.</p>
<p>
This does the trick, and the code now works as intended.</p>
<h2>
Testing</h2>
<p>
To test the code, we will compare the output of our optimized function and the generic implementation. The test might look like this:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># in file test/two_d_test.exs</span><span class="w">
</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TwoD.Tests</span><span class="w"> </span><span class="k" data-group-id="8602835757-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.Case</span><span class="p">,</span><span class="w"> </span><span class="ss">async</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kn">alias</span><span class="w"> </span><span class="nc">TwoD.Helpers</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">H</span><span class="w">

  </span><span class="na">@point</span><span class="w"> </span><span class="p" data-group-id="8602835757-2">{</span><span class="mf">123.0</span><span class="p">,</span><span class="w"> </span><span class="mf">456.0</span><span class="p" data-group-id="8602835757-2">}</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">round_point</span><span class="p" data-group-id="8602835757-3">(</span><span class="p" data-group-id="8602835757-4">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="8602835757-4">}</span><span class="p" data-group-id="8602835757-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8602835757-5">{</span><span class="n">round</span><span class="p" data-group-id="8602835757-6">(</span><span class="n">x</span><span class="p" data-group-id="8602835757-6">)</span><span class="p">,</span><span class="w"> </span><span class="n">round</span><span class="p" data-group-id="8602835757-7">(</span><span class="n">y</span><span class="p" data-group-id="8602835757-7">)</span><span class="p" data-group-id="8602835757-5">}</span><span class="w">

  </span><span class="n">test</span><span class="w"> </span><span class="s">&quot;optimized rotates must match generic version&quot;</span><span class="w"> </span><span class="k" data-group-id="8602835757-8">do</span><span class="w">
    </span><span class="n">assert</span><span class="w"> </span><span class="p" data-group-id="8602835757-9">(</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-10">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">270.0</span><span class="p" data-group-id="8602835757-10">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-9">)</span><span class="w"> </span><span class="o">==</span><span class="w">
      </span><span class="p" data-group-id="8602835757-11">(</span><span class="nc">H</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-12">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">270.0</span><span class="p" data-group-id="8602835757-12">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-11">)</span><span class="w">

    </span><span class="n">assert</span><span class="w"> </span><span class="p" data-group-id="8602835757-13">(</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-14">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p" data-group-id="8602835757-14">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-13">)</span><span class="w"> </span><span class="o">==</span><span class="w">
      </span><span class="p" data-group-id="8602835757-15">(</span><span class="nc">H</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-16">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p" data-group-id="8602835757-16">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-15">)</span><span class="w">

    </span><span class="n">assert</span><span class="w"> </span><span class="p" data-group-id="8602835757-17">(</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-18">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="mf">90.0</span><span class="p" data-group-id="8602835757-18">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-17">)</span><span class="w"> </span><span class="o">==</span><span class="w">
      </span><span class="p" data-group-id="8602835757-19">(</span><span class="nc">H</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-20">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="mf">90.0</span><span class="p" data-group-id="8602835757-20">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-19">)</span><span class="w">
  </span><span class="k" data-group-id="8602835757-8">end</span><span class="w">

  </span><span class="n">test</span><span class="w"> </span><span class="s">&quot;the non right/straight angles should still work&quot;</span><span class="w"> </span><span class="k" data-group-id="8602835757-21">do</span><span class="w">
    </span><span class="n">assert</span><span class="w"> </span><span class="p" data-group-id="8602835757-22">(</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-23">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="mf">85.0</span><span class="p" data-group-id="8602835757-23">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-22">)</span><span class="w"> </span><span class="o">==</span><span class="w">
      </span><span class="p" data-group-id="8602835757-24">(</span><span class="nc">H</span><span class="o">.</span><span class="n">rotate</span><span class="p" data-group-id="8602835757-25">(</span><span class="na">@point</span><span class="p">,</span><span class="w"> </span><span class="mf">85.0</span><span class="p" data-group-id="8602835757-25">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">round_point</span><span class="p" data-group-id="8602835757-24">)</span><span class="w">
  </span><span class="k" data-group-id="8602835757-21">end</span><span class="w">
</span><span class="k" data-group-id="8602835757-1">end</span></code></pre>
<h2>
Benchmarking the results</h2>
<p>
A final difficulty remains: we are still not sure whether our optimized code is actually running, or the generic implementation is still handling all function calls.</p>
<p>
If the optimization is working, a benchmark should show us that. In any event it is useful to measure that the optimization is worthwhile. I decided to use the <code class="inline">benchwarmer</code> package for this. The <code class="inline">mix.exs</code> file is modified to include:</p>
<pre><code class="highlight makeup elixir"><span class="w">  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">deps</span><span class="w"> </span><span class="k" data-group-id="7517965778-1">do</span><span class="w">
    </span><span class="p" data-group-id="7517965778-2">[</span><span class="w">
      </span><span class="p" data-group-id="7517965778-3">{</span><span class="w"> </span><span class="ss">:benchwarmer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;~&gt; 0.0.2&quot;</span><span class="w"> </span><span class="p" data-group-id="7517965778-3">}</span><span class="w">
    </span><span class="p" data-group-id="7517965778-2">]</span><span class="w">
  </span><span class="k" data-group-id="7517965778-1">end</span></code></pre>
<p>
And then we’ll add a simple benchmark script like this:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># in file lib/mix/tasks/benchmark.ex</span><span class="w">
</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Mix.Tasks.Benchmark</span><span class="w"> </span><span class="k" data-group-id="6099472733-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Mix.Task</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="p" data-group-id="6099472733-2">(</span><span class="bp">_</span><span class="p" data-group-id="6099472733-2">)</span><span class="w"> </span><span class="k" data-group-id="6099472733-3">do</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;Checking optimized vs unoptimized&quot;</span><span class="w">
    </span><span class="nc">Benchwarmer</span><span class="o">.</span><span class="n">benchmark</span><span class="p" data-group-id="6099472733-4">(</span><span class="w">
      </span><span class="p" data-group-id="6099472733-5">[</span><span class="o">&amp;</span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="p" data-group-id="6099472733-5">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6099472733-6">[</span><span class="p" data-group-id="6099472733-7">{</span><span class="mf">123.0</span><span class="p">,</span><span class="w"> </span><span class="mf">456.0</span><span class="p" data-group-id="6099472733-7">}</span><span class="p">,</span><span class="w"> </span><span class="mf">180.0</span><span class="p" data-group-id="6099472733-6">]</span><span class="w">
    </span><span class="p" data-group-id="6099472733-4">)</span><span class="w">

    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;Checking overhead of having optimizations&quot;</span><span class="w">
    </span><span class="nc">Benchwarmer</span><span class="o">.</span><span class="n">benchmark</span><span class="p" data-group-id="6099472733-8">(</span><span class="w">
      </span><span class="p" data-group-id="6099472733-9">[</span><span class="o">&amp;</span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="p" data-group-id="6099472733-9">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6099472733-10">[</span><span class="p" data-group-id="6099472733-11">{</span><span class="mf">123.0</span><span class="p">,</span><span class="w"> </span><span class="mf">456.0</span><span class="p" data-group-id="6099472733-11">}</span><span class="p">,</span><span class="w"> </span><span class="mf">182.0</span><span class="p" data-group-id="6099472733-10">]</span><span class="w">
    </span><span class="p" data-group-id="6099472733-8">)</span><span class="w">
  </span><span class="k" data-group-id="6099472733-3">end</span><span class="w">
</span><span class="k" data-group-id="6099472733-1">end</span></code></pre>
<p>
in turn giving us:</p>
<pre><code class="highlight makeup elixir"><span class="err">$</span><span class="w"> </span><span class="n">mix</span><span class="w"> </span><span class="n">benchmark</span><span class="w">
</span><span class="nc">Checking</span><span class="w"> </span><span class="n">optimized</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="n">unoptimized</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w">
</span><span class="mf">1.6</span><span class="w"> </span><span class="n">sec</span><span class="w">   </span><span class="mi">524</span><span class="nc">K</span><span class="w"> </span><span class="n">iterations</span><span class="w">   </span><span class="mf">3.18</span><span class="w"> </span><span class="n">μs</span><span class="o">/</span><span class="n">op</span><span class="w">

</span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w">
</span><span class="mf">1.4</span><span class="w"> </span><span class="n">sec</span><span class="w">     </span><span class="mi">2</span><span class="nc">M</span><span class="w"> </span><span class="n">iterations</span><span class="w">   </span><span class="mf">0.71</span><span class="w"> </span><span class="n">μs</span><span class="o">/</span><span class="n">op</span><span class="w">

</span><span class="nc">Checking</span><span class="w"> </span><span class="n">overhead</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">having</span><span class="w"> </span><span class="n">optimizations</span><span class="w">
</span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">TwoD.Helpers</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w">
</span><span class="mf">1.3</span><span class="w"> </span><span class="n">sec</span><span class="w">     </span><span class="mi">1</span><span class="nc">M</span><span class="w"> </span><span class="n">iterations</span><span class="w">   </span><span class="mf">1.34</span><span class="w"> </span><span class="n">μs</span><span class="o">/</span><span class="n">op</span><span class="w">

</span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">TwoD</span><span class="o">.</span><span class="n">rotate</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="o">*</span><span class="w">
</span><span class="mf">1.8</span><span class="w"> </span><span class="n">sec</span><span class="w">     </span><span class="mi">1</span><span class="nc">M</span><span class="w"> </span><span class="n">iterations</span><span class="w">   </span><span class="mf">1.78</span><span class="w"> </span><span class="n">μs</span><span class="o">/</span><span class="n">op</span></code></pre>
<p>
I find it a bit interesting that we are getting a 4X speedup for the straight and right angles, while at the same time the general purpose call is 20% slower. Neither of these results should come as a big surprise.</p>
<p>
In conclusion, this technique is worthwhile if you have a slow computation that is mostly called with a specific range of arguments. It also seems wise to factor in the loss of readability.</p>
<p>
You may browse the complete source code at <a href="https://github.com/tallakt/two_d">GitHub</a></p>
<h2>
Thanks</h2>
<p>
Thanks to <a href="https://twitter.com/mgwidmann">@mgwidmann</a> for pointing out that <code class="inline">unquote</code> is so useful inside a module definition.</p>
<p>
Thanks to Saša Jurić for getting me through difficult compiler issues, and then helping me out with the code examples and text.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2015, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/tallakt_macros">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/tallakt_macros.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Thu, 6 Aug 2015 00:00:00 +0000</pubDate></item><item><title>Beyond Task.Async</title><link>http://theerlangelist.com//article/beyond_taskasync</link><description><![CDATA[<h1>Beyond Task.Async</h1>
<h4 class="right">2015-07-31</h4>

<div class="article-body">
<p>
In this post I’ll talk about less typical patterns of parallelization with tasks. Arguably, the most common case for tasks is to start some jobs concurrently with <code class="inline">Task.async</code> and then collect the results with <code class="inline">Task.await</code>. By doing this we might run separate jobs in parallel, and thus perform the total work more efficiently. This can be done very elegantly with async/await without the much overhead in the code.</p>
<p>
However, async/await have some properties which may not be suitable in some cases, so you might need a different approach. That is the topic of this post, but first, let’s quickly recap the basic async/await pattern.</p>
<h2>
Parallelizing with async/await</h2>
<p>
Async/await makes sense when we need to perform multiple independent computations and aggregate their results into the total output. If computations take some time, we might benefit by running them concurrently, possibly reducing the total execution time from <code class="inline">sum(computation_times)</code> to <code class="inline">max(computation_times)</code>.</p>
<p>
The computation can be any activity such as database query, a call to a 3rd party service, or some CPU bound calculation. In this post, I’ll just use a contrived stub:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Computation</span><span class="w"> </span><span class="k" data-group-id="0968566161-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="p" data-group-id="0968566161-2">(</span><span class="n">x</span><span class="p" data-group-id="0968566161-2">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k" data-group-id="0968566161-3">do</span><span class="w">
    </span><span class="ss">:timer</span><span class="o">.</span><span class="n">sleep</span><span class="p" data-group-id="0968566161-4">(</span><span class="n">x</span><span class="p" data-group-id="0968566161-4">)</span><span class="w">  </span><span class="c1"># simulates a long-running operation</span><span class="w">
    </span><span class="n">x</span><span class="w">
  </span><span class="k" data-group-id="0968566161-3">end</span><span class="w">
</span><span class="k" data-group-id="0968566161-1">end</span></code></pre>
<p>
This “computation” takes a positive integer <code class="inline">x</code>, sleeps for <code class="inline">x</code> milliseconds, and returns the number back. It’s just a simulation of a possibly long running operation.</p>
<p>
Now, let’s say that we need to aggregate the results of multiple computations. Again, I’ll introduce a simple stub:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Aggregator</span><span class="w"> </span><span class="k" data-group-id="0269671257-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">new</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">value</span><span class="p" data-group-id="0269671257-2">(</span><span class="n">aggregator</span><span class="p" data-group-id="0269671257-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">aggregator</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">add_result</span><span class="p" data-group-id="0269671257-3">(</span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="0269671257-3">)</span><span class="w"> </span><span class="k" data-group-id="0269671257-4">do</span><span class="w">
    </span><span class="ss">:timer</span><span class="o">.</span><span class="n">sleep</span><span class="p" data-group-id="0269671257-5">(</span><span class="mi">50</span><span class="p" data-group-id="0269671257-5">)</span><span class="w">
    </span><span class="n">aggregator</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">result</span><span class="w">
  </span><span class="k" data-group-id="0269671257-4">end</span><span class="w">
</span><span class="k" data-group-id="0269671257-1">end</span></code></pre>
<p>
This is just a simple wrapper which sums input numbers. In real life, this might be a more involved aggregator that somehow combines results of multiple queries into a single “thing”.</p>
<p>
Assuming that different computations are independent, there is potential to run them concurrently, and this is where tasks come in handy. For example, let’s say we need to run this computation for ten different numbers:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">AsyncAwait</span><span class="w"> </span><span class="k" data-group-id="7714805234-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="w"> </span><span class="k" data-group-id="7714805234-2">do</span><span class="w">
    </span><span class="ss">:random</span><span class="o">.</span><span class="n">seed</span><span class="p" data-group-id="7714805234-3">(</span><span class="ss">:os</span><span class="o">.</span><span class="n">timestamp</span><span class="p" data-group-id="7714805234-3">)</span><span class="w">

    </span><span class="mi">1</span><span class="o">.</span><span class="o">.</span><span class="mi">10</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7714805234-4">(</span><span class="k" data-group-id="7714805234-5">fn</span><span class="p" data-group-id="7714805234-6">(</span><span class="bp">_</span><span class="p" data-group-id="7714805234-6">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:random</span><span class="o">.</span><span class="n">uniform</span><span class="p" data-group-id="7714805234-7">(</span><span class="mi">1000</span><span class="p" data-group-id="7714805234-7">)</span><span class="w"> </span><span class="k" data-group-id="7714805234-5">end</span><span class="p" data-group-id="7714805234-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7714805234-8">(</span><span class="o">&amp;</span><span class="nc">Task</span><span class="o">.</span><span class="n">async</span><span class="p" data-group-id="7714805234-9">(</span><span class="k" data-group-id="7714805234-10">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Computation</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="7714805234-11">(</span><span class="ni">&amp;1</span><span class="p" data-group-id="7714805234-11">)</span><span class="w"> </span><span class="k" data-group-id="7714805234-10">end</span><span class="p" data-group-id="7714805234-9">)</span><span class="p" data-group-id="7714805234-8">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7714805234-12">(</span><span class="o">&amp;</span><span class="nc">Task</span><span class="o">.</span><span class="n">await</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="7714805234-12">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p" data-group-id="7714805234-13">(</span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">add_result</span><span class="p" data-group-id="7714805234-14">(</span><span class="ni">&amp;2</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="7714805234-14">)</span><span class="p" data-group-id="7714805234-13">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="w">
  </span><span class="k" data-group-id="7714805234-2">end</span><span class="w">
</span><span class="k" data-group-id="7714805234-1">end</span></code></pre>
<p>
This is a fairly simple technique. First, we generate some random input and start the task to handle each element. Then, we await on results of each task and reduce responses into the final value. This allow us to improve the running time, since computations might run in parallel. The total time should be the time of the longest running computation plus the fixed penalty of 500 ms (10 * 50 ms) to include each result into the total output. In this example it shouldn’t take longer than 1500 ms to get the final result.</p>
<h2>
Properties of async/await</h2>
<p>
Async/await is very elegant and brings some nice benefits, but it also has some limitations.</p>
<p>
The first problem is that we await on results in the order we started the tasks. In some cases, this might not be optimal. For example, imagine that the first task takes 500 ms, while all others take 1 ms. This means that we’ll process the results of short-running tasks only after we handle the slow task. The total execution time in this example will be about 1 second. From the performance point of view, it would be better if we would take results as they arrive. This would allow us to aggregate most of the results while the slowest task is still running, reducing the execution time to 550 ms.</p>
<p>
Another issue is that it’s not easy to enforce a global timeout. You can’t easily say, “I want to give up if all the results don’t arrive in 500 ms”. You can provide a timeout to <code class="inline">Task.await</code> (it’s five seconds by default), but this applies only to a single await operation. Hence, a five seconds timeout actually means we might end up waiting 50 seconds for ten tasks to time out.</p>
<p>
Finally, you should be aware that async/await pattern takes the all-or-nothing approach. If any task or the master process crashes, all involved processes will be taken down (unless they’re trapping exits). This happens because <code class="inline">Task.async</code> links the caller and the spawned task process.</p>
<p>
In most situations, these issues won’t really matter, and async/await combo will be perfectly fine. However, sometimes you might want to change the default behaviour.</p>
<h2>
Eliminating await</h2>
<p>
Let’s start by making the “master” process handle results in the order of arrival. This is fairly simple if we rely on the fact that <code class="inline">Task.async</code> reports the result back to the caller process via a message. We can therefore receive a message, and check if it comes from one of our task. If so, we can add the result to the aggregator.</p>
<p>
To do this, we can rely on <code class="inline">Task.find/2</code> that takes the list of tasks and the message, and returns either <code class="inline">{result, task}</code> if the message corresponds to the task in the list, or <code class="inline">nil</code> if the message is not from a task in the given list:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">AsyncFind</span><span class="w"> </span><span class="k" data-group-id="8527201843-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="w"> </span><span class="k" data-group-id="8527201843-2">do</span><span class="w">
    </span><span class="ss">:random</span><span class="o">.</span><span class="n">seed</span><span class="p" data-group-id="8527201843-3">(</span><span class="ss">:os</span><span class="o">.</span><span class="n">timestamp</span><span class="p" data-group-id="8527201843-3">)</span><span class="w">

    </span><span class="mi">1</span><span class="o">.</span><span class="o">.</span><span class="mi">10</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="8527201843-4">(</span><span class="k" data-group-id="8527201843-5">fn</span><span class="p" data-group-id="8527201843-6">(</span><span class="bp">_</span><span class="p" data-group-id="8527201843-6">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:random</span><span class="o">.</span><span class="n">uniform</span><span class="p" data-group-id="8527201843-7">(</span><span class="mi">1000</span><span class="p" data-group-id="8527201843-7">)</span><span class="w"> </span><span class="k" data-group-id="8527201843-5">end</span><span class="p" data-group-id="8527201843-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="8527201843-8">(</span><span class="o">&amp;</span><span class="nc">Task</span><span class="o">.</span><span class="n">async</span><span class="p" data-group-id="8527201843-9">(</span><span class="k" data-group-id="8527201843-10">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Computation</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="8527201843-11">(</span><span class="ni">&amp;1</span><span class="p" data-group-id="8527201843-11">)</span><span class="w"> </span><span class="k" data-group-id="8527201843-10">end</span><span class="p" data-group-id="8527201843-9">)</span><span class="p" data-group-id="8527201843-8">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">collect_results</span><span class="w">
  </span><span class="k" data-group-id="8527201843-2">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="8527201843-12">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="w"> </span><span class="o">\\</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">new</span><span class="p" data-group-id="8527201843-12">)</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="8527201843-13">(</span><span class="p" data-group-id="8527201843-14">[</span><span class="p" data-group-id="8527201843-14">]</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p" data-group-id="8527201843-13">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="p" data-group-id="8527201843-15">(</span><span class="n">aggregator</span><span class="p" data-group-id="8527201843-15">)</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="8527201843-16">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p" data-group-id="8527201843-16">)</span><span class="w"> </span><span class="k" data-group-id="8527201843-17">do</span><span class="w">
    </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="8527201843-18">do</span><span class="w">
      </span><span class="n">msg</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="k">case</span><span class="w"> </span><span class="nc">Task</span><span class="o">.</span><span class="n">find</span><span class="p" data-group-id="8527201843-19">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="8527201843-19">)</span><span class="w"> </span><span class="k" data-group-id="8527201843-20">do</span><span class="w">
          </span><span class="p" data-group-id="8527201843-21">{</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p" data-group-id="8527201843-21">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
            </span><span class="n">collect_results</span><span class="p" data-group-id="8527201843-22">(</span><span class="w">
              </span><span class="nc">List</span><span class="o">.</span><span class="n">delete</span><span class="p" data-group-id="8527201843-23">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p" data-group-id="8527201843-23">)</span><span class="p">,</span><span class="w">
              </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">add_result</span><span class="p" data-group-id="8527201843-24">(</span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="8527201843-24">)</span><span class="w">
            </span><span class="p" data-group-id="8527201843-22">)</span><span class="w">

          </span><span class="no">nil</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
            </span><span class="n">collect_results</span><span class="p" data-group-id="8527201843-25">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p" data-group-id="8527201843-25">)</span><span class="w">
        </span><span class="k" data-group-id="8527201843-20">end</span><span class="w">
    </span><span class="k" data-group-id="8527201843-18">end</span><span class="w">
  </span><span class="k" data-group-id="8527201843-17">end</span><span class="w">
</span><span class="k" data-group-id="8527201843-1">end</span></code></pre>
<p>
Most of the action happens in <code class="inline">collect_results</code>. Here, we loop recursively, waiting for a message to arrive. Then we invoke <code class="inline">Task.find/2</code> to determine whether the message comes from a task. If yes, we delete the task from the list of pending tasks, aggregate the response and resume the loop. The loop stops when there are no more pending tasks in the list. Then, we simply return the aggregated value.</p>
<p>
In this example I’m using explicit receive, but in production you should be careful about it. If the master process is a server, such as <code class="inline">GenServer</code> or <code class="inline">Phoenix.Channel</code>, you should let the underlying behaviour receive messages, and invoke <code class="inline">Task.find/2</code> from the <code class="inline">handle_info</code> callback. For the sake of brevity, I didn’t take that approach here, but as an exercise you could try to implement it yourself.</p>
<p>
One final note: by receiving results as they arrive we lose the ordering. In this case, where we simply sum numbers, this doesn’t matter. If you must preserve the ordering, you’ll need to include an additional order info, and then sort the results after they are collected.</p>
<h2>
Handling timeouts</h2>
<p>
Once we moved away from <code class="inline">Task.await</code>, the master process becomes more flexible. For example, we can now easily introduce a global timeout. The idea is simple: after the tasks are started, we can use <code class="inline">Process.send_after/3</code> to send a message to the master process after some time:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Timeout</span><span class="w"> </span><span class="k" data-group-id="6809047867-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="w"> </span><span class="k" data-group-id="6809047867-2">do</span><span class="w">
    </span><span class="c1"># exactly the same as before</span><span class="w">
  </span><span class="k" data-group-id="6809047867-2">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="6809047867-3">(</span><span class="n">tasks</span><span class="p" data-group-id="6809047867-3">)</span><span class="w"> </span><span class="k" data-group-id="6809047867-4">do</span><span class="w">
    </span><span class="n">timeout_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_ref</span><span class="w">
    </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Process</span><span class="o">.</span><span class="n">send_after</span><span class="p" data-group-id="6809047867-5">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6809047867-6">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="6809047867-6">}</span><span class="p">,</span><span class="w"> </span><span class="mi">900</span><span class="p" data-group-id="6809047867-5">)</span><span class="w">
    </span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="6809047867-7">do</span><span class="w">
      </span><span class="n">collect_results</span><span class="p" data-group-id="6809047867-8">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="6809047867-8">)</span><span class="w">
    </span><span class="k" data-group-id="6809047867-7">after</span><span class="w">
      </span><span class="ss">:erlang</span><span class="o">.</span><span class="n">cancel_timer</span><span class="p" data-group-id="6809047867-9">(</span><span class="n">timer</span><span class="p" data-group-id="6809047867-9">)</span><span class="w">
      </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="6809047867-10">do</span><span class="w">
        </span><span class="p" data-group-id="6809047867-11">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="n">timeout_ref</span><span class="p" data-group-id="6809047867-11">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:ok</span><span class="w">
        </span><span class="k" data-group-id="6809047867-10">after</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:ok</span><span class="w">
      </span><span class="k" data-group-id="6809047867-10">end</span><span class="w">
    </span><span class="k" data-group-id="6809047867-7">end</span><span class="w">
  </span><span class="k" data-group-id="6809047867-4">end</span><span class="w">

  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="6809047867-1">end</span></code></pre>
<p>
Here, we create the timer, and a reference which will be a part of the timeout message. Then we enqueue the timeout message to be sent to the master process after 900 ms. Including the reference in the message ensures that the timeout message will be unique for this run, and will not interfere with some other message.</p>
<p>
Finally, we start the receive loop and return it’s result.</p>
<p>
Take special note of the <code class="inline">after</code> block where we cancel the timer to avoid sending a timeout message if all the results arrive on time. However, since timer works concurrently to the master process, it is still possible that the message might have been sent just before we canceled the timer, but after all the results are already collected. Thus, we do a receive with a zero timeout to flush the message if it’s already in the queue.</p>
<p>
With this setup in place, we now need to handle the timeout message:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="2635691769-1">(</span><span class="p" data-group-id="2635691769-2">[</span><span class="p" data-group-id="2635691769-2">]</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="2635691769-1">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2635691769-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="p" data-group-id="2635691769-4">(</span><span class="n">aggregator</span><span class="p" data-group-id="2635691769-4">)</span><span class="p" data-group-id="2635691769-3">}</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="2635691769-5">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="2635691769-5">)</span><span class="w"> </span><span class="k" data-group-id="2635691769-6">do</span><span class="w">
  </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="2635691769-7">do</span><span class="w">
    </span><span class="p" data-group-id="2635691769-8">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="n">timeout_ref</span><span class="p" data-group-id="2635691769-8">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="p" data-group-id="2635691769-9">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="p" data-group-id="2635691769-10">(</span><span class="n">aggregator</span><span class="p" data-group-id="2635691769-10">)</span><span class="p" data-group-id="2635691769-9">}</span><span class="w">

    </span><span class="n">msg</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="k">case</span><span class="w"> </span><span class="nc">Task</span><span class="o">.</span><span class="n">find</span><span class="p" data-group-id="2635691769-11">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="2635691769-11">)</span><span class="w"> </span><span class="k" data-group-id="2635691769-12">do</span><span class="w">
        </span><span class="p" data-group-id="2635691769-13">{</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p" data-group-id="2635691769-13">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="n">collect_results</span><span class="p" data-group-id="2635691769-14">(</span><span class="w">
            </span><span class="nc">List</span><span class="o">.</span><span class="n">delete</span><span class="p" data-group-id="2635691769-15">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p" data-group-id="2635691769-15">)</span><span class="p">,</span><span class="w">
            </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">add_result</span><span class="p" data-group-id="2635691769-16">(</span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="2635691769-16">)</span><span class="p">,</span><span class="w">
            </span><span class="n">timeout_ref</span><span class="w">
          </span><span class="p" data-group-id="2635691769-14">)</span><span class="w">

        </span><span class="no">nil</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">collect_results</span><span class="p" data-group-id="2635691769-17">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="2635691769-17">)</span><span class="w">
      </span><span class="k" data-group-id="2635691769-12">end</span><span class="w">
  </span><span class="k" data-group-id="2635691769-7">end</span><span class="w">
</span><span class="k" data-group-id="2635691769-6">end</span></code></pre>
<p>
The core change here is in lines 4-5 where we explicitly deal with the timeout. In this example, we just return what we currently have. Depending on the particular use case, you may want to do something different, for example raise an error.</p>
<h2>
Explicitly handling errors</h2>
<p>
The next thing we’ll tackle is error handling. <code class="inline">Task.async</code> is built in such a way that if something fails, everything fails. When you start the task via <code class="inline">async</code> the process will be linked to the caller. This holds even if you use <code class="inline">Task.Supervisor.async</code>. As the result, if some task crashes, the master process will crash as well, taking down all other tasks.</p>
<p>
If this is not a problem, then <code class="inline">Task.async</code> is a perfectly valid solution. However, sometimes you may want to explicitly deal with errors. For example, you might want to just ignore failing tasks, reporting back whatever succeeded. Or you may want to keep the tasks running even if the master process crashes.</p>
<p>
There are two basic ways you can go about it: catch errors in the task, or use <code class="inline">Task.Supervisor</code> with <code class="inline">start_child</code>.</p>
<h3>
Catching errors</h3>
<p>
The simplest approach is to encircle the task code with a <code class="inline">try/catch</code> block:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Task</span><span class="o">.</span><span class="n">async</span><span class="p" data-group-id="4052983671-1">(</span><span class="k" data-group-id="4052983671-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="4052983671-3">do</span><span class="w">
    </span><span class="p" data-group-id="4052983671-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Computation</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="4052983671-5">(</span><span class="n">...</span><span class="p" data-group-id="4052983671-5">)</span><span class="p" data-group-id="4052983671-4">}</span><span class="w">
  </span><span class="k" data-group-id="4052983671-3">catch</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="ss">:error</span><span class="w">
  </span><span class="k" data-group-id="4052983671-3">end</span><span class="w">
</span><span class="k" data-group-id="4052983671-2">end</span><span class="p" data-group-id="4052983671-1">)</span></code></pre>
<p>
Then, when you receive results, you can explicitly handle each case, ignoring <code class="inline">:error</code> results. The implementation is mostly mechanical and left to you as an exercise.</p>
<p>
I’ve occasionally seen some concerns that catching is not the Erlang/Elixir way, so I’d like to touch on this. If you can do something meaningful with an error, catching is a reasonable approach. In this case, we want to collect all the successful responses, so ignoring failed ones is completely fine.</p>
<p>
So catching is definitely a simple way of explicitly dealing with errors, but it’s not without shortcomings. The main issue is that catch doesn’t handle exit signals. Thus, if the task links to some other process, and that other process terminates, the task process will crash as well. Since the task is linked to the master process, this will cause the master process to crash, and in turn crash all other tasks. The link between the caller and the task also means that if the master process crashes, for example while aggregating, all tasks will be terminated.</p>
<p>
To overcome this, we can either make all processes trap exits, or remove the link between processes. Trapping exits might introduce some subtle issues (see <a href="https://www.reddit.com/r/elixir/comments/3dlwhu/is_it_ok_to_trap_exits_in_a_cowboy_handler_process">here</a> for some information), so I’ll take the second approach.</p>
<h3>
Replacing async</h3>
<p>
The whole issue arises because <code class="inline">async</code> links the caller and the task process, which ensures “all-or-nothing” property. This is a perfectly fine decision, but it’s not necessarily suitable for all cases.   <del>
I wonder whether linking should be made optional, but I don’t have a strong opinion at the moment.  </del>
 <strong>Update</strong>: <a href="https://hexdocs.pm/elixir/Task.Supervisor.html#async_nolink/2">Task.Supervisor.async_nolink</a> has been introduced in Elixir 1.2, which allows you to start a task which is not linked to the caller.</p>
<p>
As it is, <code class="inline">Task.async</code> currently establishes a link, and if we want to avoid this, we need to reimplement async ourselves. Here’s what we’ll do:</p>
<ul>
  <li>
Start a <code class="inline">Task.Supervisor</code> and use <code class="inline">Task.Supervisor.start_child</code> to start tasks.  </li>
  <li>
Manually implement sending of the return message from the task to the caller.  </li>
  <li>
Have the master process monitor tasks so it can be notified about potential crashes. Explicitly handle such messages by removing the crashed task from the list of tasks we await on.  </li>
</ul>
<p>
The first point allows us to run tasks in a different part of the supervision tree from the master. Tasks and the master process are no longer linked, and failure of one process doesn’t cause failure of others.</p>
<p>
However, since we’re not using <code class="inline">async</code> anymore, we need to manually send the return message to the caller process.</p>
<p>
Finally, using the monitor ensures that the master process will be notified if some task crashes and can stop awaiting on their results.</p>
<p>
This requires more work, but it provides stronger guarantees. We can now be certain that:</p>
<ul>
  <li>
A failing task won’t crash anyone else.  </li>
  <li>
The master process will be informed about the task crash and can do something about it.  </li>
  <li>
Even a failure of master process won’t cause tasks to crash.  </li>
</ul>
<p>
If the third property doesn’t suit your purposes, you can simply place the master process and the tasks supervisor under the same common supervisor, with <code class="inline">one_for_all</code> or <code class="inline">rest_for_one</code> strategy.</p>
<p>
This is what I like about Erlang fault-tolerance approach. There are various options with strong guarantees. You can isolate crashes, but you can also connect failures if needed. Some scenarios may require more work, but the implementation is still straightforward. Supporting these scenarios without process isolation and crash propagation would be harder and you might end up reinventing parts of Erlang.</p>
<p>
Let’s implement this. The top-level <code class="inline">run/0</code> function is now changed a bit:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">SupervisedTask</span><span class="w"> </span><span class="k" data-group-id="7103878291-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="w"> </span><span class="k" data-group-id="7103878291-2">do</span><span class="w">
    </span><span class="ss">:random</span><span class="o">.</span><span class="n">seed</span><span class="p" data-group-id="7103878291-3">(</span><span class="ss">:os</span><span class="o">.</span><span class="n">timestamp</span><span class="p" data-group-id="7103878291-3">)</span><span class="w">
    </span><span class="nc">Task.Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="7103878291-4">(</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="ss">:task_supervisor</span><span class="p" data-group-id="7103878291-4">)</span><span class="w">

    </span><span class="n">work_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_ref</span><span class="w">

    </span><span class="mi">1</span><span class="o">.</span><span class="o">.</span><span class="mi">10</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7103878291-5">(</span><span class="k" data-group-id="7103878291-6">fn</span><span class="p" data-group-id="7103878291-7">(</span><span class="bp">_</span><span class="p" data-group-id="7103878291-7">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:random</span><span class="o">.</span><span class="n">uniform</span><span class="p" data-group-id="7103878291-8">(</span><span class="mi">1000</span><span class="p" data-group-id="7103878291-8">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="k" data-group-id="7103878291-6">end</span><span class="p" data-group-id="7103878291-5">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7103878291-9">(</span><span class="o">&amp;</span><span class="n">start_computation</span><span class="p" data-group-id="7103878291-10">(</span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="7103878291-10">)</span><span class="p" data-group-id="7103878291-9">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">collect_results</span><span class="p" data-group-id="7103878291-11">(</span><span class="n">work_ref</span><span class="p" data-group-id="7103878291-11">)</span><span class="w">
  </span><span class="k" data-group-id="7103878291-2">end</span><span class="w">

  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="7103878291-1">end</span></code></pre>
<p>
First, a named supervisor is started. This is a quick hack to keep the example short. In production, this supervisor should of course reside somewhere in the supervision hierarchy.</p>
<p>
Then, a <em>work reference</em> is created, which will be included in task response messages. Finally, we generate some random numbers and start our computations. Notice the <code class="inline">:random.uniform(1000) - 500</code>. This ensures that some numbers will be negative, which will cause some tasks to crash.</p>
<p>
Tasks now have to be started under the supervisor:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">start_computation</span><span class="p" data-group-id="0408239146-1">(</span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p" data-group-id="0408239146-1">)</span><span class="w"> </span><span class="k" data-group-id="0408239146-2">do</span><span class="w">
  </span><span class="n">caller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="w">

  </span><span class="c1"># Start the task under the named supervisor</span><span class="w">
  </span><span class="p" data-group-id="0408239146-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="0408239146-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Task.Supervisor</span><span class="o">.</span><span class="n">start_child</span><span class="p" data-group-id="0408239146-4">(</span><span class="w">
    </span><span class="ss">:task_supervisor</span><span class="p">,</span><span class="w">
    </span><span class="k" data-group-id="0408239146-5">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Computation</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="0408239146-6">(</span><span class="n">arg</span><span class="p" data-group-id="0408239146-6">)</span><span class="w">

      </span><span class="c1"># Send the result back to the caller</span><span class="w">
      </span><span class="n">send</span><span class="p" data-group-id="0408239146-7">(</span><span class="n">caller</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0408239146-8">{</span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="0408239146-8">}</span><span class="p" data-group-id="0408239146-7">)</span><span class="w">
    </span><span class="k" data-group-id="0408239146-5">end</span><span class="w">
  </span><span class="p" data-group-id="0408239146-4">)</span><span class="w">

  </span><span class="c1"># Monitor the started task</span><span class="w">
  </span><span class="nc">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p" data-group-id="0408239146-9">(</span><span class="n">pid</span><span class="p" data-group-id="0408239146-9">)</span><span class="w">
  </span><span class="n">pid</span><span class="w">
</span><span class="k" data-group-id="0408239146-2">end</span></code></pre>
<p>
Finally, we need to expand the receive loop to handle <code class="inline">:DOWN</code> messages, which we’ll receive when the task terminates:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="7734133551-1">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">work_ref</span><span class="p" data-group-id="7734133551-1">)</span><span class="w"> </span><span class="k" data-group-id="7734133551-2">do</span><span class="w">
  </span><span class="n">timeout_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_ref</span><span class="w">
  </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Process</span><span class="o">.</span><span class="n">send_after</span><span class="p" data-group-id="7734133551-3">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7734133551-4">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="7734133551-4">}</span><span class="p">,</span><span class="w"> </span><span class="mi">400</span><span class="p" data-group-id="7734133551-3">)</span><span class="w">
  </span><span class="k">try</span><span class="w"> </span><span class="k" data-group-id="7734133551-5">do</span><span class="w">
    </span><span class="n">collect_results</span><span class="p" data-group-id="7734133551-6">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="7734133551-6">)</span><span class="w">
  </span><span class="k" data-group-id="7734133551-5">after</span><span class="w">
    </span><span class="ss">:erlang</span><span class="o">.</span><span class="n">cancel_timer</span><span class="p" data-group-id="7734133551-7">(</span><span class="n">timer</span><span class="p" data-group-id="7734133551-7">)</span><span class="w">
    </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="7734133551-8">do</span><span class="w">
      </span><span class="p" data-group-id="7734133551-9">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="n">timeout_ref</span><span class="p" data-group-id="7734133551-9">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:ok</span><span class="w">
      </span><span class="k" data-group-id="7734133551-8">after</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:ok</span><span class="w">
    </span><span class="k" data-group-id="7734133551-8">end</span><span class="w">
  </span><span class="k" data-group-id="7734133551-5">end</span><span class="w">
</span><span class="k" data-group-id="7734133551-2">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="7734133551-10">(</span><span class="p" data-group-id="7734133551-11">[</span><span class="p" data-group-id="7734133551-11">]</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="7734133551-10">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7734133551-12">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="p" data-group-id="7734133551-13">(</span><span class="n">aggregator</span><span class="p" data-group-id="7734133551-13">)</span><span class="p" data-group-id="7734133551-12">}</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">collect_results</span><span class="p" data-group-id="7734133551-14">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="7734133551-14">)</span><span class="w"> </span><span class="k" data-group-id="7734133551-15">do</span><span class="w">
  </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="7734133551-16">do</span><span class="w">
    </span><span class="p" data-group-id="7734133551-17">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="n">timeout_ref</span><span class="p" data-group-id="7734133551-17">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="p" data-group-id="7734133551-18">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="p" data-group-id="7734133551-19">(</span><span class="n">aggregator</span><span class="p" data-group-id="7734133551-19">)</span><span class="p" data-group-id="7734133551-18">}</span><span class="w">

    </span><span class="p" data-group-id="7734133551-20">{</span><span class="o">^</span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="7734133551-20">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">collect_results</span><span class="p" data-group-id="7734133551-21">(</span><span class="w">
        </span><span class="nc">List</span><span class="o">.</span><span class="n">delete</span><span class="p" data-group-id="7734133551-22">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p" data-group-id="7734133551-22">)</span><span class="p">,</span><span class="w">
        </span><span class="n">work_ref</span><span class="p">,</span><span class="w">
        </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">add_result</span><span class="p" data-group-id="7734133551-23">(</span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="7734133551-23">)</span><span class="p">,</span><span class="w">
        </span><span class="n">timeout_ref</span><span class="w">
      </span><span class="p" data-group-id="7734133551-21">)</span><span class="w">

    </span><span class="p" data-group-id="7734133551-24">{</span><span class="ss">:DOWN</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="7734133551-24">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="k">if</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">member?</span><span class="p" data-group-id="7734133551-25">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="7734133551-25">)</span><span class="w"> </span><span class="k" data-group-id="7734133551-26">do</span><span class="w">
        </span><span class="c1"># Handling task termination. In this case, we simply delete the</span><span class="w">
        </span><span class="c1"># task from the list of tasks, and wait for other tasks to finish.</span><span class="w">
        </span><span class="n">collect_results</span><span class="p" data-group-id="7734133551-27">(</span><span class="nc">List</span><span class="o">.</span><span class="n">delete</span><span class="p" data-group-id="7734133551-28">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="7734133551-28">)</span><span class="p">,</span><span class="w"> </span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="7734133551-27">)</span><span class="w">
      </span><span class="k" data-group-id="7734133551-26">else</span><span class="w">
        </span><span class="n">collect_results</span><span class="p" data-group-id="7734133551-29">(</span><span class="n">tasks</span><span class="p">,</span><span class="w"> </span><span class="n">work_ref</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">timeout_ref</span><span class="p" data-group-id="7734133551-29">)</span><span class="w">
      </span><span class="k" data-group-id="7734133551-26">end</span><span class="w">
  </span><span class="k" data-group-id="7734133551-16">end</span><span class="w">
</span><span class="k" data-group-id="7734133551-15">end</span></code></pre>
<p>
This is mostly straightforward, with the major changes happening in lines 29-36. It’s worth mentioning that we’ll receive a <code class="inline">:DOWN</code> message even if the task doesn’t crash. However, this message will arrive after the response message has been sent back, so the master process will first handle the response message. Since we remove the task from the list, the subsequent <code class="inline">:DOWN</code> message of that task will be ignored. This is not super efficient, and we could have improved this by doing some extra bookkeeping and demonitoring the task after it returns, but I refrained from this for the sake of brevity.</p>
<p>
In any case, we can now test it. If I start <code class="inline">SupervisedTask.run</code>, I’ll see some errors logged (courtesy of <code class="inline">Logger</code>), but I’ll still get whatever is collected. You can also try it yourself. The code is available <a href="https://github.com/sasa1977/beyond_task_async">here</a>.</p>
<h2>
Reducing the boilerplate</h2>
<p>
As we moved to more complex patterns, our master process became way more involved. The plain async/await has only 12 lines of code, while the final implementation has 66. The master process is burdened with a lot of mechanics, such as keeping references, starting a timer message, and handling received messages. There’s a lot of potential to extract some of that boilerplate, so we can keep the master process more focused.</p>
<p>
There are different approaches to extracting the boilerplate. If a process has to behave in a special way, you can consider creating a generic OTP-like behaviour that powers the process. The concrete implementation then just has to fill in the blanks by providing necessary callback functions.</p>
<p>
However, in this particular case, I don’t think creating a behaviour is a good option. The thing is that the master process might already be powered by a behaviour, such as <code class="inline">GenServer</code> or <code class="inline">Phoenix.Channel</code>. If we implement our generic code as a behaviour, we can’t really combine it with another behaviour. Thus, we’ll always need to have one more process that starts all these tasks and collects their results. This may result in excessive message passing, and have an impact on performance.</p>
<p>
An alternative is to implement a helper module that can be used to start tasks and process task related messages. For example, we could have the following interface for starting tasks:</p>
<pre><code class="highlight makeup elixir"><span class="n">runner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">TaskRunner</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="3097338918-1">(</span><span class="w">
  </span><span class="p" data-group-id="3097338918-2">[</span><span class="w">
    </span><span class="p" data-group-id="3097338918-3">{</span><span class="ss">:supervisor1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3097338918-4">{</span><span class="nc">SomeModule</span><span class="p">,</span><span class="w"> </span><span class="ss">:some_function</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p" data-group-id="3097338918-4">}</span><span class="p" data-group-id="3097338918-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="3097338918-5">{</span><span class="ss">:supervisor2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3097338918-6">{</span><span class="nc">AnotherModule</span><span class="p">,</span><span class="w"> </span><span class="ss">:some_function</span><span class="p">,</span><span class="w"> </span><span class="n">other_args</span><span class="p" data-group-id="3097338918-6">}</span><span class="p" data-group-id="3097338918-5">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="3097338918-7">{</span><span class="ss">:supervisor3</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="3097338918-8">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="3097338918-8">end</span><span class="p" data-group-id="3097338918-7">}</span><span class="p">,</span><span class="w">
    </span><span class="c1"># ...</span><span class="w">
  </span><span class="p" data-group-id="3097338918-2">]</span><span class="p">,</span><span class="w">
  </span><span class="n">timeout</span><span class="w">
</span><span class="p" data-group-id="3097338918-1">)</span></code></pre>
<p>
Under the hood, <code class="inline">TaskRunner</code> would start tasks under given supervisors, setup work and timer references, and send the timeout message to the caller process. By allowing different tasks to run under different supervisors, we have more flexibility. In particular, this allows us to start different tasks on different nodes.</p>
<p>
The responsibility of receiving messages now lies on the caller process. It has to receive a message either via <code class="inline">receive</code> or for example in the <code class="inline">handle_info</code> callback. When the process gets a message, it has to first pass it to <code class="inline">TaskRunner.handle_message</code> which will return one of the following:</p>
<ul>
  <li>
<code class="inline">nil</code> - a message is not task runner specific, feel free to handle it yourself  </li>
  <li>
<code class="inline">{{:ok, result}, runner}</code> - a result arrived from a task  </li>
  <li>
<code class="inline">{{:task_error, reason}, runner}</code> - a task has crashed  </li>
  <li>
<code class="inline">{:timeout, runner}</code> - timeout has occurred  </li>
</ul>
<p>
Finally, we’ll introduce a <code class="inline">TaskRunner.done?/1</code> function, which can be used to determine whether all tasks have finished.</p>
<p>
This is all we need to make various decision in the client process. The previous example can now be rewritten as:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">TaskRunnerClient</span><span class="w"> </span><span class="k" data-group-id="2036687121-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="w"> </span><span class="k" data-group-id="2036687121-2">do</span><span class="w">
    </span><span class="ss">:random</span><span class="o">.</span><span class="n">seed</span><span class="p" data-group-id="2036687121-3">(</span><span class="ss">:os</span><span class="o">.</span><span class="n">timestamp</span><span class="p" data-group-id="2036687121-3">)</span><span class="w">
    </span><span class="nc">Task.Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="2036687121-4">(</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="ss">:task_supervisor</span><span class="p" data-group-id="2036687121-4">)</span><span class="w">

    </span><span class="mi">1</span><span class="o">.</span><span class="o">.</span><span class="mi">10</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="2036687121-5">(</span><span class="k" data-group-id="2036687121-6">fn</span><span class="p" data-group-id="2036687121-7">(</span><span class="bp">_</span><span class="p" data-group-id="2036687121-7">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:random</span><span class="o">.</span><span class="n">uniform</span><span class="p" data-group-id="2036687121-8">(</span><span class="mi">1000</span><span class="p" data-group-id="2036687121-8">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="k" data-group-id="2036687121-6">end</span><span class="p" data-group-id="2036687121-5">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="2036687121-9">(</span><span class="o">&amp;</span><span class="p" data-group-id="2036687121-10">{</span><span class="ss">:task_supervisor</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2036687121-11">{</span><span class="nc">Computation</span><span class="p">,</span><span class="w"> </span><span class="ss">:run</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2036687121-12">[</span><span class="ni">&amp;1</span><span class="p" data-group-id="2036687121-12">]</span><span class="p" data-group-id="2036687121-11">}</span><span class="p" data-group-id="2036687121-10">}</span><span class="p" data-group-id="2036687121-9">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">TaskRunner</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="2036687121-13">(</span><span class="mi">400</span><span class="p" data-group-id="2036687121-13">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">handle_messages</span><span class="p" data-group-id="2036687121-14">(</span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">new</span><span class="p" data-group-id="2036687121-14">)</span><span class="w">
  </span><span class="k" data-group-id="2036687121-2">end</span><span class="w">


  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">handle_messages</span><span class="p" data-group-id="2036687121-15">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p" data-group-id="2036687121-15">)</span><span class="w"> </span><span class="k" data-group-id="2036687121-16">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="nc">TaskRunner</span><span class="o">.</span><span class="n">done?</span><span class="p" data-group-id="2036687121-17">(</span><span class="n">runner</span><span class="p" data-group-id="2036687121-17">)</span><span class="w"> </span><span class="k" data-group-id="2036687121-18">do</span><span class="w">
      </span><span class="p" data-group-id="2036687121-19">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="p" data-group-id="2036687121-20">(</span><span class="n">aggregator</span><span class="p" data-group-id="2036687121-20">)</span><span class="p" data-group-id="2036687121-19">}</span><span class="w">
    </span><span class="k" data-group-id="2036687121-18">else</span><span class="w">
      </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="2036687121-21">do</span><span class="w">
        </span><span class="n">msg</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="k">case</span><span class="w"> </span><span class="nc">TaskRunner</span><span class="o">.</span><span class="n">handle_message</span><span class="p" data-group-id="2036687121-22">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="2036687121-22">)</span><span class="w"> </span><span class="k" data-group-id="2036687121-23">do</span><span class="w">
            </span><span class="no">nil</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">handle_messages</span><span class="p" data-group-id="2036687121-24">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p" data-group-id="2036687121-24">)</span><span class="w">

            </span><span class="p" data-group-id="2036687121-25">{</span><span class="p" data-group-id="2036687121-26">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="2036687121-26">}</span><span class="p">,</span><span class="w"> </span><span class="n">runner</span><span class="p" data-group-id="2036687121-25">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
              </span><span class="n">handle_messages</span><span class="p" data-group-id="2036687121-27">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">add_result</span><span class="p" data-group-id="2036687121-28">(</span><span class="n">aggregator</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="2036687121-28">)</span><span class="p" data-group-id="2036687121-27">)</span><span class="w">

            </span><span class="p" data-group-id="2036687121-29">{</span><span class="p" data-group-id="2036687121-30">{</span><span class="ss">:task_error</span><span class="p">,</span><span class="w"> </span><span class="c">_reason</span><span class="p" data-group-id="2036687121-30">}</span><span class="p">,</span><span class="w"> </span><span class="n">runner</span><span class="p" data-group-id="2036687121-29">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
              </span><span class="n">handle_messages</span><span class="p" data-group-id="2036687121-31">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="n">aggregator</span><span class="p" data-group-id="2036687121-31">)</span><span class="w">

            </span><span class="p" data-group-id="2036687121-32">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="c">_runner</span><span class="p" data-group-id="2036687121-32">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
              </span><span class="p" data-group-id="2036687121-33">{</span><span class="ss">:timeout</span><span class="p">,</span><span class="w"> </span><span class="nc">Aggregator</span><span class="o">.</span><span class="n">value</span><span class="p" data-group-id="2036687121-34">(</span><span class="n">aggregator</span><span class="p" data-group-id="2036687121-34">)</span><span class="p" data-group-id="2036687121-33">}</span><span class="w">
          </span><span class="k" data-group-id="2036687121-23">end</span><span class="w">
      </span><span class="k" data-group-id="2036687121-21">end</span><span class="w">
    </span><span class="k" data-group-id="2036687121-18">end</span><span class="w">
  </span><span class="k" data-group-id="2036687121-16">end</span><span class="w">
</span><span class="k" data-group-id="2036687121-1">end</span></code></pre>
<p>
This is less verbose than the previous version, and the receive loop is now focused only on handling of success, error, and timeout, without worrying how these situations are detected.</p>
<p>
The code is still more involved than the simple async/await pattern, but it offers more flexibility. You can support various scenarios, such as stopping on first success or reporting the timeout back to the user while letting the tasks finish their jobs. If this flexibility is not important for your particular scenarios, then this approach is an overkill, and async/await should do just fine.</p>
<p>
I will not describe the implementation of <code class="inline">TaskRunner</code> as it is mostly a refactoring of the code from <code class="inline">SupervisedTask</code>. You’re advised to try and implement it yourself as an exercise. A basic (definitely not complete or tested) take can be found <a href="https://github.com/sasa1977/beyond_task_async/blob/master/lib/task_runner.ex">here</a>.</p>
<h2>
Parting words</h2>
<p>
While this article focuses on tasks, in a sense they serve more as an example to illustrate concurrent thinking in Erlang.</p>
<p>
Stepping away from <code class="inline">Task.await</code> and receiving messages manually allowed the master process to be more flexible. Avoiding links between master and the tasks decoupled their lives, and gave us a better error isolation. Using monitors made it possible to detect failures and perform some special handling. Pushing everything to a helper module, without implementing a dedicated behaviour, gave us the generic code that can be used in different types of processes.</p>
<p>
These are in my opinion more important takeaways of this article. In the future the Elixir team may introduce additional support for tasks which will make most of these techniques unnecessary. But the underlying reasoning should be applicable in many other situations, not necessarily task-related.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2015, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/beyond_taskasync">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/beyond_taskasync.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Fri, 31 Jul 2015 00:00:00 +0000</pubDate></item><item><title>Speaking at ElixirConf EU</title><link>http://theerlangelist.com//article/elixirconf2015</link><description><![CDATA[<h1>Speaking at ElixirConf EU</h1>
<h4 class="right">2015-01-26</h4>

<div class="article-body">
<p>
I’m very excited that my <a href="http://www.elixirconf.eu/elixirconf2015/saa-juric">talk on high-availability</a> got accepted for the <a href="http://www.elixirconf.eu/">first European Elixir conference</a>.</p>
<p>
For the past three years, I have been evangelizing Erlang and Elixir here in Croatia, at our local annual <a href="http://2014.webcampzg.org/">WebCampZg</a> event. In addition, I invested a lot of effort writing the <a href="https://www.manning.com/books/elixir-in-action-second-edition?a_aid=sjuric">book on Elixir</a> which is now in its final stages.</p>
<p>
All this work has been motivated by my own positive experience using Erlang and Elixir in production. Some four years ago, I started using Erlang almost by chance, and it helped me immensely in building a long-polling based HTTP push server together with the supporting data provider system. The more I worked with Erlang, the more I got fascinated with how useful it is when it comes to building server-side systems. Ultimately, it became my tool of choice for development of complex backend systems that need to provide reliable service.</p>
<p>
I reached for Elixir two years ago, when I started this blog, hoping it will help me showcase the magic behind Erlang to OO developers. I was really surprised with the level of maturity and integration with Erlang, even at that early stage. Pretty soon, I started introducing Elixir in production, and discovered it further boosts my productivity.</p>
<p>
Two years later, Elixir 1.0 is out, the ecosystem is growing, and we have great libraries such as <a href="http://www.phoenixframework.org/">Phoenix</a> and <a href="https://github.com/elixir-lang/ecto">Ecto</a>, leveraging Elixir to further improve developer productivity.</p>
<p>
Moreover, there’s a lot of learning material available. In addition to excellent online <a href="https://elixir-lang.org/getting-started/introduction.html">getting started guides</a> and <a href="https://hexdocs.pm/elixir/">reference</a>, there are <a href="http://shop.oreilly.com/product/0636920030584.do">three</a> <a href="https://pragprog.com/book/elixir/programming-elixir">published</a> <a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir">books</a>, with <a href="https://www.manning.com/books/elixir-in-action-second-edition?a_aid=sjuric">Elixir in Action</a> almost finished, and <a href="http://www.exotpbook.com/">two</a> <a href="https://www.packtpub.com/application-development/elixir-cookbook">more</a> in the making. The present looks great, and the future is even more promising. These are exciting times, and a great chance to jump aboard and start using Elixir and Erlang.</p>
<p>
So if you happen to be interested, <a href="http://www.elixirconf.eu/#register">grab a ticket for ElixirConfEU</a> while it’s available. Hope I’ll see you there!</p>
<p>
While I’m in the announcement mode, I’ll also mention that we’re starting a local FP group here in Zagreb, Croatia. Details about the introductory drinkup can be found <a href="http://www.meetup.com/lambdazg/events/219980288/">here</a>, so if you happen to live nearby, come and visit us for some functional chat.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2015, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/elixirconf2015">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/elixirconf2015.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 26 Jan 2015 00:00:00 +0000</pubDate></item><item><title>Conway&apos;s Game of Life in Elixir</title><link>http://theerlangelist.com//article/conway</link><description><![CDATA[<h1>Conway&#39;s Game of Life in Elixir</h1>
<h4 class="right">2014-11-24</h4>

<div class="article-body">
<p>
About a month ago, on <a href="http://elixirquiz.github.io/index.html">Elixir Quiz</a> site there was a <a href="http://elixirquiz.github.io/2014-11-01-game-of-life.html">Conway’s Game of Life challenge</a>. While I didn’t find the time to participate in the challenge, I played with the problem recently, and found it very interesting.</p>
<p>
So in this post, I’m going to break down <a href="https://gist.github.com/sasa1977/6877c52c3c35c2c03c82">my solution to the problem</a>. If you’re not familiar with Game of Life rules, you can take a quick look <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life#Rules">here</a>.</p>
<p>
My solution is simplified in that I deal only with square grids. It’s not very hard to extend it to work for any rectangle, but I wanted to keep things simple.</p>
<h2>
Functional abstraction</h2>
<p>
The whole game revolves around the grid of cells which are in some state (dead or alive), and there are clear rules that determine the next state of each cell based on the current state of its neighbours. Thus, I’ve implemented the <code class="inline">Conway.Grid</code> module that models the grid. Let’s see how the module will be used.</p>
<p>
The initial grid can be created with <code class="inline">Conway.Grid.new/1</code>:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># Creates 5x5 grid with random values</span><span class="w">
</span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Conway.Grid</span><span class="o">.</span><span class="n">new</span><span class="p" data-group-id="4147705263-1">(</span><span class="mi">5</span><span class="p" data-group-id="4147705263-1">)</span><span class="w">

</span><span class="c1"># Creates grid from the given cell data</span><span class="w">
</span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Conway.Grid</span><span class="o">.</span><span class="n">new</span><span class="p" data-group-id="4147705263-2">(</span><span class="p" data-group-id="4147705263-3">[</span><span class="w">
  </span><span class="p" data-group-id="4147705263-4">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="4147705263-4">]</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="4147705263-5">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="4147705263-5">]</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="4147705263-6">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="4147705263-6">]</span><span class="w">
</span><span class="p" data-group-id="4147705263-3">]</span><span class="p" data-group-id="4147705263-2">)</span></code></pre>
<p>
As can be deducted from the second example, a cell state can be either zero (not alive) or one (alive).</p>
<p>
Once the grid is instantiated, we can move it a step forward with <code class="inline">Conway.Grid.next/1</code>:</p>
<pre><code class="highlight makeup elixir"><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Conway.Grid</span><span class="o">.</span><span class="n">next</span><span class="p" data-group-id="9600227032-1">(</span><span class="n">grid</span><span class="p" data-group-id="9600227032-1">)</span></code></pre>
<p>
Finally, we can query grid’s size, and the value of each cell:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Conway.Grid</span><span class="o">.</span><span class="n">size</span><span class="p" data-group-id="1880167717-1">(</span><span class="n">grid</span><span class="p" data-group-id="1880167717-1">)</span><span class="w">

</span><span class="c1"># Returns 0 or 1 for the cell at the given location</span><span class="w">
</span><span class="nc">Conway.Grid</span><span class="o">.</span><span class="n">cell_status</span><span class="p" data-group-id="1880167717-2">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="1880167717-2">)</span></code></pre>
<p>
This is all we need to manipulate the grid and somehow display it.</p>
<p>
This is a simple decoupling technique. The game logic is contained in the single module, but the “driving” part of the game, i.e. the code that repeatedly moves the game forward, is left out.</p>
<p>
This allows us to use the core game module in different contexts. In my example, I’m using <code class="inline">Conway.Grid</code> <a href="https://gist.github.com/sasa1977/6877c52c3c35c2c03c82#file-conway-ex-L100-L125">from a simplistic terminal client</a>, but it’s easy to use the module from a <code class="inline">GenServer</code> for example to push updates to various connected clients, or from unit tests to verify that state transition works properly.</p>
<p>
Another nice benefit of this approach is that we can use <code class="inline">:erlang.term_to_binary/1</code> to serialize the structure and persist the grid state, and then later deserialize it and resume playing the grid.</p>
<p>
This is what I like to call a functional abstraction. Notice in previous examples how we use <code class="inline">Conway.Grid</code> without knowing its internal representation. The module abstracts away its internal details. In particular, as clients, we don’t care what data type is used for the module. All we know that creator and updater functions return a “grid”, and all functions from <code class="inline">Conway.Grid</code> know how to work with that grid.</p>
<p>
The module thus abstracts some concept, and does so relying on a pure functional (immutable) data structure. Hence, a functional abstraction.</p>
<p>
<strong>Note</strong>: Frequently, the term <strong>type</strong> is used for this. I’m not particular fan of this terminology. To me, the only true Elixir types are <a href="http://www.erlang.org/doc/reference_manual/data_types.html">the ones supported by BEAM</a>. All others, such as <code class="inline">HashDict</code>, <code class="inline">HashSet</code>, <code class="inline">Range</code>, Erlang’s <code class="inline">:gb_trees</code>, and even structs, are somehow composed from those basic types.</p>
<h2>
Choosing the data representation</h2>
<p>
<strong>Update:</strong> As Greg and leikind pointed out in comments, the approach I’m taking here is neither efficient nor flexible, because I’m keeping and processing all cells, instead of dealing only with live ones. You can find the alternative version, where only live cells are kept in a <code class="inline">HashSet</code> <a href="https://gist.github.com/sasa1977/7d101a5698edfd6b0dc9">here</a>. The nice thing is that the change was simple, due to abstraction of the <code class="inline">Conway.Grid</code>. The module interface remained the same.</p>
<p>
In any case, let’s start implementing <code class="inline">Conway.Grid</code>. The most important decision is how to represent the grid data. Given the game rules, we have following needs:</p>
<ul>
  <li>
random access to cells (their states)  </li>
  <li>
incremental building of the grid  </li>
</ul>
<p>
We need the first property to access neighbour cells when determining the next state of each cell. The second property is needed since in each step we fully rebuild the grid based on the current state of each cell.</p>
<p>
In BEAM, tuples are a good fit for random access (which is O(1) operation), but they are poor for incremental building. Modifying a tuple <a href="http://www.erlang.org/doc/efficiency_guide/commoncaveats.html#id61125">(almost always) results in (shallow) copying of all tuple elements</a>. This can hurt performance and increase memory usage.</p>
<p>
In contrast, lists are crappy for random access, but they are efficient for incremental building, if we’re either prepending new elements to the head, or building the list in a body-recursive way.</p>
<p>
However, we can use different approaches in different situations. In particular, we can:</p>
<ul>
  <li>
Maintain a 2D grid as a tuple of tuples. This gives us an O(1) random access complexity.  </li>
  <li>
Build a new grid as a lists of lists. Once the new grid is built, convert it to tuple of tuples via <code class="inline">List.to_tuple/1</code>.  </li>
</ul>
<p>
<code class="inline">List.to_tuple/1</code> will be efficient (though still O(n)), since it is implemented in C, and does it’s job by <a href="https://github.com/erlang/otp/blob/743ed31108ee555db18d9833186865e85e34333e/erts/emulator/beam/bif.c#L3424-L3431">preallocating the tuple and populating it from the list</a>. Thus, we avoid extra copying of tuples.</p>
<p>
Performance wise, this is probably not the optimal implementation, but I think it’s a reasonable first attempt that still keeps the code simple and clear.</p>
<p>
So to recap, out grid will be implemented as the tuple of tuples:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="9483284371-1">{</span><span class="w">
  </span><span class="p" data-group-id="9483284371-2">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="9483284371-2">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="9483284371-3">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="9483284371-3">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="9483284371-4">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="9483284371-4">}</span><span class="w">
</span><span class="p" data-group-id="9483284371-1">}</span></code></pre>
<p>
This is all the data we need, since we can efficiently derive the grid size from the data via <code class="inline">Kernel.tuple_size/1</code>. It’s still worth making our <code class="inline">Conway.Grid</code> a struct, so we can gain pattern matching, possible polymorphism, and easier extensibility.</p>
<p>
Hence, the skeleton of the module will look like:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Conway.Grid</span><span class="w"> </span><span class="k" data-group-id="8201669216-1">do</span><span class="w">
  </span><span class="kd">defstruct</span><span class="w"> </span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="8201669216-1">end</span></code></pre>
<p>
Now we can start implementing the module.</p>
<h2>
Constructing the grid</h2>
<p>
Recall from usage examples that our “constructor” function is overloaded. It either takes a grid dimension and creates the randomly populated grid, or it takes a list of lists with prepopulated data.</p>
<p>
Let’s solve the latter case first:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">new</span><span class="p" data-group-id="0235528477-1">(</span><span class="n">data</span><span class="p" data-group-id="0235528477-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_list</span><span class="p" data-group-id="0235528477-2">(</span><span class="n">data</span><span class="p" data-group-id="0235528477-2">)</span><span class="w"> </span><span class="k" data-group-id="0235528477-3">do</span><span class="w">
  </span><span class="p" data-group-id="0235528477-4">%</span><span class="nc" data-group-id="0235528477-4">Conway.Grid</span><span class="p" data-group-id="0235528477-4">{</span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="n">list_to_data</span><span class="p" data-group-id="0235528477-5">(</span><span class="n">data</span><span class="p" data-group-id="0235528477-5">)</span><span class="p" data-group-id="0235528477-4">}</span><span class="w">
</span><span class="k" data-group-id="0235528477-3">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">list_to_data</span><span class="p" data-group-id="0235528477-6">(</span><span class="n">data</span><span class="p" data-group-id="0235528477-6">)</span><span class="w"> </span><span class="k" data-group-id="0235528477-7">do</span><span class="w">
  </span><span class="n">data</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="0235528477-8">(</span><span class="o">&amp;</span><span class="nc">List</span><span class="o">.</span><span class="n">to_tuple</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="0235528477-8">)</span><span class="w">     </span><span class="c1"># convert every inner list</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">List</span><span class="o">.</span><span class="n">to_tuple</span><span class="w">                  </span><span class="c1"># convert the outer list</span><span class="w">
</span><span class="k" data-group-id="0235528477-7">end</span></code></pre>
<p>
Now, we can do the random population. We’ll first implement a helper generic function for creating the grid data:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">new_data</span><span class="p" data-group-id="5513484771-1">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">producer_fun</span><span class="p" data-group-id="5513484771-1">)</span><span class="w"> </span><span class="k" data-group-id="5513484771-2">do</span><span class="w">
  </span><span class="k">for</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="5513484771-3">(</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5513484771-3">)</span><span class="w"> </span><span class="k" data-group-id="5513484771-4">do</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="5513484771-5">(</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5513484771-5">)</span><span class="w"> </span><span class="k" data-group-id="5513484771-6">do</span><span class="w">
      </span><span class="n">producer_fun</span><span class="o">.</span><span class="p" data-group-id="5513484771-7">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="5513484771-7">)</span><span class="w">
    </span><span class="k" data-group-id="5513484771-6">end</span><span class="w">
  </span><span class="k" data-group-id="5513484771-4">end</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">list_to_data</span><span class="w">
</span><span class="k" data-group-id="5513484771-2">end</span></code></pre>
<p>
Here, we take the desired size, and produce a square list of lists, calling the <code class="inline">producer_fun</code> lambda for each element. Then, we just pass it to <code class="inline">list_to_data/1</code> to convert to a tuple of tuples. This genericity of <code class="inline">new_data/2</code> will allow us to reuse the code when moving the grid to the next state.</p>
<p>
For the moment, we can implement the second clause of <code class="inline">new/1</code>:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">new</span><span class="p" data-group-id="3981201672-1">(</span><span class="n">size</span><span class="p" data-group-id="3981201672-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="3981201672-2">(</span><span class="n">size</span><span class="p" data-group-id="3981201672-2">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k" data-group-id="3981201672-3">do</span><span class="w">
  </span><span class="p" data-group-id="3981201672-4">%</span><span class="nc" data-group-id="3981201672-4">Conway.Grid</span><span class="p" data-group-id="3981201672-4">{</span><span class="w">
    </span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="n">new_data</span><span class="p" data-group-id="3981201672-5">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="3981201672-6">fn</span><span class="p" data-group-id="3981201672-7">(</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="3981201672-7">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:random</span><span class="o">.</span><span class="n">uniform</span><span class="p" data-group-id="3981201672-8">(</span><span class="mi">2</span><span class="p" data-group-id="3981201672-8">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k" data-group-id="3981201672-6">end</span><span class="p" data-group-id="3981201672-5">)</span><span class="w">
  </span><span class="p" data-group-id="3981201672-4">}</span><span class="w">
</span><span class="k" data-group-id="3981201672-3">end</span></code></pre>
<p>
Next, let’s implement two getter functions for retrieving the grid size and the state of each cell:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">size</span><span class="p" data-group-id="1057026839-1">(</span><span class="p" data-group-id="1057026839-2">%</span><span class="nc" data-group-id="1057026839-2">Conway.Grid</span><span class="p" data-group-id="1057026839-2">{</span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="n">data</span><span class="p" data-group-id="1057026839-2">}</span><span class="p" data-group-id="1057026839-1">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">tuple_size</span><span class="p" data-group-id="1057026839-3">(</span><span class="n">data</span><span class="p" data-group-id="1057026839-3">)</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">cell_status</span><span class="p" data-group-id="1057026839-4">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="1057026839-4">)</span><span class="w"> </span><span class="k" data-group-id="1057026839-5">do</span><span class="w">
  </span><span class="n">grid</span><span class="o">.</span><span class="n">data</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">elem</span><span class="p" data-group-id="1057026839-6">(</span><span class="n">y</span><span class="p" data-group-id="1057026839-6">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">elem</span><span class="p" data-group-id="1057026839-7">(</span><span class="n">x</span><span class="p" data-group-id="1057026839-7">)</span><span class="w">
</span><span class="k" data-group-id="1057026839-5">end</span></code></pre>
<h2>
Shifting the state</h2>
<p>
The only thing remaining is to move the grid to the next state. Let’s start with the interface function:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">next</span><span class="p" data-group-id="7193688670-1">(</span><span class="n">grid</span><span class="p" data-group-id="7193688670-1">)</span><span class="w"> </span><span class="k" data-group-id="7193688670-2">do</span><span class="w">
  </span><span class="p" data-group-id="7193688670-3">%</span><span class="nc" data-group-id="7193688670-3">Conway.Grid</span><span class="p" data-group-id="7193688670-3">{</span><span class="n">grid</span><span class="w"> </span><span class="o">|</span><span class="w">
    </span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="n">new_data</span><span class="p" data-group-id="7193688670-4">(</span><span class="n">size</span><span class="p" data-group-id="7193688670-5">(</span><span class="n">grid</span><span class="p" data-group-id="7193688670-5">)</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">next_cell_status</span><span class="p" data-group-id="7193688670-6">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;2</span><span class="p" data-group-id="7193688670-6">)</span><span class="p" data-group-id="7193688670-4">)</span><span class="w">
  </span><span class="p" data-group-id="7193688670-3">}</span><span class="w">
</span><span class="k" data-group-id="7193688670-2">end</span></code></pre>
<p>
As mentioned earlier, we reuse the existing <code class="inline">new_data/2</code> function. We just provide a different lambda which will generate new cell states based on the current grid state.</p>
<p>
Implementation of <code class="inline">next_cell_status/3</code> embeds the game rules:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">next_cell_status</span><span class="p" data-group-id="2917013507-1">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="2917013507-1">)</span><span class="w"> </span><span class="k" data-group-id="2917013507-2">do</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="p" data-group-id="2917013507-3">{</span><span class="n">cell_status</span><span class="p" data-group-id="2917013507-4">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="2917013507-4">)</span><span class="p">,</span><span class="w"> </span><span class="n">alive_neighbours</span><span class="p" data-group-id="2917013507-5">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="2917013507-5">)</span><span class="p" data-group-id="2917013507-3">}</span><span class="w"> </span><span class="k" data-group-id="2917013507-6">do</span><span class="w">
    </span><span class="p" data-group-id="2917013507-7">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2917013507-7">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p" data-group-id="2917013507-8">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="2917013507-8">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p" data-group-id="2917013507-9">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="2917013507-9">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p" data-group-id="2917013507-10">{</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="2917013507-10">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="k" data-group-id="2917013507-6">end</span><span class="w">
</span><span class="k" data-group-id="2917013507-2">end</span></code></pre>
<p>
Here I’ve resorted to a <code class="inline">case</code> branch, because I think it’s the most readable approach in this case. I’ve experimented with moving this branching to a separate multiclause, but then it was less clear what is being pattern-matched.</p>
<h2>
Counting alive neighbours</h2>
<p>
Now we move to the most complex part of the code. Calculating the number of alive neighbours. For this, we have to get the state of each surrounding cell, and count the number of those which are alive.</p>
<p>
In this example, I’ve decided to use the <code class="inline">for</code> comprehension, because it has nice support for multiple generators and rich filters.</p>
<p>
However, <code class="inline">for</code> emits results to a collectable, and we need a single integer (the count of alive neighbours). Therefore, <a href="https://gist.github.com/sasa1977/6877c52c3c35c2c03c82#file-conway-ex-L4-L25">I’ve implemented a simple sum collectable</a>. It allows us to collect an enumerable of numbers into an integer containing their sum.</p>
<p>
The idea is then to use <code class="inline">for</code> to filter all alive neighbours, emit value 1 for each such neighbour, and collect those 1s into a <code class="inline">Sum</code> instance:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">alive_neighbours</span><span class="p" data-group-id="9857498755-1">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">cell_x</span><span class="p">,</span><span class="w"> </span><span class="n">cell_y</span><span class="p" data-group-id="9857498755-1">)</span><span class="w"> </span><span class="k" data-group-id="9857498755-2">do</span><span class="w">
  </span><span class="c1"># 1. Iterate all x,y in -1..+1 area</span><span class="w">
  </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="9857498755-3">(</span><span class="n">cell_x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9857498755-3">)</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="9857498755-4">(</span><span class="n">cell_x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9857498755-4">)</span><span class="p">,</span><span class="w">
      </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="9857498755-5">(</span><span class="n">cell_y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9857498755-5">)</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="9857498755-6">(</span><span class="n">cell_y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9857498755-6">)</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="9857498755-7">(</span><span class="w">
        </span><span class="c1"># take only valid coordinates</span><span class="w">
        </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="9857498755-8">(</span><span class="n">size</span><span class="p" data-group-id="9857498755-9">(</span><span class="n">grid</span><span class="p" data-group-id="9857498755-9">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9857498755-8">)</span><span class="w"> </span><span class="ow">and</span><span class="w">
        </span><span class="n">y</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="o">.</span><span class="p" data-group-id="9857498755-10">(</span><span class="n">size</span><span class="p" data-group-id="9857498755-11">(</span><span class="n">grid</span><span class="p" data-group-id="9857498755-11">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9857498755-10">)</span><span class="w"> </span><span class="ow">and</span><span class="w">

        </span><span class="c1"># don&#39;t include the current cell</span><span class="w">
        </span><span class="p" data-group-id="9857498755-12">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cell_x</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cell_y</span><span class="p" data-group-id="9857498755-12">)</span><span class="w"> </span><span class="ow">and</span><span class="w">

        </span><span class="c1"># take only alive cells</span><span class="w">
        </span><span class="n">cell_status</span><span class="p" data-group-id="9857498755-13">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="9857498755-13">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="p" data-group-id="9857498755-7">)</span><span class="p">,</span><span class="w">
      </span><span class="c1"># collect to Sum</span><span class="w">
      </span><span class="ss">into</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9857498755-14">%</span><span class="nc" data-group-id="9857498755-14">Sum</span><span class="p" data-group-id="9857498755-14">{</span><span class="p" data-group-id="9857498755-14">}</span><span class="w">
  </span><span class="k" data-group-id="9857498755-15">do</span><span class="w">
    </span><span class="mi">1</span><span class="w">   </span><span class="c1"># add 1 for every alive neighbour</span><span class="w">
  </span><span class="k" data-group-id="9857498755-15">end</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Sum</span><span class="o">.</span><span class="n">value</span><span class="w">    </span><span class="c1"># get the sum value</span><span class="w">
</span><span class="k" data-group-id="9857498755-2">end</span></code></pre>
<p>
I did initial implementation of this with nested <code class="inline">Enum.reduce/3</code> and I wasn’t as pleased. This solution actually takes more LOC, but I find it easier to understand. There are many other ways of implementing this counting, but to me this approach seems pretty readable. YMMV of course.</p>
<p>
<strong>Update:</strong> Tallak Tveide rightfully asked why not just pipe the result of <code class="inline">for</code> into <code class="inline">Enum.sum/1</code> (note also that <code class="inline">Enum.count/1</code> also works). This will work, and quite possibly perform just fine. However, when I was first writing this particular function, I asked myself why would I want to create an intermediate enumerable just to count its size. This is why I made the <code class="inline">Sum</code> collectable. It’s probably over-engineering / micro-optimizing for this case, but I found it an interesting exercise. As an added benefit, I have a generic <code class="inline">Sum</code> collectable which I can use in any of my code whenever I need to count the number of filtered items.</p>
<p>
In any case, we’re done. The simple implementation of Conway’s Game of Life is finished. We have a nice functional abstraction and a basic terminal client. Give it a try on your machine. Just paste <a href="https://gist.github.com/sasa1977/6877c52c3c35c2c03c82">the complete code</a> into the <code class="inline">iex</code> shell, or run it with <code class="inline">elixir conway.ex</code>.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/conway">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/conway.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 24 Nov 2014 00:00:00 +0000</pubDate></item><item><title>Understanding Elixir Macros, Part 6 - In-place Code Generation</title><link>http://theerlangelist.com//article/macros_6</link><description><![CDATA[<h1>Understanding Elixir Macros, Part 6 - In-place Code Generation</h1>
<h4 class="right">2014-07-06</h4>

<div class="article-body">
<p>
Today’s post is the last one in the macro series. Before starting, I’d like to extend kudos to <a href="https://twitter.com/BjoernRochel">Björn Rochel</a> who already improved on <code class="inline">deftraceable</code> macro in his <a href="https://github.com/BjRo/apex">Apex</a> library. Björn discovered that the blog version of <code class="inline">deftraceable</code> doesn’t handle default args (<code class="inline">arg \\ def_value</code>) properly, and <a href="https://github.com/BjRo/apex/blob/ca3cfbcf4473a4314d8dfa7f4bed610be652a03b/lib/apex/awesome_def.ex#L57-L59">implemented a fix</a>.</p>
<p>
In the meantime, let’s wrap up this macro saga. In today’s post, probably the most involved one in the entire series, I’m going to discuss some aspects of an in-place code generation, and the consequences it may have on our macros.</p>
<h2>
Generating code in the module</h2>
<p>
As I mentioned way back in <a href="macros_1">part 1</a>, macros are not the only meta-programming mechanism in Elixir. It is also possible to generate the code directly in the module. To refresh your memory, let’s see the example:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Fsm</span><span class="w"> </span><span class="k" data-group-id="1164738019-1">do</span><span class="w">
  </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1164738019-2">[</span><span class="w">
    </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1164738019-3">{</span><span class="ss">:pause</span><span class="p">,</span><span class="w"> </span><span class="ss">:paused</span><span class="p" data-group-id="1164738019-3">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1164738019-4">{</span><span class="ss">:stop</span><span class="p">,</span><span class="w"> </span><span class="ss">:stopped</span><span class="p" data-group-id="1164738019-4">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">paused</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1164738019-5">{</span><span class="ss">:resume</span><span class="p">,</span><span class="w"> </span><span class="ss">:running</span><span class="p" data-group-id="1164738019-5">}</span><span class="w">
  </span><span class="p" data-group-id="1164738019-2">]</span><span class="w">

  </span><span class="c1"># Dynamically generating functions directly in the module</span><span class="w">
  </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="1164738019-6">{</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1164738019-7">{</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p" data-group-id="1164738019-7">}</span><span class="p" data-group-id="1164738019-6">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="k" data-group-id="1164738019-8">do</span><span class="w">
    </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="1164738019-9">(</span><span class="n">action</span><span class="p" data-group-id="1164738019-9">)</span><span class="p" data-group-id="1164738019-10">(</span><span class="k">unquote</span><span class="p" data-group-id="1164738019-11">(</span><span class="n">state</span><span class="p" data-group-id="1164738019-11">)</span><span class="p" data-group-id="1164738019-10">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="1164738019-12">(</span><span class="n">next_state</span><span class="p" data-group-id="1164738019-12">)</span><span class="w">
  </span><span class="k" data-group-id="1164738019-8">end</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">initial</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:running</span><span class="w">
</span><span class="k" data-group-id="1164738019-1">end</span><span class="w">

</span><span class="nc">Fsm</span><span class="o">.</span><span class="n">initial</span><span class="w">
</span><span class="c1"># :running</span><span class="w">

</span><span class="nc">Fsm</span><span class="o">.</span><span class="n">initial</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Fsm</span><span class="o">.</span><span class="n">pause</span><span class="w">
</span><span class="c1"># :paused</span><span class="w">

</span><span class="nc">Fsm</span><span class="o">.</span><span class="n">initial</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Fsm</span><span class="o">.</span><span class="n">pause</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Fsm</span><span class="o">.</span><span class="n">pause</span><span class="w">
</span><span class="c1"># ** (FunctionClauseError) no function clause matching in Fsm.pause/1</span></code></pre>
<p>
Here, we’re dynamically generating function clauses directly in the module. This allows us to metaprogram against some input (in this case a keyword list), and generate the code without writing a dedicated macro.</p>
<p>
Notice in the code above how we use <code class="inline">unquote</code> to inject variables into function clause definition. This is perfectly in sync with how macros work. Keep in mind that <code class="inline">def</code> is also a macro, and a macro always receives it’s arguments quoted. Consequently, if you want a macro argument to receive the value of some variable, you must use <code class="inline">unquote</code> when passing that variable. It doesn’t suffice to simply call <code class="inline">def action</code>, because <code class="inline">def</code> macro receives a quoted reference to <code class="inline">action</code> rather than value that is in the variable <code class="inline">action</code>.</p>
<p>
You can of course call your own macros in such dynamic way, and the same principle will hold. There is an unexpected twist though - the order of evaluation is not what you might expect.</p>
<h2>
Order of expansion</h2>
<p>
As you’d expect, the module-level code (the code that isn’t a part of any function) is evaluated in the expansion phase. Somewhat surprisingly, this will happen after all macros (save for <code class="inline">def</code>) have been expanded. It’s easy to prove this:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyMacro</span><span class="w"> </span><span class="k" data-group-id="8590669779-1">do</span><span class="w">
          </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">my_macro</span><span class="w"> </span><span class="k" data-group-id="8590669779-2">do</span><span class="w">
            </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;my_macro called&quot;</span><span class="w">
            </span><span class="no">nil</span><span class="w">
          </span><span class="k" data-group-id="8590669779-2">end</span><span class="w">
        </span><span class="k" data-group-id="8590669779-1">end</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="8590669779-3">do</span><span class="w">
          </span><span class="kn">import</span><span class="w"> </span><span class="nc">MyMacro</span><span class="w">

          </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;module-level expression&quot;</span><span class="w">
          </span><span class="n">my_macro</span><span class="w">
        </span><span class="k" data-group-id="8590669779-3">end</span><span class="w">

</span><span class="c1"># Output:</span><span class="w">
</span><span class="n">my_macro</span><span class="w"> </span><span class="n">called</span><span class="w">
</span><span class="n">module</span><span class="o">-</span><span class="n">level</span><span class="w"> </span><span class="n">expression</span></code></pre>
<p>
See from the output how <code class="inline">mymacro</code> is called before <code class="inline">IO.puts</code> even though the corresponding <code class="inline">IO.puts</code> call precedes the macro call. This proves that compiler first resolves all “standard” macros. Then the module generation starts, and it is in this phase where module-level code, together with calls to <code class="inline">def</code> is being evaluated.</p>
<h2>
Module-level friendly macros</h2>
<p>
This has some important consequences on our own macros. For example, our <code class="inline">deftraceable</code> macro could also be invoked dynamically. However, this currently won’t work:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="4128584991-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="4128584991-1">end</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="4128584991-2">do</span><span class="w">
          </span><span class="kn">import</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">

          </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4128584991-3">[</span><span class="w">
            </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4128584991-4">{</span><span class="ss">:pause</span><span class="p">,</span><span class="w"> </span><span class="ss">:paused</span><span class="p" data-group-id="4128584991-4">}</span><span class="p">,</span><span class="w">
            </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4128584991-5">{</span><span class="ss">:stop</span><span class="p">,</span><span class="w"> </span><span class="ss">:stopped</span><span class="p" data-group-id="4128584991-5">}</span><span class="p">,</span><span class="w">
            </span><span class="ss">paused</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4128584991-6">{</span><span class="ss">:resume</span><span class="p">,</span><span class="w"> </span><span class="ss">:running</span><span class="p" data-group-id="4128584991-6">}</span><span class="w">
          </span><span class="p" data-group-id="4128584991-3">]</span><span class="w">

          </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="4128584991-7">{</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4128584991-8">{</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p" data-group-id="4128584991-8">}</span><span class="p" data-group-id="4128584991-7">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="k" data-group-id="4128584991-9">do</span><span class="w">
            </span><span class="c1"># Using deftraceable dynamically</span><span class="w">
            </span><span class="n">deftraceable</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4128584991-10">(</span><span class="n">action</span><span class="p" data-group-id="4128584991-10">)</span><span class="p" data-group-id="4128584991-11">(</span><span class="k">unquote</span><span class="p" data-group-id="4128584991-12">(</span><span class="n">state</span><span class="p" data-group-id="4128584991-12">)</span><span class="p" data-group-id="4128584991-11">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4128584991-13">(</span><span class="n">next_state</span><span class="p" data-group-id="4128584991-13">)</span><span class="w">
          </span><span class="k" data-group-id="4128584991-9">end</span><span class="w">
          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">initial</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:running</span><span class="w">
        </span><span class="k" data-group-id="4128584991-2">end</span><span class="w">

</span><span class="gt">** (MatchError) no match of right hand side value: :error
    expanding macro: Tracer.deftraceable/2
    iex:13: Test (module)</span></code></pre>
<p>
This falls with a somewhat cryptic and not very helpful error. So what went wrong? As mentioned in previous section, macros are expanded before in-place module evaluation starts. For us this means that <code class="inline">deftraceable</code> is called before the outer <code class="inline">for</code> comprehension is even evaluated.</p>
<p>
Consequently, <strong>even though it is invoked from a comprehension, <code class="inline">deftraceable</code> will be invoked exactly once</strong>. Moreover, since comprehension is not yet evaluated, inner variables <code class="inline">state</code>, <code class="inline">action</code>, and <code class="inline">next_state</code> are not present when our macro is called.</p>
<p>
How can this even work? Essentially, our macro will be called with quoted unquote - <code class="inline">head</code> and <code class="inline">body</code> will contain ASTs that represents <code class="inline">unquote(action)(unquote(state))</code> and <code class="inline">unquote(next_state)</code> respectively.</p>
<p>
Now, recall that in the current version of <code class="inline">deftraceable</code>, we make some assumptions about input in our macro. Here’s a sketch:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="1290167510-1">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="1290167510-1">)</span><span class="w"> </span><span class="k" data-group-id="1290167510-2">do</span><span class="w">
  </span><span class="c1"># Here, we are assuming how the input head looks like, and perform some</span><span class="w">
  </span><span class="c1"># AST transformations based on those assumptions.</span><span class="w">

  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1290167510-3">do</span><span class="w">
    </span><span class="n">...</span><span class="w">
  </span><span class="k" data-group-id="1290167510-3">end</span><span class="w">
</span><span class="k" data-group-id="1290167510-2">end</span></code></pre>
<p>
And that’s our problem. If we call <code class="inline">deftraceable</code> dynamically, while generating the code in-place, then such assumptions no longer hold.</p>
<h2>
Deferring code generation</h2>
<p>
When it comes to macro execution, it’s important to distinguish between the macro context and the caller’s context:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">my_macro</span><span class="w"> </span><span class="k" data-group-id="4766195738-1">do</span><span class="w">
  </span><span class="c1"># Macro context: the code here is a normal part of the macro, and runs when</span><span class="w">
  </span><span class="c1"># the macro is invoked.</span><span class="w">

  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="4766195738-2">do</span><span class="w">
    </span><span class="c1"># Caller&#39;s context: generated code that runs in place where the macro is</span><span class="w">
    </span><span class="c1"># invoked.</span><span class="w">
  </span><span class="k" data-group-id="4766195738-2">end</span></code></pre>
<p>
This is where things get a bit tricky. If we want to support module-level dynamic calls of our macros, we shouldn’t assume anything in the macro context. Instead, we should defer the code generation to the caller’s context.</p>
<p>
To say it in code:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="5533340379-1">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="5533340379-1">)</span><span class="w"> </span><span class="k" data-group-id="5533340379-2">do</span><span class="w">
  </span><span class="c1"># Macro context: we shouldn&#39;t assume anything about the input AST here</span><span class="w">

  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5533340379-3">do</span><span class="w">
    </span><span class="c1"># Caller&#39;s context: we should transfer input AST here, and then make our</span><span class="w">
    </span><span class="c1"># assumptions here.</span><span class="w">
  </span><span class="k" data-group-id="5533340379-3">end</span><span class="w">
</span><span class="k" data-group-id="5533340379-2">end</span></code></pre>
<p>
Why can we make assumptions in the caller’s context? Because this code will run after all macros have been expanded. For example, remember that even though our macro is invoked from inside a comprehension, it will be called only once. However, the code generated by our macro will run in the comprehension - once for each element.</p>
<p>
So this approach amounts to deferring the final code generation. Instead of immediately generating the target code, we generate intermediate module-level statements that will generate the final code. These intermediate statements will run at the latest possible moment of expansion, after all other macros have been resolved:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="8667642088-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">

  </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="8667642088-2">{</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8667642088-3">{</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p" data-group-id="8667642088-3">}</span><span class="p" data-group-id="8667642088-2">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="k" data-group-id="8667642088-4">do</span><span class="w">
    </span><span class="c1"># After deftraceable is expanded, here we&#39;ll get a plain code that</span><span class="w">
    </span><span class="c1"># generates target function. This code will be invoked once for</span><span class="w">
    </span><span class="c1"># every step of the for comprehension. At this point, we&#39;re in the</span><span class="w">
    </span><span class="c1"># caller&#39;s context, and have an access to state, action, and next_state</span><span class="w">
    </span><span class="c1"># variables and can properly generate corresponding function.</span><span class="w">
  </span><span class="k" data-group-id="8667642088-4">end</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="8667642088-1">end</span></code></pre>
<p>
Before implementing the solution, it’s important to note that this is not a universal pattern, and you should consider whether you really need this approach.</p>
<p>
If your macro is not meant to be used on a module-level, then you should probably avoid this technique. Otherwise, if your macro is called from inside function definition, and you move the generation to the caller’s context, you’ll essentially move the code execution from compile-time to run-time, which can affect performance.</p>
<p>
Moreover, even if your macro is running on a module-level, this technique won’t be necessary as long as you don’t make any assumptions about the input. For example, in <a href="macros_2">part 2</a>, we made a simulation of Plug’s <code class="inline">get</code> macro:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="7916033981-1">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="7916033981-1">)</span><span class="w"> </span><span class="k" data-group-id="7916033981-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="7916033981-3">do</span><span class="w">
    </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_match</span><span class="p" data-group-id="7916033981-4">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="7916033981-5">(</span><span class="n">route</span><span class="p" data-group-id="7916033981-5">)</span><span class="p">,</span><span class="w"> </span><span class="n">var!</span><span class="p" data-group-id="7916033981-6">(</span><span class="n">conn</span><span class="p" data-group-id="7916033981-6">)</span><span class="p" data-group-id="7916033981-4">)</span><span class="w"> </span><span class="k" data-group-id="7916033981-7">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="7916033981-8">(</span><span class="n">body</span><span class="p" data-group-id="7916033981-9">[</span><span class="ss">:do</span><span class="p" data-group-id="7916033981-9">]</span><span class="p" data-group-id="7916033981-8">)</span><span class="w">
    </span><span class="k" data-group-id="7916033981-7">end</span><span class="w">
  </span><span class="k" data-group-id="7916033981-3">end</span><span class="w">
</span><span class="k" data-group-id="7916033981-2">end</span></code></pre>
<p>
Even though this macro works on a module-level it doesn’t assume anything about the format of the AST, simply injecting input fragments in the caller’s context, sprinkling some boilerplate around. Of course, we’re expecting here that <code class="inline">body</code> will have a <code class="inline">:do</code> option, but we’re not assuming anything about the specific shape and format of <code class="inline">body[:do]</code> AST.</p>
<p>
To recap, if your macro is meant to be called on a module-level, this could be the general pattern:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">...</span><span class="w">
  </span><span class="c1"># Macro context:</span><span class="w">
  </span><span class="c1"># Feel free to do any preparations here, as long as you don&#39;t assume anything</span><span class="w">
  </span><span class="c1"># about the shape of the input AST</span><span class="w">

  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0128002421-1">do</span><span class="w">
    </span><span class="c1"># Caller&#39;s context:</span><span class="w">
    </span><span class="c1"># If you&#39;re analyzing and/or transforming input AST you should do it here.</span><span class="w">
  </span><span class="k" data-group-id="0128002421-1">end</span></code></pre>
<p>
Since the caller context is module-level, this deferred transformation will still take place in compilation time, so there will be no runtime performance penalties.</p>
<h2>
The solution</h2>
<p>
Given this discussion, the solution is relatively simple, but explaining it is fairly involved. So I’m going to start by showing you the end result (pay attention to comments):</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="9809173692-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="9809173692-2">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="9809173692-2">)</span><span class="w"> </span><span class="k" data-group-id="9809173692-3">do</span><span class="w">
    </span><span class="c1"># This is the most important change that allows us to correctly pass</span><span class="w">
    </span><span class="c1"># input AST to the caller&#39;s context. I&#39;ll explain how this works a</span><span class="w">
    </span><span class="c1"># bit later.</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="ss">bind_quoted</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9809173692-4">[</span><span class="w">
      </span><span class="ss">head</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="9809173692-5">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9809173692-5">)</span><span class="p">,</span><span class="w">
      </span><span class="ss">body</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="9809173692-6">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9809173692-6">)</span><span class="w">
    </span><span class="p" data-group-id="9809173692-4">]</span><span class="w"> </span><span class="k" data-group-id="9809173692-7">do</span><span class="w">
      </span><span class="c1"># Caller&#39;s context: we&#39;ll be generating the code from here</span><span class="w">

      </span><span class="c1"># Since the code generation is deferred to the caller context,</span><span class="w">
      </span><span class="c1"># we can now make our assumptions about the input AST.</span><span class="w">

      </span><span class="c1"># This code is mostly identical to the previous version</span><span class="w">
      </span><span class="c1">#</span><span class="w">
      </span><span class="c1"># Notice that these variables are now created in the caller&#39;s context.</span><span class="w">
      </span><span class="p" data-group-id="9809173692-8">{</span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">args_ast</span><span class="p" data-group-id="9809173692-8">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">name_and_args</span><span class="p" data-group-id="9809173692-9">(</span><span class="n">head</span><span class="p" data-group-id="9809173692-9">)</span><span class="w">
      </span><span class="p" data-group-id="9809173692-10">{</span><span class="n">arg_names</span><span class="p">,</span><span class="w"> </span><span class="n">decorated_args</span><span class="p" data-group-id="9809173692-10">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">decorate_args</span><span class="p" data-group-id="9809173692-11">(</span><span class="n">args_ast</span><span class="p" data-group-id="9809173692-11">)</span><span class="w">

      </span><span class="c1"># Completely identical to the previous version.</span><span class="w">
      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">postwalk</span><span class="p" data-group-id="9809173692-12">(</span><span class="n">head</span><span class="p">,</span><span class="w">
        </span><span class="k" data-group-id="9809173692-13">fn</span><span class="w">
          </span><span class="p" data-group-id="9809173692-14">(</span><span class="p" data-group-id="9809173692-15">{</span><span class="n">fun_ast</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">old_args</span><span class="p" data-group-id="9809173692-15">}</span><span class="p" data-group-id="9809173692-14">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="p" data-group-id="9809173692-16">(</span><span class="w">
            </span><span class="n">fun_ast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fun_name</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">old_args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">args_ast</span><span class="w">
          </span><span class="p" data-group-id="9809173692-16">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
            </span><span class="p" data-group-id="9809173692-17">{</span><span class="n">fun_ast</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">decorated_args</span><span class="p" data-group-id="9809173692-17">}</span><span class="w">
          </span><span class="p" data-group-id="9809173692-18">(</span><span class="n">other</span><span class="p" data-group-id="9809173692-18">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">other</span><span class="w">
      </span><span class="k" data-group-id="9809173692-13">end</span><span class="p" data-group-id="9809173692-12">)</span><span class="w">

      </span><span class="c1"># This code is completely identical to the previous version</span><span class="w">
      </span><span class="c1"># Note: however, notice that the code is executed in the same context</span><span class="w">
      </span><span class="c1"># as previous three expressions.</span><span class="w">
      </span><span class="c1">#</span><span class="w">
      </span><span class="c1"># Hence, the unquote(head) here references the head variable that is</span><span class="w">
      </span><span class="c1"># computed in this context, instead of macro context. The same holds for</span><span class="w">
      </span><span class="c1"># other unquotes that are occuring in the function body.</span><span class="w">
      </span><span class="c1">#</span><span class="w">
      </span><span class="c1"># This is the point of deferred code generation. Our macro generates</span><span class="w">
      </span><span class="c1"># this code, which then in turn generates the final code.</span><span class="w">
      </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9809173692-19">(</span><span class="n">head</span><span class="p" data-group-id="9809173692-19">)</span><span class="w"> </span><span class="k" data-group-id="9809173692-20">do</span><span class="w">
        </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">file</span><span class="w">
        </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">line</span><span class="w">
        </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">module</span><span class="w">

        </span><span class="n">function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9809173692-21">(</span><span class="n">fun_name</span><span class="p" data-group-id="9809173692-21">)</span><span class="w">
        </span><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9809173692-22">(</span><span class="n">arg_names</span><span class="p" data-group-id="9809173692-22">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="9809173692-23">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="9809173692-23">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="9809173692-24">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="9809173692-24">)</span><span class="w">

        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9809173692-25">(</span><span class="n">body</span><span class="p" data-group-id="9809173692-26">[</span><span class="ss">:do</span><span class="p" data-group-id="9809173692-26">]</span><span class="p" data-group-id="9809173692-25">)</span><span class="w">

        </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="9809173692-27">#{</span><span class="n">file</span><span class="si" data-group-id="9809173692-27">}</span><span class="s">(line </span><span class="si" data-group-id="9809173692-28">#{</span><span class="n">line</span><span class="si" data-group-id="9809173692-28">}</span><span class="s">)&quot;</span><span class="w">
        </span><span class="n">call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="9809173692-29">#{</span><span class="n">module</span><span class="si" data-group-id="9809173692-29">}</span><span class="s">.</span><span class="si" data-group-id="9809173692-30">#{</span><span class="n">function_name</span><span class="si" data-group-id="9809173692-30">}</span><span class="s">(</span><span class="si" data-group-id="9809173692-31">#{</span><span class="n">passed_args</span><span class="si" data-group-id="9809173692-31">}</span><span class="s">) = </span><span class="si" data-group-id="9809173692-32">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="9809173692-32">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="9809173692-33">#{</span><span class="n">loc</span><span class="si" data-group-id="9809173692-33">}</span><span class="s"> </span><span class="si" data-group-id="9809173692-34">#{</span><span class="n">call</span><span class="si" data-group-id="9809173692-34">}</span><span class="s">&quot;</span><span class="w">

        </span><span class="n">result</span><span class="w">
      </span><span class="k" data-group-id="9809173692-20">end</span><span class="w">
    </span><span class="k" data-group-id="9809173692-7">end</span><span class="w">
  </span><span class="k" data-group-id="9809173692-3">end</span><span class="w">

  </span><span class="c1"># Identical to the previous version, but functions are exported since they</span><span class="w">
  </span><span class="c1"># must be called from the caller&#39;s context.</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="9809173692-35">(</span><span class="p" data-group-id="9809173692-36">{</span><span class="ss">:when</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9809173692-37">[</span><span class="n">short_head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="9809173692-37">]</span><span class="p" data-group-id="9809173692-36">}</span><span class="p" data-group-id="9809173692-35">)</span><span class="w"> </span><span class="k" data-group-id="9809173692-38">do</span><span class="w">
    </span><span class="n">name_and_args</span><span class="p" data-group-id="9809173692-39">(</span><span class="n">short_head</span><span class="p" data-group-id="9809173692-39">)</span><span class="w">
  </span><span class="k" data-group-id="9809173692-38">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="9809173692-40">(</span><span class="n">short_head</span><span class="p" data-group-id="9809173692-40">)</span><span class="w"> </span><span class="k" data-group-id="9809173692-41">do</span><span class="w">
    </span><span class="nc">Macro</span><span class="o">.</span><span class="n">decompose_call</span><span class="p" data-group-id="9809173692-42">(</span><span class="n">short_head</span><span class="p" data-group-id="9809173692-42">)</span><span class="w">
  </span><span class="k" data-group-id="9809173692-41">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">decorate_args</span><span class="p" data-group-id="9809173692-43">(</span><span class="p" data-group-id="9809173692-44">[</span><span class="p" data-group-id="9809173692-44">]</span><span class="p" data-group-id="9809173692-43">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9809173692-45">{</span><span class="p" data-group-id="9809173692-46">[</span><span class="p" data-group-id="9809173692-46">]</span><span class="p">,</span><span class="p" data-group-id="9809173692-47">[</span><span class="p" data-group-id="9809173692-47">]</span><span class="p" data-group-id="9809173692-45">}</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">decorate_args</span><span class="p" data-group-id="9809173692-48">(</span><span class="n">args_ast</span><span class="p" data-group-id="9809173692-48">)</span><span class="w"> </span><span class="k" data-group-id="9809173692-49">do</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="9809173692-50">{</span><span class="n">arg_ast</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="9809173692-50">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">with_index</span><span class="p" data-group-id="9809173692-51">(</span><span class="n">args_ast</span><span class="p" data-group-id="9809173692-51">)</span><span class="w"> </span><span class="k" data-group-id="9809173692-52">do</span><span class="w">
      </span><span class="n">arg_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="9809173692-53">(</span><span class="ss">:&quot;arg</span><span class="si" data-group-id="9809173692-54">#{</span><span class="n">index</span><span class="si" data-group-id="9809173692-54">}</span><span class="ss">&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="9809173692-53">)</span><span class="w">

      </span><span class="n">full_arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9809173692-55">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="9809173692-56">(</span><span class="n">arg_ast</span><span class="p" data-group-id="9809173692-56">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9809173692-57">(</span><span class="n">arg_name</span><span class="p" data-group-id="9809173692-57">)</span><span class="w">
      </span><span class="k" data-group-id="9809173692-55">end</span><span class="w">

      </span><span class="p" data-group-id="9809173692-58">{</span><span class="n">arg_name</span><span class="p">,</span><span class="w"> </span><span class="n">full_arg</span><span class="p" data-group-id="9809173692-58">}</span><span class="w">
    </span><span class="k" data-group-id="9809173692-52">end</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">unzip</span><span class="w">
  </span><span class="k" data-group-id="9809173692-49">end</span><span class="w">
</span><span class="k" data-group-id="9809173692-1">end</span></code></pre>
<p>
Let’s try the macro:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="8607844948-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="8607844948-1">end</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="8607844948-2">do</span><span class="w">
          </span><span class="kn">import</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">

          </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8607844948-3">[</span><span class="w">
            </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8607844948-4">{</span><span class="ss">:pause</span><span class="p">,</span><span class="w"> </span><span class="ss">:paused</span><span class="p" data-group-id="8607844948-4">}</span><span class="p">,</span><span class="w">
            </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8607844948-5">{</span><span class="ss">:stop</span><span class="p">,</span><span class="w"> </span><span class="ss">:stopped</span><span class="p" data-group-id="8607844948-5">}</span><span class="p">,</span><span class="w">
            </span><span class="ss">paused</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8607844948-6">{</span><span class="ss">:resume</span><span class="p">,</span><span class="w"> </span><span class="ss">:running</span><span class="p" data-group-id="8607844948-6">}</span><span class="w">
          </span><span class="p" data-group-id="8607844948-3">]</span><span class="w">

          </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="8607844948-7">{</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8607844948-8">{</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p" data-group-id="8607844948-8">}</span><span class="p" data-group-id="8607844948-7">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="k" data-group-id="8607844948-9">do</span><span class="w">
            </span><span class="n">deftraceable</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8607844948-10">(</span><span class="n">action</span><span class="p" data-group-id="8607844948-10">)</span><span class="p" data-group-id="8607844948-11">(</span><span class="k">unquote</span><span class="p" data-group-id="8607844948-12">(</span><span class="n">state</span><span class="p" data-group-id="8607844948-12">)</span><span class="p" data-group-id="8607844948-11">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8607844948-13">(</span><span class="n">next_state</span><span class="p" data-group-id="8607844948-13">)</span><span class="w">
          </span><span class="k" data-group-id="8607844948-9">end</span><span class="w">
          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">initial</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:running</span><span class="w">
        </span><span class="k" data-group-id="8607844948-2">end</span><span class="w">

</span><span class="gp unselectable">iex(3)&gt; </span><span class="nc">Test</span><span class="o">.</span><span class="n">initial</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Test</span><span class="o">.</span><span class="n">pause</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Test</span><span class="o">.</span><span class="n">resume</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Test</span><span class="o">.</span><span class="n">stop</span><span class="w">

</span><span class="n">iex</span><span class="p" data-group-id="8607844948-14">(</span><span class="n">line</span><span class="w"> </span><span class="mi">15</span><span class="p" data-group-id="8607844948-14">)</span><span class="w"> </span><span class="nc">Elixir.Test</span><span class="o">.</span><span class="n">initial</span><span class="p" data-group-id="8607844948-15">(</span><span class="p" data-group-id="8607844948-15">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:running</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="8607844948-16">(</span><span class="n">line</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="8607844948-16">)</span><span class="w"> </span><span class="nc">Elixir.Test</span><span class="o">.</span><span class="n">pause</span><span class="p" data-group-id="8607844948-17">(</span><span class="ss">:running</span><span class="p" data-group-id="8607844948-17">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:paused</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="8607844948-18">(</span><span class="n">line</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="8607844948-18">)</span><span class="w"> </span><span class="nc">Elixir.Test</span><span class="o">.</span><span class="n">resume</span><span class="p" data-group-id="8607844948-19">(</span><span class="ss">:paused</span><span class="p" data-group-id="8607844948-19">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:running</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="8607844948-20">(</span><span class="n">line</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="8607844948-20">)</span><span class="w"> </span><span class="nc">Elixir.Test</span><span class="o">.</span><span class="n">stop</span><span class="p" data-group-id="8607844948-21">(</span><span class="ss">:running</span><span class="p" data-group-id="8607844948-21">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:stopped</span></code></pre>
<p>
As you can see, the change is not very complicated. We managed to keep most of our code intact, though we had to do some trickery with <code class="inline">quote bind_quoted: true</code> and <code class="inline">Macro.escape</code>:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="ss">bind_quoted</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6023382236-1">[</span><span class="w">
  </span><span class="ss">head</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="6023382236-2">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="6023382236-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">body</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="6023382236-3">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="6023382236-3">)</span><span class="w">
</span><span class="p" data-group-id="6023382236-1">]</span><span class="w"> </span><span class="k" data-group-id="6023382236-4">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="6023382236-4">end</span></code></pre>
<p>
Let’s take a closer look at what does it mean.</p>
<h2>
bind_quoted</h2>
<p>
Remember that our macro is generating a code that will generate the final code. Somewhere in the first-level generated code (the one returned by our macro), we need to place the following expression:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5402029007-1">(</span><span class="n">head</span><span class="p" data-group-id="5402029007-1">)</span><span class="w"> </span><span class="k" data-group-id="5402029007-2">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="5402029007-2">end</span></code></pre>
<p>
This expression will be invoked in the caller’s context (the client module), and its task is to generate the function. As mentioned in comments, it’s important to understand that <code class="inline">unquote(head)</code> here references the <code class="inline">head</code> variable that exists in the caller’s context. We’re not injecting a variable from the macro context, but the one that exists in the caller’s context.</p>
<p>
However, we can’t generate such expression with plain <code class="inline">quote</code>:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5502321057-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5502321057-2">(</span><span class="n">head</span><span class="p" data-group-id="5502321057-2">)</span><span class="w"> </span><span class="k" data-group-id="5502321057-3">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="5502321057-3">end</span><span class="w">
</span><span class="k" data-group-id="5502321057-1">end</span></code></pre>
<p>
Remember how <code class="inline">unquote</code> works. It injects the AST that is in the <code class="inline">head</code> variable in place of the <code class="inline">unquote</code> call. This is not what we want here. What we want is to generate the AST representing the call to <code class="inline">unquote</code> which will then be executed later, in the caller’s context, and reference the caller’s <code class="inline">head</code> variable.</p>
<p>
This can be done by providing <code class="inline">unquote: false</code> option:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="k" data-group-id="9875272307-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9875272307-2">(</span><span class="n">head</span><span class="p" data-group-id="9875272307-2">)</span><span class="w"> </span><span class="k" data-group-id="9875272307-3">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="9875272307-3">end</span><span class="w">
</span><span class="k" data-group-id="9875272307-1">end</span></code></pre>
<p>
Here, we will generate the code that represents <code class="inline">unquote</code> call. If this code is injected in proper place, where variable <code class="inline">head</code> exists, we’ll end up calling the <code class="inline">def</code> macro, passing whatever is in the <code class="inline">head</code> variable.</p>
<p>
So it seems that <code class="inline">unquote: false</code> is what we need, but there is a downside that we can’t access any variable from the macro context:</p>
<pre><code class="highlight makeup elixir"><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:bar</span><span class="w">
</span><span class="k">quote</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="k" data-group-id="2073591934-1">do</span><span class="w">
  </span><span class="k">unquote</span><span class="p" data-group-id="2073591934-2">(</span><span class="n">foo</span><span class="p" data-group-id="2073591934-2">)</span><span class="w">    </span><span class="c1"># &lt;- won&#39;t work because of unquote: false</span><span class="w">
</span><span class="k" data-group-id="2073591934-1">end</span></code></pre>
<p>
Using <code class="inline">unquote: false</code> effectively blocks immediate AST injection, and treats <code class="inline">unquote</code> as any other function call. Consequently, we can’t inject something into the target AST. And here’s where <code class="inline">bind_quoted</code> comes in handy. By providing <code class="inline">bind_quoted: bindings</code> we can disable immediate unquoting, while still binding whatever data we want to transfer to the caller’s context:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="ss">bind_quoted</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8438638309-1">[</span><span class="w">
  </span><span class="ss">foo</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="p">,</span><span class="w">
  </span><span class="ss">bar</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="p" data-group-id="8438638309-1">]</span><span class="w"> </span><span class="k" data-group-id="8438638309-2">do</span><span class="w">
  </span><span class="k">unquote</span><span class="p" data-group-id="8438638309-3">(</span><span class="n">whatever</span><span class="p" data-group-id="8438638309-3">)</span><span class="w">  </span><span class="c1"># &lt;- works like with unquote: false</span><span class="w">

  </span><span class="n">foo</span><span class="w">  </span><span class="c1"># &lt;- accessible due to bind_quoted</span><span class="w">
  </span><span class="n">bar</span><span class="w">  </span><span class="c1"># &lt;- accessible due to bind_quoted</span><span class="w">
</span><span class="k" data-group-id="8438638309-2">end</span></code></pre>
<h2>
Injecting the code vs transferring data</h2>
<p>
Another problem we’re facing is that the contents we’re passing from the macro to the caller’s context is by default <em>injected</em>, rather then transferred. So, whenever you do <code class="inline">unquote(some_ast)</code>, you’re injecting one AST fragment into another one you’re building with a <code class="inline">quote</code> expression.</p>
<p>
Occasionally, we want to <em>transfer</em> the data, instead of injecting it. Let’s see an example. Say we have some triplet, we want to transfer to the caller’s context</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9765454156-1">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="9765454156-1">}</span><span class="w">
</span><span class="p" data-group-id="9765454156-2">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="9765454156-2">}</span></code></pre>
<p>
Now, let’s try to transfer it using typical <code class="inline">unquote</code>:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0408924242-1">do</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="0408924242-2">(</span><span class="k">unquote</span><span class="p" data-group-id="0408924242-3">(</span><span class="n">data</span><span class="p" data-group-id="0408924242-3">)</span><span class="p" data-group-id="0408924242-2">)</span><span class="w"> </span><span class="k" data-group-id="0408924242-1">end</span><span class="w">
</span><span class="p" data-group-id="0408924242-4">{</span><span class="p" data-group-id="0408924242-5">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0408924242-6">[</span><span class="p" data-group-id="0408924242-6">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0408924242-7">[</span><span class="p" data-group-id="0408924242-8">{</span><span class="ss">:__aliases__</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0408924242-9">[</span><span class="ss">alias</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="0408924242-9">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0408924242-10">[</span><span class="ss">:IO</span><span class="p" data-group-id="0408924242-10">]</span><span class="p" data-group-id="0408924242-8">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:inspect</span><span class="p" data-group-id="0408924242-7">]</span><span class="p" data-group-id="0408924242-5">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0408924242-11">[</span><span class="p" data-group-id="0408924242-11">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0408924242-12">[</span><span class="p" data-group-id="0408924242-13">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0408924242-13">}</span><span class="p" data-group-id="0408924242-12">]</span><span class="p" data-group-id="0408924242-4">}</span></code></pre>
<p>
This seems to work. Let’s try and eval the resulting ast:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(3)&gt; </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="5798667695-1">(</span><span class="n">ast</span><span class="p" data-group-id="5798667695-1">)</span><span class="w">
</span><span class="gt">** (CompileError) nofile: invalid quoted expression: {1, 2, 3}</span></code></pre>
<p>
So what happened here? The thing is that we didn’t really transfer our <code class="inline">{1,2,3}</code> triplet. Instead, we injected it into the target AST. Injection means, that <code class="inline">{1,2,3}</code> is itself treated as an AST fragment, which is obviously wrong.</p>
<p>
What we really want in this case is data transfer. In the code generation context, we have some data that we want to transfer to the caller’s context. And this is where <code class="inline">Macro.escape</code> helps. By escaping a term, we can make sure that it is transferred rather than injected. When we call <code class="inline">unquote(Macro.escape(term))</code>, we’ll inject an AST that describes the data in <code class="inline">term</code>.</p>
<p>
Let’s try this out:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(3)&gt; </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1284495107-1">do</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p" data-group-id="1284495107-2">(</span><span class="k">unquote</span><span class="p" data-group-id="1284495107-3">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="1284495107-4">(</span><span class="n">data</span><span class="p" data-group-id="1284495107-4">)</span><span class="p" data-group-id="1284495107-3">)</span><span class="p" data-group-id="1284495107-2">)</span><span class="w"> </span><span class="k" data-group-id="1284495107-1">end</span><span class="w">
</span><span class="p" data-group-id="1284495107-5">{</span><span class="p" data-group-id="1284495107-6">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1284495107-7">[</span><span class="p" data-group-id="1284495107-7">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1284495107-8">[</span><span class="p" data-group-id="1284495107-9">{</span><span class="ss">:__aliases__</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1284495107-10">[</span><span class="ss">alias</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="1284495107-10">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1284495107-11">[</span><span class="ss">:IO</span><span class="p" data-group-id="1284495107-11">]</span><span class="p" data-group-id="1284495107-9">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:inspect</span><span class="p" data-group-id="1284495107-8">]</span><span class="p" data-group-id="1284495107-6">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1284495107-12">[</span><span class="p" data-group-id="1284495107-12">]</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="1284495107-13">[</span><span class="p" data-group-id="1284495107-14">{</span><span class="ss">:{}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1284495107-15">[</span><span class="p" data-group-id="1284495107-15">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1284495107-16">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1284495107-16">]</span><span class="p" data-group-id="1284495107-14">}</span><span class="p" data-group-id="1284495107-13">]</span><span class="p" data-group-id="1284495107-5">}</span><span class="w">

</span><span class="gp unselectable">iex(4)&gt; </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="1284495107-17">(</span><span class="n">ast</span><span class="p" data-group-id="1284495107-17">)</span><span class="w">
</span><span class="p" data-group-id="1284495107-18">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1284495107-18">}</span></code></pre>
<p>
As you can see, we were able to transfer the data untouched.</p>
<p>
Going back to our deferred code generation, this is exactly what we need. Instead of injecting into the target AST, we want to transfer the input AST, completely preserving its shape:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="5044679906-1">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="5044679906-1">)</span><span class="w"> </span><span class="k" data-group-id="5044679906-2">do</span><span class="w">
  </span><span class="c1"># Here we have head and body AST</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5044679906-3">do</span><span class="w">
    </span><span class="c1"># We need that same head and body AST here, so we can generate</span><span class="w">
    </span><span class="c1"># the final code.</span><span class="w">
  </span><span class="k" data-group-id="5044679906-3">end</span><span class="w">
</span><span class="k" data-group-id="5044679906-2">end</span></code></pre>
<p>
By using <code class="inline">Macro.escape/1</code> we can ensure that input AST is transferred untouched back to the caller’s context where we’ll generate the final code.</p>
<p>
As discussed in previous section, we’re using <code class="inline">bind_quoted</code>, but the same principle holds:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="ss">bind_quoted</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7180550453-1">[</span><span class="w">
  </span><span class="ss">head</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="7180550453-2">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="7180550453-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">body</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="7180550453-3">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="7180550453-3">)</span><span class="w">
</span><span class="p" data-group-id="7180550453-1">]</span><span class="w"> </span><span class="k" data-group-id="7180550453-4">do</span><span class="w">
  </span><span class="c1"># Here we have exact data copies of head and body from</span><span class="w">
  </span><span class="c1"># the macro context.</span><span class="w">
</span><span class="k" data-group-id="7180550453-4">end</span></code></pre>
<h2>
Escaping and unquote: true</h2>
<p>
Notice a deceptively simple <code class="inline">unquote: true</code> option that we pass to <code class="inline">Macro.escape</code>. This is the hardest thing to explain here. To be able to understand it, you must be confident about how AST is passed to the macro, and returned back to the caller’s context.</p>
<p>
First, remember how we call our macro:</p>
<pre><code class="highlight makeup elixir"><span class="n">deftraceable</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6353552234-1">(</span><span class="n">action</span><span class="p" data-group-id="6353552234-1">)</span><span class="p" data-group-id="6353552234-2">(</span><span class="k">unquote</span><span class="p" data-group-id="6353552234-3">(</span><span class="n">state</span><span class="p" data-group-id="6353552234-3">)</span><span class="p" data-group-id="6353552234-2">)</span><span class="w"> </span><span class="k" data-group-id="6353552234-4">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="6353552234-4">end</span></code></pre>
<p>
Now, since macro actually receives its arguments quoted, the <code class="inline">head</code> argument will be equivalent to following:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># This is what the head argument in the macro context actually contains</span><span class="w">
</span><span class="k">quote</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="k" data-group-id="6918813634-1">do</span><span class="w">
  </span><span class="k">unquote</span><span class="p" data-group-id="6918813634-2">(</span><span class="n">action</span><span class="p" data-group-id="6918813634-2">)</span><span class="p" data-group-id="6918813634-3">(</span><span class="k">unquote</span><span class="p" data-group-id="6918813634-4">(</span><span class="n">state</span><span class="p" data-group-id="6918813634-4">)</span><span class="p" data-group-id="6918813634-3">)</span><span class="w">
</span><span class="k" data-group-id="6918813634-1">end</span></code></pre>
<p>
Remember that <code class="inline">Macro.escape</code> preserves data, so when you transfer a variable in some other AST, the contents remains unchanged. Given the shape of the <code class="inline">head</code> above, this is the situation we’ll end up with after our macro is expanded:</p>
<pre><code class="highlight makeup elixir"><span class="c1"># Caller&#39;s context</span><span class="w">
</span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="8605234848-1">{</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8605234848-2">{</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p" data-group-id="8605234848-2">}</span><span class="p" data-group-id="8605234848-1">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="k" data-group-id="8605234848-3">do</span><span class="w">
  </span><span class="c1"># Here is our code that generates function. Due to bind_quoted, here</span><span class="w">
  </span><span class="c1"># we have head and body variables available.</span><span class="w">

  </span><span class="c1"># Variable head is equivalent to</span><span class="w">
  </span><span class="c1">#   quote unquote: false do</span><span class="w">
  </span><span class="c1">#     unquote(action)(unquote(state))</span><span class="w">
  </span><span class="c1">#   end</span><span class="w">

  </span><span class="c1"># What we really need is for head to be equivalent to:</span><span class="w">
  </span><span class="c1">#   quote do</span><span class="w">
  </span><span class="c1">#     unquote(action)(unquote(state))</span><span class="w">
  </span><span class="c1">#   end</span><span class="w">
</span><span class="k" data-group-id="8605234848-3">end</span></code></pre>
<p>
Why do we need the second form of quoted head? Because this AST is now shaped in the caller’s context, where we have <code class="inline">action</code> and <code class="inline">state</code> variables available. And the second expression will use the contents of these variables.</p>
<p>
And this is where <code class="inline">unquote: true</code> option helps. When we call <code class="inline">Macro.escape(input_ast, unquote: true)</code>, we’ll still (mostly) preserve the shape of the transferred data, but the <code class="inline">unquote</code> fragments (e.g. <code class="inline">unquote(action)</code>) in the input AST will be resolved <em>in the caller’s context</em>.</p>
<p>
So to recap, a proper transport of the input AST to the caller’s context looks like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="5215299627-1">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="5215299627-1">)</span><span class="w"> </span><span class="k" data-group-id="5215299627-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="ss">bind_quoted</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5215299627-3">[</span><span class="w">
    </span><span class="ss">head</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="5215299627-4">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="5215299627-4">)</span><span class="p">,</span><span class="w">
    </span><span class="ss">body</span><span class="p">:</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">escape</span><span class="p" data-group-id="5215299627-5">(</span><span class="n">body</span><span class="p">,</span><span class="w"> </span><span class="ss">unquote</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="5215299627-5">)</span><span class="w">
  </span><span class="p" data-group-id="5215299627-3">]</span><span class="w"> </span><span class="k" data-group-id="5215299627-6">do</span><span class="w">
    </span><span class="c1"># Generate the code here</span><span class="w">
  </span><span class="k" data-group-id="5215299627-6">end</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="5215299627-2">end</span></code></pre>
<p>
This wasn’t so hard, but it takes some time grokking what exactly happens here. Try to make sure you’re not just blindly doing escapes (and/or <code class="inline">unquote: true</code>) without understanding that this is what you really want. After all, there’s a reason this is not a default behavior.</p>
<p>
When writing a macro, think about whether you want to inject some AST, or transport the data unchanged. In the latter case, you need <code class="inline">Macro.escape</code>. If the data being transferred is an AST that might contain <code class="inline">unquote</code> fragments, then you probably need to use <code class="inline">Macro.escape</code> with <code class="inline">unquote: true</code>.</p>
<h2>
Recap</h2>
<p>
This concludes the series on Elixir macros. I hope you found these articles interesting and educating, and that you have gained more confidence and understanding of how macros work.</p>
<p>
Always remember - macros amount to plain composition of AST fragments during expansion phase. If you understand the caller’s context and macro inputs, it shouldn’t be very hard to perform the transformations you want either directly, or by deferring when necessary.</p>
<p>
This series has by no means covered all possible aspects and nuances. If you want to learn more, a good place to start is the documentation for <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2">quote/2 special form</a>. You’ll also find some useful helpers in the <a href="https://hexdocs.pm/elixir/Macro.html">Macro</a> and <a href="https://hexdocs.pm/elixir/Code.html">Code</a> module.</p>
<p>
Happy meta-programming!</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/macros_6">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/macros_6.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Sun, 6 Jul 2014 00:00:00 +0000</pubDate></item><item><title>Understanding Elixir Macros, Part 5 - Reshaping the AST</title><link>http://theerlangelist.com//article/macros_5</link><description><![CDATA[<h1>Understanding Elixir Macros, Part 5 - Reshaping the AST</h1>
<h4 class="right">2014-06-29</h4>

<div class="article-body">
<p>
<a href="macros_5">Last time</a> I presented a basic version of <code class="inline">deftraceable</code> macro that allows us to write traceable functions. The final version of the macro has some remaining issues, and today we’ll tackle one of those - arguments pattern matching.</p>
<p>
Today’s exercise should demonstrate that we have to carefully consider our assumptions about possible inputs to our macros can receive.</p>
<h2>
The problem</h2>
<p>
As I hinted the last time, the current version of <code class="inline">deftraceable</code> doesn’t work with pattern matched arguments. Let’s demonstrate the problem:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="1152703513-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="1152703513-1">end</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="1152703513-2">do</span><span class="w">
          </span><span class="kn">import</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">

          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">div</span><span class="p" data-group-id="1152703513-3">(</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="1152703513-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:error</span><span class="w">
        </span><span class="k" data-group-id="1152703513-2">end</span><span class="w">
</span><span class="gt">** (CompileError) iex:5: unbound variable _</span></code></pre>
<p>
So what happened? The <code class="inline">deftraceable</code> macro blindly assumes that input arguments are plain variables or constants. Hence, when you call <code class="inline">deftracable div(a, b), do: …</code> the generated code will contain:</p>
<pre><code class="highlight makeup elixir"><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7172064790-1">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7172064790-1">]</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7172064790-2">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="7172064790-2">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="7172064790-3">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="7172064790-3">)</span></code></pre>
<p>
This will work as expected, but if one argument is an anonymous variable (<code class="inline">_</code>), then we generate the following code:</p>
<pre><code class="highlight makeup elixir"><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="0615752558-1">[</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="0615752558-1">]</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="0615752558-2">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="0615752558-2">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="0615752558-3">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="0615752558-3">)</span></code></pre>
<p>
This is obviously not correct, and therefore we get the unbound variable error.</p>
<p>
So what’s the solution? We shouldn’t assume anything about input arguments. Instead, we should take each argument into a dedicated variable generated by the macro. Or to say it with code, if our macro is called with:</p>
<pre><code class="highlight makeup elixir"><span class="n">deftraceable</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="1029485787-1">(</span><span class="n">pattern1</span><span class="p">,</span><span class="w"> </span><span class="n">pattern2</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="1029485787-1">)</span></code></pre>
<p>
We should generate the function head:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="6893994380-1">(</span><span class="n">pattern1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">pattern2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="6893994380-1">)</span></code></pre>
<p>
This allows us to take argument values into our internal temp variables, and print the contents of those variables.</p>
<h2>
The solution</h2>
<p>
So let’s implement this. First, I’m going to show you the top-level sketch of the solution:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="3319452397-1">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="3319452397-1">)</span><span class="w"> </span><span class="k" data-group-id="3319452397-2">do</span><span class="w">
  </span><span class="p" data-group-id="3319452397-3">{</span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">args_ast</span><span class="p" data-group-id="3319452397-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name_and_args</span><span class="p" data-group-id="3319452397-4">(</span><span class="n">head</span><span class="p" data-group-id="3319452397-4">)</span><span class="w">

  </span><span class="c1"># Decorates input args by adding &quot;= argX&quot; to each argument.</span><span class="w">
  </span><span class="c1"># Also returns a list of argument names (arg1, arg2, ...)</span><span class="w">
  </span><span class="p" data-group-id="3319452397-5">{</span><span class="n">arg_names</span><span class="p">,</span><span class="w"> </span><span class="n">decorated_args</span><span class="p" data-group-id="3319452397-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decorate_args</span><span class="p" data-group-id="3319452397-6">(</span><span class="n">args_ast</span><span class="p" data-group-id="3319452397-6">)</span><span class="w">

  </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">??</span><span class="w">   </span><span class="c1"># Replace original args with decorated ones</span><span class="w">

  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3319452397-7">do</span><span class="w">
    </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3319452397-8">(</span><span class="n">head</span><span class="p" data-group-id="3319452397-8">)</span><span class="w"> </span><span class="k" data-group-id="3319452397-9">do</span><span class="w">
      </span><span class="n">...</span><span class="w"> </span><span class="c1"># unchanged</span><span class="w">

      </span><span class="c1"># Use temp variables to make a trace message</span><span class="w">
      </span><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3319452397-10">(</span><span class="n">arg_names</span><span class="p" data-group-id="3319452397-10">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="3319452397-11">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="3319452397-11">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="3319452397-12">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="3319452397-12">)</span><span class="w">

      </span><span class="n">...</span><span class="w"> </span><span class="c1"># unchanged</span><span class="w">
    </span><span class="k" data-group-id="3319452397-9">end</span><span class="w">
  </span><span class="k" data-group-id="3319452397-7">end</span><span class="w">
</span><span class="k" data-group-id="3319452397-2">end</span></code></pre>
<p>
First, we extract name and args from the head (we resolved this in previous article). Then we have to inject <code class="inline">= argX</code> into the <code class="inline">args_ast</code> and take back the modified args (which we’ll put into <code class="inline">decorated_args</code>).</p>
<p>
We also need pure names of generated variables (or more exactly their AST), since we’ll use these to collect argument values. The variable <code class="inline">arg_names</code> will essentially contain <code class="inline">quote do [arg_1, arg_2, …] end</code> which can be easily injected into the tree.</p>
<p>
So let’s implement the rest. First, let’s see how we can decorate arguments:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">decorate_args</span><span class="p" data-group-id="4382724816-1">(</span><span class="n">args_ast</span><span class="p" data-group-id="4382724816-1">)</span><span class="w"> </span><span class="k" data-group-id="4382724816-2">do</span><span class="w">
  </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="4382724816-3">{</span><span class="n">arg_ast</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="4382724816-3">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">with_index</span><span class="p" data-group-id="4382724816-4">(</span><span class="n">args_ast</span><span class="p" data-group-id="4382724816-4">)</span><span class="w"> </span><span class="k" data-group-id="4382724816-5">do</span><span class="w">
    </span><span class="c1"># Dynamically generate quoted identifier</span><span class="w">
    </span><span class="n">arg_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="4382724816-6">(</span><span class="ss">:&quot;arg</span><span class="si" data-group-id="4382724816-7">#{</span><span class="n">index</span><span class="si" data-group-id="4382724816-7">}</span><span class="ss">&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="4382724816-6">)</span><span class="w">

    </span><span class="c1"># Generate AST for patternX = argX</span><span class="w">
    </span><span class="n">full_arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="4382724816-8">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="4382724816-9">(</span><span class="n">arg_ast</span><span class="p" data-group-id="4382724816-9">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4382724816-10">(</span><span class="n">arg_name</span><span class="p" data-group-id="4382724816-10">)</span><span class="w">
    </span><span class="k" data-group-id="4382724816-8">end</span><span class="w">

    </span><span class="p" data-group-id="4382724816-11">{</span><span class="n">arg_name</span><span class="p">,</span><span class="w"> </span><span class="n">full_arg</span><span class="p" data-group-id="4382724816-11">}</span><span class="w">
  </span><span class="k" data-group-id="4382724816-5">end</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">unzip</span><span class="w">
</span><span class="k" data-group-id="4382724816-2">end</span></code></pre>
<p>
Most of the action takes place in the <code class="inline">for</code> comprehension. Essentially we go through input AST fragment of each variable, and compute the temp name (quoted <code class="inline">argX</code>) relying on the <code class="inline">Macro.var/2</code> function which can transform an atom into a quoted variable that has a name of that atom. The second argument to <code class="inline">Macro.var/2</code> ensures that the variable is hygienic. Although we’ll inject <code class="inline">arg1</code>, <code class="inline">arg2</code>, … variables into the caller context, the caller won’t see these variables. In fact, a user of <code class="inline">deftraceable</code> can freely use these names for some local variables without interfering with temps introduced by our macro.</p>
<p>
Finally, at the end of the comprehension we return a tuple consisting of the temp’s name, and the quoted full pattern - (e.g. <code class="inline">_ = arg1</code>, or <code class="inline">0 = arg2</code>). The little dance after the comprehension with <code class="inline">unzip</code> and <code class="inline">to_tuple</code> ensures that <code class="inline">decorate_args</code> returns the result in form of <code class="inline">{arg_names, decorated_args}</code>.</p>
<p>
With <code class="inline">decorate_args</code> helper ready we can pass input arguments, and get decorated ones, together with the names of temp variables. Now we need to inject these decorated arguments into the head of the function, in place of the original arguments. In particular, we must perform following steps:</p>
<ol>
  <li>
Walk recursively through the AST of the input function head.  </li>
  <li>
Find the place where function name and arguments are specified.  </li>
  <li>
Replace original (input) arguments with the AST of decorated arguments  </li>
</ol>
<p>
This task can be reasonably simplified if we rely on <code class="inline">Macro.postwalk/2</code> function:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="1918370157-1">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="1918370157-1">)</span><span class="w"> </span><span class="k" data-group-id="1918370157-2">do</span><span class="w">
  </span><span class="p" data-group-id="1918370157-3">{</span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">args_ast</span><span class="p" data-group-id="1918370157-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name_and_args</span><span class="p" data-group-id="1918370157-4">(</span><span class="n">head</span><span class="p" data-group-id="1918370157-4">)</span><span class="w">

  </span><span class="p" data-group-id="1918370157-5">{</span><span class="n">arg_names</span><span class="p">,</span><span class="w"> </span><span class="n">decorated_args</span><span class="p" data-group-id="1918370157-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decorate_args</span><span class="p" data-group-id="1918370157-6">(</span><span class="n">args_ast</span><span class="p" data-group-id="1918370157-6">)</span><span class="w">

  </span><span class="c1"># 1. Walk recursively through the AST</span><span class="w">
  </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">postwalk</span><span class="p" data-group-id="1918370157-7">(</span><span class="w">
    </span><span class="n">head</span><span class="p">,</span><span class="w">

    </span><span class="c1"># This lambda is called for each element in the input AST and</span><span class="w">
    </span><span class="c1"># has a chance of returning alternative AST</span><span class="w">
    </span><span class="k" data-group-id="1918370157-8">fn</span><span class="w">
      </span><span class="c1"># 2. Pattern match the place where function name and arguments are</span><span class="w">
      </span><span class="c1"># specified</span><span class="w">
      </span><span class="p" data-group-id="1918370157-9">(</span><span class="p" data-group-id="1918370157-10">{</span><span class="n">fun_ast</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">old_args</span><span class="p" data-group-id="1918370157-10">}</span><span class="p" data-group-id="1918370157-9">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="p" data-group-id="1918370157-11">(</span><span class="w">
        </span><span class="n">fun_ast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fun_name</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">old_args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">args_ast</span><span class="w">
      </span><span class="p" data-group-id="1918370157-11">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="c1"># 3. Replace input arguments with the AST of decorated arguments</span><span class="w">
        </span><span class="p" data-group-id="1918370157-12">{</span><span class="n">fun_ast</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">decorated_args</span><span class="p" data-group-id="1918370157-12">}</span><span class="w">

      </span><span class="c1"># Some other element in the head AST (probably a guard)</span><span class="w">
      </span><span class="c1">#   -&gt; we just leave it unchanged</span><span class="w">
      </span><span class="p" data-group-id="1918370157-13">(</span><span class="n">other</span><span class="p" data-group-id="1918370157-13">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">other</span><span class="w">
    </span><span class="k" data-group-id="1918370157-8">end</span><span class="w">
  </span><span class="p" data-group-id="1918370157-7">)</span><span class="w">

  </span><span class="n">...</span><span class="w"> </span><span class="c1"># unchanged</span><span class="w">
</span><span class="k" data-group-id="1918370157-2">end</span></code></pre>
<p>
<code class="inline">Macro.postwalk/2</code> walks the AST recursively, and calls the provided lambda for each node, after all of the node’s descendants have been visited. The lambda receives the AST of the element, and there we have a chance of returning something else instead of that node.</p>
<p>
So what we do in this lambda is basically a pattern match where we’re looking for the <code class="inline">{fun_name, context, args}</code>. As explained in part 3, this is the quoted representation of the expression <code class="inline">some_fun(arg1, arg2, …)</code>. Once we encounter the node that matches this pattern, we just replace input arguments with new (decorated) ones. In all other cases, we simply return the input AST, leaving the rest of the tree unchanged.</p>
<p>
This is somewhat convoluted, but it solves our problem. Here’s the final version of the trace macro:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="9333063298-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="9333063298-2">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="9333063298-2">)</span><span class="w"> </span><span class="k" data-group-id="9333063298-3">do</span><span class="w">
    </span><span class="p" data-group-id="9333063298-4">{</span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">args_ast</span><span class="p" data-group-id="9333063298-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name_and_args</span><span class="p" data-group-id="9333063298-5">(</span><span class="n">head</span><span class="p" data-group-id="9333063298-5">)</span><span class="w">

    </span><span class="p" data-group-id="9333063298-6">{</span><span class="n">arg_names</span><span class="p">,</span><span class="w"> </span><span class="n">decorated_args</span><span class="p" data-group-id="9333063298-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decorate_args</span><span class="p" data-group-id="9333063298-7">(</span><span class="n">args_ast</span><span class="p" data-group-id="9333063298-7">)</span><span class="w">

    </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">postwalk</span><span class="p" data-group-id="9333063298-8">(</span><span class="n">head</span><span class="p">,</span><span class="w">
      </span><span class="k" data-group-id="9333063298-9">fn</span><span class="w">
        </span><span class="p" data-group-id="9333063298-10">(</span><span class="p" data-group-id="9333063298-11">{</span><span class="n">fun_ast</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">old_args</span><span class="p" data-group-id="9333063298-11">}</span><span class="p" data-group-id="9333063298-10">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="p" data-group-id="9333063298-12">(</span><span class="w">
          </span><span class="n">fun_ast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fun_name</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">old_args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">args_ast</span><span class="w">
        </span><span class="p" data-group-id="9333063298-12">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
          </span><span class="p" data-group-id="9333063298-13">{</span><span class="n">fun_ast</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">decorated_args</span><span class="p" data-group-id="9333063298-13">}</span><span class="w">
        </span><span class="p" data-group-id="9333063298-14">(</span><span class="n">other</span><span class="p" data-group-id="9333063298-14">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">other</span><span class="w">
      </span><span class="k" data-group-id="9333063298-9">end</span><span class="p" data-group-id="9333063298-8">)</span><span class="w">

    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9333063298-15">do</span><span class="w">
      </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9333063298-16">(</span><span class="n">head</span><span class="p" data-group-id="9333063298-16">)</span><span class="w"> </span><span class="k" data-group-id="9333063298-17">do</span><span class="w">
        </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">file</span><span class="w">
        </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">line</span><span class="w">
        </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">module</span><span class="w">

        </span><span class="n">function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9333063298-18">(</span><span class="n">fun_name</span><span class="p" data-group-id="9333063298-18">)</span><span class="w">
        </span><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9333063298-19">(</span><span class="n">arg_names</span><span class="p" data-group-id="9333063298-19">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="9333063298-20">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="9333063298-20">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="9333063298-21">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="9333063298-21">)</span><span class="w">

        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9333063298-22">(</span><span class="n">body</span><span class="p" data-group-id="9333063298-23">[</span><span class="ss">:do</span><span class="p" data-group-id="9333063298-23">]</span><span class="p" data-group-id="9333063298-22">)</span><span class="w">

        </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="9333063298-24">#{</span><span class="n">file</span><span class="si" data-group-id="9333063298-24">}</span><span class="s">(line </span><span class="si" data-group-id="9333063298-25">#{</span><span class="n">line</span><span class="si" data-group-id="9333063298-25">}</span><span class="s">)&quot;</span><span class="w">
        </span><span class="n">call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="9333063298-26">#{</span><span class="n">module</span><span class="si" data-group-id="9333063298-26">}</span><span class="s">.</span><span class="si" data-group-id="9333063298-27">#{</span><span class="n">function_name</span><span class="si" data-group-id="9333063298-27">}</span><span class="s">(</span><span class="si" data-group-id="9333063298-28">#{</span><span class="n">passed_args</span><span class="si" data-group-id="9333063298-28">}</span><span class="s">) = </span><span class="si" data-group-id="9333063298-29">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="9333063298-29">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="9333063298-30">#{</span><span class="n">loc</span><span class="si" data-group-id="9333063298-30">}</span><span class="s"> </span><span class="si" data-group-id="9333063298-31">#{</span><span class="n">call</span><span class="si" data-group-id="9333063298-31">}</span><span class="s">&quot;</span><span class="w">

        </span><span class="n">result</span><span class="w">
      </span><span class="k" data-group-id="9333063298-17">end</span><span class="w">
    </span><span class="k" data-group-id="9333063298-15">end</span><span class="w">
  </span><span class="k" data-group-id="9333063298-3">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="9333063298-32">(</span><span class="p" data-group-id="9333063298-33">{</span><span class="ss">:when</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9333063298-34">[</span><span class="n">short_head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="9333063298-34">]</span><span class="p" data-group-id="9333063298-33">}</span><span class="p" data-group-id="9333063298-32">)</span><span class="w"> </span><span class="k" data-group-id="9333063298-35">do</span><span class="w">
    </span><span class="n">name_and_args</span><span class="p" data-group-id="9333063298-36">(</span><span class="n">short_head</span><span class="p" data-group-id="9333063298-36">)</span><span class="w">
  </span><span class="k" data-group-id="9333063298-35">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="9333063298-37">(</span><span class="n">short_head</span><span class="p" data-group-id="9333063298-37">)</span><span class="w"> </span><span class="k" data-group-id="9333063298-38">do</span><span class="w">
    </span><span class="nc">Macro</span><span class="o">.</span><span class="n">decompose_call</span><span class="p" data-group-id="9333063298-39">(</span><span class="n">short_head</span><span class="p" data-group-id="9333063298-39">)</span><span class="w">
  </span><span class="k" data-group-id="9333063298-38">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">decorate_args</span><span class="p" data-group-id="9333063298-40">(</span><span class="p" data-group-id="9333063298-41">[</span><span class="p" data-group-id="9333063298-41">]</span><span class="p" data-group-id="9333063298-40">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9333063298-42">{</span><span class="p" data-group-id="9333063298-43">[</span><span class="p" data-group-id="9333063298-43">]</span><span class="p">,</span><span class="p" data-group-id="9333063298-44">[</span><span class="p" data-group-id="9333063298-44">]</span><span class="p" data-group-id="9333063298-42">}</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">decorate_args</span><span class="p" data-group-id="9333063298-45">(</span><span class="n">args_ast</span><span class="p" data-group-id="9333063298-45">)</span><span class="w"> </span><span class="k" data-group-id="9333063298-46">do</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="9333063298-47">{</span><span class="n">arg_ast</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="9333063298-47">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">with_index</span><span class="p" data-group-id="9333063298-48">(</span><span class="n">args_ast</span><span class="p" data-group-id="9333063298-48">)</span><span class="w"> </span><span class="k" data-group-id="9333063298-49">do</span><span class="w">
      </span><span class="c1"># dynamically generate quoted identifier</span><span class="w">
      </span><span class="n">arg_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="9333063298-50">(</span><span class="ss">:&quot;arg</span><span class="si" data-group-id="9333063298-51">#{</span><span class="n">index</span><span class="si" data-group-id="9333063298-51">}</span><span class="ss">&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">__MODULE__</span><span class="p" data-group-id="9333063298-50">)</span><span class="w">

      </span><span class="c1"># generate AST for patternX = argX</span><span class="w">
      </span><span class="n">full_arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9333063298-52">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="9333063298-53">(</span><span class="n">arg_ast</span><span class="p" data-group-id="9333063298-53">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9333063298-54">(</span><span class="n">arg_name</span><span class="p" data-group-id="9333063298-54">)</span><span class="w">
      </span><span class="k" data-group-id="9333063298-52">end</span><span class="w">

      </span><span class="p" data-group-id="9333063298-55">{</span><span class="n">arg_name</span><span class="p">,</span><span class="w"> </span><span class="n">full_arg</span><span class="p" data-group-id="9333063298-55">}</span><span class="w">
    </span><span class="k" data-group-id="9333063298-49">end</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">unzip</span><span class="w">
  </span><span class="k" data-group-id="9333063298-46">end</span><span class="w">
</span><span class="k" data-group-id="9333063298-1">end</span></code></pre>
<p>
Let’s try it out:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="8753323087-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="8753323087-1">end</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="8753323087-2">do</span><span class="w">
          </span><span class="kn">import</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">

          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">div</span><span class="p" data-group-id="8753323087-3">(</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="8753323087-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:error</span><span class="w">
          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">div</span><span class="p" data-group-id="8753323087-4">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="8753323087-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">
        </span><span class="k" data-group-id="8753323087-2">end</span><span class="w">

</span><span class="gp unselectable">iex(3)&gt; </span><span class="nc">Test</span><span class="o">.</span><span class="n">div</span><span class="p" data-group-id="8753323087-5">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="8753323087-5">)</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="8753323087-6">(</span><span class="n">line</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="8753323087-6">)</span><span class="w"> </span><span class="nc">Elixir.Test</span><span class="o">.</span><span class="n">div</span><span class="p" data-group-id="8753323087-7">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="8753323087-7">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.5</span><span class="w">

</span><span class="gp unselectable">iex(4)&gt; </span><span class="nc">Test</span><span class="o">.</span><span class="n">div</span><span class="p" data-group-id="8753323087-8">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="8753323087-8">)</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="8753323087-9">(</span><span class="n">line</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="8753323087-9">)</span><span class="w"> </span><span class="nc">Elixir.Test</span><span class="o">.</span><span class="n">div</span><span class="p" data-group-id="8753323087-10">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="8753323087-10">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:error</span></code></pre>
<p>
As you can see, it’s possible, and not extremely complicated, to get into the AST, tear it apart, and sprinkle it with some custom injected code. On the downside, the code of the resulting macro gets increasingly complex, and it becomes harder to analyze.</p>
<p>
This concludes today’s session. <a href="macros_6">Next time</a> I’m going to discuss some aspects of in-place code generation.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/macros_5">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/macros_5.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Sun, 29 Jun 2014 00:00:00 +0000</pubDate></item><item><title>Understanding Elixir Macros, Part 4 - Diving Deeper</title><link>http://theerlangelist.com//article/macros_4</link><description><![CDATA[<h1>Understanding Elixir Macros, Part 4 - Diving Deeper</h1>
<h4 class="right">2014-06-23</h4>

<div class="article-body">
<p>
In <a href="macros_3">previous installment</a>, I’ve shown you some basic ways of analyzing input AST and doing something about it. Today we’ll take a look at some more involved AST transformations. This will mostly be a rehash of already explained techniques. The aim is to show that it’s not very hard to go deeper into the AST, though the resulting code can easily become fairly complex and somewhat hacky.</p>
<h2>
Tracing function calls</h2>
<p>
In this article, we’ll create a <code class="inline">deftraceable</code> macro that allows us to define traceable functions. A traceable function works just like a normal function, but whenever we call it, a debug information is printed. Here’s the idea:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="3123620185-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">

  </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">my_fun</span><span class="p" data-group-id="3123620185-2">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="3123620185-2">)</span><span class="w"> </span><span class="k" data-group-id="3123620185-3">do</span><span class="w">
    </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">
  </span><span class="k" data-group-id="3123620185-3">end</span><span class="w">
</span><span class="k" data-group-id="3123620185-1">end</span><span class="w">

</span><span class="nc">Test</span><span class="o">.</span><span class="n">my_fun</span><span class="p" data-group-id="3123620185-4">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="3123620185-4">)</span><span class="w">

</span><span class="c1"># =&gt; test.ex(line 4) Test.my_fun(6,2) = 3</span></code></pre>
<p>
This example is of course contrived. You don’t need to devise such macro, because <a href="http://erlang.org/doc/man/dbg.html">Erlang already has very powerful tracing capabilities</a>, and there’s an <a href="https://github.com/fishcakez/dbg">Elixir wrapper available</a>. However, the example is interesting because it will demand some deeper AST transformations and techniques.</p>
<p>
Before starting, I’d like to mention again that you should carefully consider whether you really need such constructs. Macros such as <code class="inline">deftraceable</code> introduce another thing every code maintainer needs to understand. Looking at the code, it’s not obvious what happens behind the scene. If everyone devises such constructs, each Elixir project will quickly turn into a soup of custom language extentions. It will be hard even for experienced developers to understand the flow of the underlying code that heavily relies on complex macros.</p>
<p>
All that said, there will be cases suitable for macros, so you shouldn’t avoid them just because someone claims that macros are bad. For example, if we didn’t have tracing facilities in Erlang, we’d need to devise some kind of a macro to help us with it (not necesarilly similar to the example above, but that’s another discussion), or our code would suffer from large boilerplate.</p>
<p>
In my opinion, boilerplate is bad because the code becomes ridden with bureaucratic noise, and therefore it is harder to read and understand. Macros can certainly help in reducing crust, but before reaching for them, consider whether you can resolve duplication with run-time constructs (functions, modules, protocols).</p>
<p>
With that long disclaimer out of the way, let’s write <code class="inline">deftraceable</code>. First, it’s worth manually generating the corresponding code.</p>
<p>
Let’s recall the usage:</p>
<pre><code class="highlight makeup elixir"><span class="n">deftraceable</span><span class="w"> </span><span class="n">my_fun</span><span class="p" data-group-id="9648271451-1">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="9648271451-1">)</span><span class="w"> </span><span class="k" data-group-id="9648271451-2">do</span><span class="w">
  </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">
</span><span class="k" data-group-id="9648271451-2">end</span></code></pre>
<p>
The generated code should look like:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">my_fun</span><span class="p" data-group-id="7367320669-1">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7367320669-1">)</span><span class="w"> </span><span class="k" data-group-id="7367320669-2">do</span><span class="w">
  </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">file</span><span class="w">
  </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">line</span><span class="w">
  </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">module</span><span class="w">
  </span><span class="n">function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_fun&quot;</span><span class="w">
  </span><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7367320669-3">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="7367320669-3">]</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7367320669-4">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="7367320669-4">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="7367320669-5">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="7367320669-5">)</span><span class="w">

  </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">

  </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7367320669-6">#{</span><span class="n">file</span><span class="si" data-group-id="7367320669-6">}</span><span class="s">(line </span><span class="si" data-group-id="7367320669-7">#{</span><span class="n">line</span><span class="si" data-group-id="7367320669-7">}</span><span class="s">)&quot;</span><span class="w">
  </span><span class="n">call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7367320669-8">#{</span><span class="n">module</span><span class="si" data-group-id="7367320669-8">}</span><span class="s">.</span><span class="si" data-group-id="7367320669-9">#{</span><span class="n">function_name</span><span class="si" data-group-id="7367320669-9">}</span><span class="s">(</span><span class="si" data-group-id="7367320669-10">#{</span><span class="n">passed_args</span><span class="si" data-group-id="7367320669-10">}</span><span class="s">) = </span><span class="si" data-group-id="7367320669-11">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="7367320669-11">}</span><span class="s">&quot;</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7367320669-12">#{</span><span class="n">loc</span><span class="si" data-group-id="7367320669-12">}</span><span class="s"> </span><span class="si" data-group-id="7367320669-13">#{</span><span class="n">call</span><span class="si" data-group-id="7367320669-13">}</span><span class="s">&quot;</span><span class="w">

  </span><span class="n">result</span><span class="w">
</span><span class="k" data-group-id="7367320669-2">end</span></code></pre>
<p>
The idea is simple. We fetch various data from the compiler environment, then compute the result, and finally print everything to the screen.</p>
<p>
The code relies on <code class="inline">__ENV__</code> special form that can be used to inject all sort of compile-time informations (e.g. line number and file) in the final AST. <code class="inline">__ENV__</code> is a struct and whenever you use it in the code, it will be expanded in compile time to appropriate value. Hence, wherever in code we write <code class="inline">__ENV__.file</code> the resulting bytecode will contain the (binary) string constant with the containing file name.</p>
<p>
Now we need to build this code dynamically. Let’s see the basic outline:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="7275810065-1">(</span><span class="sc">??</span><span class="p" data-group-id="7275810065-1">)</span><span class="w"> </span><span class="k" data-group-id="7275810065-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="7275810065-3">do</span><span class="w">
    </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="7275810065-4">(</span><span class="n">head</span><span class="p" data-group-id="7275810065-4">)</span><span class="w"> </span><span class="k" data-group-id="7275810065-5">do</span><span class="w">
      </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">file</span><span class="w">
      </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">line</span><span class="w">
      </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">module</span><span class="w">
      </span><span class="n">function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">??</span><span class="w">
      </span><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">??</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7275810065-6">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="7275810065-6">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="7275810065-7">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="7275810065-7">)</span><span class="w">

      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">??</span><span class="w">

      </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7275810065-8">#{</span><span class="n">file</span><span class="si" data-group-id="7275810065-8">}</span><span class="s">(line </span><span class="si" data-group-id="7275810065-9">#{</span><span class="n">line</span><span class="si" data-group-id="7275810065-9">}</span><span class="s">)&quot;</span><span class="w">
      </span><span class="n">call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7275810065-10">#{</span><span class="n">module</span><span class="si" data-group-id="7275810065-10">}</span><span class="s">.</span><span class="si" data-group-id="7275810065-11">#{</span><span class="n">function_name</span><span class="si" data-group-id="7275810065-11">}</span><span class="s">(</span><span class="si" data-group-id="7275810065-12">#{</span><span class="n">passed_args</span><span class="si" data-group-id="7275810065-12">}</span><span class="s">) = </span><span class="si" data-group-id="7275810065-13">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="7275810065-13">}</span><span class="s">&quot;</span><span class="w">
      </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7275810065-14">#{</span><span class="n">loc</span><span class="si" data-group-id="7275810065-14">}</span><span class="s"> </span><span class="si" data-group-id="7275810065-15">#{</span><span class="n">call</span><span class="si" data-group-id="7275810065-15">}</span><span class="s">&quot;</span><span class="w">

      </span><span class="n">result</span><span class="w">
    </span><span class="k" data-group-id="7275810065-5">end</span><span class="w">
  </span><span class="k" data-group-id="7275810065-3">end</span><span class="w">
</span><span class="k" data-group-id="7275810065-2">end</span></code></pre>
<p>
Here I placed question marks (??) in places where we need to dynamically inject AST fragments, based on the input arguments. In particular, we have to deduce function name, argument names, and function body from the passed parameters.</p>
<p>
Now, when we call a macro <code class="inline">deftraceable my_fun(…) do … end</code>, the macro receives two arguments - the function head (function name and argument list) and a keyword list containing the function body. Both of these will of course be quoted.</p>
<p>
How do I know this? I actually don’t. I usually gain this knowledge by trial and error. Basically, I start by defining a macro:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="9814165967-1">(</span><span class="n">arg1</span><span class="p" data-group-id="9814165967-1">)</span><span class="w"> </span><span class="k" data-group-id="9814165967-2">do</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="w"> </span><span class="n">arg1</span><span class="w">
  </span><span class="no">nil</span><span class="w">
</span><span class="k" data-group-id="9814165967-2">end</span></code></pre>
<p>
Then I try to call the macro from some test module or from the shell. If the argument numbers are wrong, an error will occur, and I’ll retry by adding another argument to the macro definition. Once I get the result printed, I try to figure out what arguments represent, and then start building the macro.</p>
<p>
The <code class="inline">nil</code> at the end of the macro ensures we don’t generate anything (well, we generate <code class="inline">nil</code> which is usually irrelevant to the caller code). This allows me to further compose fragments without injecting the code. I usually rely on <code class="inline">IO.inspect</code> and <code class="inline">Macro.to_string/1</code> to verify intermediate results, and once I’m happy, I remove the <code class="inline">nil</code> part and see if the thing works.</p>
<p>
In our case <code class="inline">deftraceable</code> receives the function head and the body. The function head will be an AST fragment in the format I’ve described last time (<code class="inline">{function_name, context, [arg1, arg2, …]</code>).</p>
<p>
So we need to do following:</p>
<ul>
  <li>
Extract function name and arguments from the quoted head  </li>
  <li>
Inject these values into the AST we’re returning from the macro  </li>
  <li>
Inject function body into that same AST  </li>
  <li>
Print trace info  </li>
</ul>
<p>
We could use pattern matching to extract function name and arguments from this AST fragment, but as it turns out there is a helper <code class="inline">Macro.decompose_call/1</code> that does exactly this. Given these steps, the final version of the macro looks like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="0424485947-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="0424485947-2">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="0424485947-2">)</span><span class="w"> </span><span class="k" data-group-id="0424485947-3">do</span><span class="w">
    </span><span class="c1"># Extract function name and arguments</span><span class="w">
    </span><span class="p" data-group-id="0424485947-4">{</span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">args_ast</span><span class="p" data-group-id="0424485947-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">decompose_call</span><span class="p" data-group-id="0424485947-5">(</span><span class="n">head</span><span class="p" data-group-id="0424485947-5">)</span><span class="w">

    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0424485947-6">do</span><span class="w">
      </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0424485947-7">(</span><span class="n">head</span><span class="p" data-group-id="0424485947-7">)</span><span class="w"> </span><span class="k" data-group-id="0424485947-8">do</span><span class="w">
        </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">file</span><span class="w">
        </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">line</span><span class="w">
        </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">module</span><span class="w">

        </span><span class="c1"># Inject function name and arguments into AST</span><span class="w">
        </span><span class="n">function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0424485947-9">(</span><span class="n">fun_name</span><span class="p" data-group-id="0424485947-9">)</span><span class="w">
        </span><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0424485947-10">(</span><span class="n">args_ast</span><span class="p" data-group-id="0424485947-10">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="0424485947-11">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="0424485947-11">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="0424485947-12">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="0424485947-12">)</span><span class="w">

        </span><span class="c1"># Inject function body into the AST</span><span class="w">
        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0424485947-13">(</span><span class="n">body</span><span class="p" data-group-id="0424485947-14">[</span><span class="ss">:do</span><span class="p" data-group-id="0424485947-14">]</span><span class="p" data-group-id="0424485947-13">)</span><span class="w">

        </span><span class="c1"># Print trace info&quot;</span><span class="w">
        </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="0424485947-15">#{</span><span class="n">file</span><span class="si" data-group-id="0424485947-15">}</span><span class="s">(line </span><span class="si" data-group-id="0424485947-16">#{</span><span class="n">line</span><span class="si" data-group-id="0424485947-16">}</span><span class="s">)&quot;</span><span class="w">
        </span><span class="n">call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="0424485947-17">#{</span><span class="n">module</span><span class="si" data-group-id="0424485947-17">}</span><span class="s">.</span><span class="si" data-group-id="0424485947-18">#{</span><span class="n">function_name</span><span class="si" data-group-id="0424485947-18">}</span><span class="s">(</span><span class="si" data-group-id="0424485947-19">#{</span><span class="n">passed_args</span><span class="si" data-group-id="0424485947-19">}</span><span class="s">) = </span><span class="si" data-group-id="0424485947-20">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="0424485947-20">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="0424485947-21">#{</span><span class="n">loc</span><span class="si" data-group-id="0424485947-21">}</span><span class="s"> </span><span class="si" data-group-id="0424485947-22">#{</span><span class="n">call</span><span class="si" data-group-id="0424485947-22">}</span><span class="s">&quot;</span><span class="w">

        </span><span class="n">result</span><span class="w">
      </span><span class="k" data-group-id="0424485947-8">end</span><span class="w">
    </span><span class="k" data-group-id="0424485947-6">end</span><span class="w">
  </span><span class="k" data-group-id="0424485947-3">end</span><span class="w">
</span><span class="k" data-group-id="0424485947-1">end</span></code></pre>
<p>
Let’s try it out:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="8207089183-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="8207089183-1">end</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="8207089183-2">do</span><span class="w">
          </span><span class="kn">import</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">

          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">my_fun</span><span class="p" data-group-id="8207089183-3">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="8207089183-3">)</span><span class="w"> </span><span class="k" data-group-id="8207089183-4">do</span><span class="w">
            </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">
          </span><span class="k" data-group-id="8207089183-4">end</span><span class="w">
        </span><span class="k" data-group-id="8207089183-2">end</span><span class="w">

</span><span class="gp unselectable">iex(3)&gt; </span><span class="nc">Test</span><span class="o">.</span><span class="n">my_fun</span><span class="p" data-group-id="8207089183-5">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="8207089183-5">)</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="8207089183-6">(</span><span class="n">line</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="8207089183-6">)</span><span class="w"> </span><span class="nc">Test</span><span class="o">.</span><span class="n">my_fun</span><span class="p" data-group-id="8207089183-7">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="8207089183-7">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="w">   </span><span class="c1"># trace output</span><span class="w">
</span><span class="mf">2.0</span></code></pre>
<p>
It seems to be working. However, I should immediately point out that there are a couple of problems with this implementation:</p>
<ul>
  <li>
The macro doesn’t handle guards well  </li>
  <li>
Pattern matching arguments will not always work (e.g. when using _ to match any term)  </li>
  <li>
The macro doesn’t work when dynamically generating code directly in the module.  </li>
</ul>
<p>
I’ll explain each of these problems one by one, starting with guards, and leaving remaining issues for future articles.</p>
<h2>
Handling guards</h2>
<p>
All problems with <code class="inline">deftraceable</code> stem from the fact that we’re making some assumptions about the input AST. That’s a dangerous teritory, and we must be careful to cover all cases.</p>
<p>
For example, the macro assumes that head contains just the name and the arguments list. Consequently, <code class="inline">deftraceable</code> won’t work if we want to define a traceable function with guards:</p>
<pre><code class="highlight makeup elixir"><span class="n">deftraceable</span><span class="w"> </span><span class="n">my_fun</span><span class="p" data-group-id="1140283804-1">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="1140283804-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="1140283804-2">do</span><span class="w">
  </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">
</span><span class="k" data-group-id="1140283804-2">end</span></code></pre>
<p>
In this case, our head (the first argument of the macro) will also contain the guard information, and will not be parsable by <code class="inline">Macro.decompose_call/1</code> The solution is to detect this case, and handle it in a special way.</p>
<p>
First, let’s discover how this head is quoted:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5301847267-1">do</span><span class="w"> </span><span class="n">my_fun</span><span class="p" data-group-id="5301847267-2">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="5301847267-2">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="5301847267-1">end</span><span class="w">
</span><span class="p" data-group-id="5301847267-3">{</span><span class="ss">:when</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-4">[</span><span class="p" data-group-id="5301847267-4">]</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="5301847267-5">[</span><span class="p" data-group-id="5301847267-6">{</span><span class="ss">:my_fun</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-7">[</span><span class="p" data-group-id="5301847267-7">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-8">[</span><span class="p" data-group-id="5301847267-9">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-10">[</span><span class="p" data-group-id="5301847267-10">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="5301847267-9">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-11">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-12">[</span><span class="p" data-group-id="5301847267-12">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="5301847267-11">}</span><span class="p" data-group-id="5301847267-8">]</span><span class="p" data-group-id="5301847267-6">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="5301847267-13">{</span><span class="ss">:&lt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-14">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="5301847267-14">]</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="5301847267-15">[</span><span class="p" data-group-id="5301847267-16">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-17">[</span><span class="p" data-group-id="5301847267-17">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="5301847267-16">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-18">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5301847267-19">[</span><span class="p" data-group-id="5301847267-19">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="5301847267-18">}</span><span class="p" data-group-id="5301847267-15">]</span><span class="p" data-group-id="5301847267-13">}</span><span class="p" data-group-id="5301847267-5">]</span><span class="p" data-group-id="5301847267-3">}</span></code></pre>
<p>
So essentially, our guard head has the shape of <code class="inline">{:when, _, [name_and_args, …]}</code>. We can rely on this to extract the name and arguments using pattern matching:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="2503421574-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="2503421574-2">(</span><span class="p" data-group-id="2503421574-3">{</span><span class="ss">:when</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2503421574-4">[</span><span class="n">short_head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="2503421574-4">]</span><span class="p" data-group-id="2503421574-3">}</span><span class="p" data-group-id="2503421574-2">)</span><span class="w"> </span><span class="k" data-group-id="2503421574-5">do</span><span class="w">
    </span><span class="n">name_and_args</span><span class="p" data-group-id="2503421574-6">(</span><span class="n">short_head</span><span class="p" data-group-id="2503421574-6">)</span><span class="w">
  </span><span class="k" data-group-id="2503421574-5">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="2503421574-7">(</span><span class="n">short_head</span><span class="p" data-group-id="2503421574-7">)</span><span class="w"> </span><span class="k" data-group-id="2503421574-8">do</span><span class="w">
    </span><span class="nc">Macro</span><span class="o">.</span><span class="n">decompose_call</span><span class="p" data-group-id="2503421574-9">(</span><span class="n">short_head</span><span class="p" data-group-id="2503421574-9">)</span><span class="w">
  </span><span class="k" data-group-id="2503421574-8">end</span><span class="w">
  </span><span class="n">...</span></code></pre>
<p>
And of course, we need to call this function from the macro:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="3841067389-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="3841067389-2">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="3841067389-2">)</span><span class="w"> </span><span class="k" data-group-id="3841067389-3">do</span><span class="w">
    </span><span class="p" data-group-id="3841067389-4">{</span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">args_ast</span><span class="p" data-group-id="3841067389-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name_and_args</span><span class="p" data-group-id="3841067389-5">(</span><span class="n">head</span><span class="p" data-group-id="3841067389-5">)</span><span class="w">

    </span><span class="n">...</span><span class="w"> </span><span class="c1"># unchanged</span><span class="w">
  </span><span class="k" data-group-id="3841067389-3">end</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="3841067389-1">end</span></code></pre>
<p>
As you can see, it’s possible to define additional private functions and call them from your macro. After all, a macro is just a function, and when it is called, the containing module is already compiled and loaded into the VM of the compiler (otherwise, macro couldn’t be running).</p>
<p>
Here’s the full version of the macro:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="7006959618-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">deftraceable</span><span class="p" data-group-id="7006959618-2">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="7006959618-2">)</span><span class="w"> </span><span class="k" data-group-id="7006959618-3">do</span><span class="w">
    </span><span class="p" data-group-id="7006959618-4">{</span><span class="n">fun_name</span><span class="p">,</span><span class="w"> </span><span class="n">args_ast</span><span class="p" data-group-id="7006959618-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name_and_args</span><span class="p" data-group-id="7006959618-5">(</span><span class="n">head</span><span class="p" data-group-id="7006959618-5">)</span><span class="w">

    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="7006959618-6">do</span><span class="w">
      </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="7006959618-7">(</span><span class="n">head</span><span class="p" data-group-id="7006959618-7">)</span><span class="w"> </span><span class="k" data-group-id="7006959618-8">do</span><span class="w">
        </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">file</span><span class="w">
        </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">line</span><span class="w">
        </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">module</span><span class="w">

        </span><span class="n">function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="7006959618-9">(</span><span class="n">fun_name</span><span class="p" data-group-id="7006959618-9">)</span><span class="w">
        </span><span class="n">passed_args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="7006959618-10">(</span><span class="n">args_ast</span><span class="p" data-group-id="7006959618-10">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="7006959618-11">(</span><span class="o">&amp;</span><span class="n">inspect</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="7006959618-11">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">join</span><span class="p" data-group-id="7006959618-12">(</span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="7006959618-12">)</span><span class="w">

        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="7006959618-13">(</span><span class="n">body</span><span class="p" data-group-id="7006959618-14">[</span><span class="ss">:do</span><span class="p" data-group-id="7006959618-14">]</span><span class="p" data-group-id="7006959618-13">)</span><span class="w">

        </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7006959618-15">#{</span><span class="n">file</span><span class="si" data-group-id="7006959618-15">}</span><span class="s">(line </span><span class="si" data-group-id="7006959618-16">#{</span><span class="n">line</span><span class="si" data-group-id="7006959618-16">}</span><span class="s">)&quot;</span><span class="w">
        </span><span class="n">call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7006959618-17">#{</span><span class="n">module</span><span class="si" data-group-id="7006959618-17">}</span><span class="s">.</span><span class="si" data-group-id="7006959618-18">#{</span><span class="n">function_name</span><span class="si" data-group-id="7006959618-18">}</span><span class="s">(</span><span class="si" data-group-id="7006959618-19">#{</span><span class="n">passed_args</span><span class="si" data-group-id="7006959618-19">}</span><span class="s">) = </span><span class="si" data-group-id="7006959618-20">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="7006959618-20">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;</span><span class="si" data-group-id="7006959618-21">#{</span><span class="n">loc</span><span class="si" data-group-id="7006959618-21">}</span><span class="s"> </span><span class="si" data-group-id="7006959618-22">#{</span><span class="n">call</span><span class="si" data-group-id="7006959618-22">}</span><span class="s">&quot;</span><span class="w">

        </span><span class="n">result</span><span class="w">
      </span><span class="k" data-group-id="7006959618-8">end</span><span class="w">
    </span><span class="k" data-group-id="7006959618-6">end</span><span class="w">
  </span><span class="k" data-group-id="7006959618-3">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="7006959618-23">(</span><span class="p" data-group-id="7006959618-24">{</span><span class="ss">:when</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7006959618-25">[</span><span class="n">short_head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="7006959618-25">]</span><span class="p" data-group-id="7006959618-24">}</span><span class="p" data-group-id="7006959618-23">)</span><span class="w"> </span><span class="k" data-group-id="7006959618-26">do</span><span class="w">
    </span><span class="n">name_and_args</span><span class="p" data-group-id="7006959618-27">(</span><span class="n">short_head</span><span class="p" data-group-id="7006959618-27">)</span><span class="w">
  </span><span class="k" data-group-id="7006959618-26">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">name_and_args</span><span class="p" data-group-id="7006959618-28">(</span><span class="n">short_head</span><span class="p" data-group-id="7006959618-28">)</span><span class="w"> </span><span class="k" data-group-id="7006959618-29">do</span><span class="w">
    </span><span class="nc">Macro</span><span class="o">.</span><span class="n">decompose_call</span><span class="p" data-group-id="7006959618-30">(</span><span class="n">short_head</span><span class="p" data-group-id="7006959618-30">)</span><span class="w">
  </span><span class="k" data-group-id="7006959618-29">end</span><span class="w">
</span><span class="k" data-group-id="7006959618-1">end</span></code></pre>
<p>
Let’s try it out:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="4191657082-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="4191657082-1">end</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="k" data-group-id="4191657082-2">do</span><span class="w">
          </span><span class="kn">import</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">

          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">my_fun</span><span class="p" data-group-id="4191657082-3">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="4191657082-3">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="4191657082-4">do</span><span class="w">
            </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">
          </span><span class="k" data-group-id="4191657082-4">end</span><span class="w">

          </span><span class="n">deftraceable</span><span class="w"> </span><span class="n">my_fun</span><span class="p" data-group-id="4191657082-5">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p" data-group-id="4191657082-5">)</span><span class="w"> </span><span class="k" data-group-id="4191657082-6">do</span><span class="w">
            </span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="w">
          </span><span class="k" data-group-id="4191657082-6">end</span><span class="w">
        </span><span class="k" data-group-id="4191657082-2">end</span><span class="w">

</span><span class="gp unselectable">iex(3)&gt; </span><span class="nc">Test</span><span class="o">.</span><span class="n">my_fun</span><span class="p" data-group-id="4191657082-7">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="4191657082-7">)</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="4191657082-8">(</span><span class="n">line</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="4191657082-8">)</span><span class="w"> </span><span class="nc">Test</span><span class="o">.</span><span class="n">my_fun</span><span class="p" data-group-id="4191657082-9">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="4191657082-9">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w">
</span><span class="mf">0.5</span><span class="w">

</span><span class="gp unselectable">iex(4)&gt; </span><span class="nc">Test</span><span class="o">.</span><span class="n">my_fun</span><span class="p" data-group-id="4191657082-10">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="4191657082-10">)</span><span class="w">
</span><span class="n">iex</span><span class="p" data-group-id="4191657082-11">(</span><span class="n">line</span><span class="w"> </span><span class="mi">7</span><span class="p" data-group-id="4191657082-11">)</span><span class="w"> </span><span class="nc">Test</span><span class="o">.</span><span class="n">my_fun</span><span class="p" data-group-id="4191657082-12">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="4191657082-12">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span></code></pre>
<p>
The main point of this exercise was to illustrate that it’s possible to deduce something from the input AST. In this example, we managed to detect and handle a function guard. Obviously, the code becomes more involved, since it relies on the internal structure of the AST. In this case, the code is relatively simple, but as you’ll see in <a href="macros_5">future articles</a>, where I’ll tackle remaining problems of <code class="inline">deftraceable</code>, things can quickly become messy.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/macros_4">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/macros_4.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Mon, 23 Jun 2014 00:00:00 +0000</pubDate></item><item><title>Understanding Elixir Macros, Part 3 - Getting into the AST</title><link>http://theerlangelist.com//article/macros_3</link><description><![CDATA[<h1>Understanding Elixir Macros, Part 3 - Getting into the AST</h1>
<h4 class="right">2014-06-15</h4>

<div class="article-body">
<p>
It’s time to continue our exploration of Elixir macros. <a href="macros_3">Last time</a> I’ve covered some essential theory, and today, I’ll step into a less documented territory, and discuss some details on Elixir AST.</p>
<h2>
Tracing function calls</h2>
<p>
So far you have seen only basic macros that take input AST fragments and combine them together, sprinkling some additional boilerplate around and/or between input fragments. Since we don’t analyze or parse the input AST, this is probably the cleanest (or the least hackiest) style of macro writing, which results in fairly simple macros that are reasonably easy to understand.</p>
<p>
However, in some cases we will need to parse input AST fragments to get some specific informations. A simple example are <code class="inline">ExUnit</code> assertions. For example, the expression <code class="inline">assert 1+1 == 2+2</code> will fail with an error:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Assertion</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">failed</span><span class="w">
</span><span class="ss">code</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="w">
</span><span class="ss">lhs</span><span class="p">:</span><span class="w">  </span><span class="mi">1</span><span class="w">
</span><span class="ss">rhs</span><span class="p">:</span><span class="w">  </span><span class="mi">2</span></code></pre>
<p>
The macro <code class="inline">assert</code> accepts the entire expression <code class="inline">1+1 == 2+2</code> and is able to extract individual sub-expressions of the comparison, printing their corresponding results if the entire expression returns false. To do this, the macro code must somehow split the input AST into separate parts and compute each sub-expression separately.</p>
<p>
In more involved cases even richer AST transformations are called for. For example, with ExActor you can write this code:</p>
<pre><code class="highlight makeup elixir"><span class="n">defcast</span><span class="w"> </span><span class="n">inc</span><span class="p" data-group-id="1001071898-1">(</span><span class="n">x</span><span class="p" data-group-id="1001071898-1">)</span><span class="p">,</span><span class="w"> </span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">new_state</span><span class="p" data-group-id="1001071898-2">(</span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="1001071898-2">)</span></code></pre>
<p>
which translates to roughly the following:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">inc</span><span class="p" data-group-id="7612045747-1">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="7612045747-1">)</span><span class="w"> </span><span class="k" data-group-id="7612045747-2">do</span><span class="w">
  </span><span class="ss">:gen_server</span><span class="o">.</span><span class="n">cast</span><span class="p" data-group-id="7612045747-3">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7612045747-4">{</span><span class="ss">:inc</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="7612045747-4">}</span><span class="p" data-group-id="7612045747-3">)</span><span class="w">
</span><span class="k" data-group-id="7612045747-2">end</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_cast</span><span class="p" data-group-id="7612045747-5">(</span><span class="p" data-group-id="7612045747-6">{</span><span class="ss">:inc</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="7612045747-6">}</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p" data-group-id="7612045747-5">)</span><span class="w"> </span><span class="k" data-group-id="7612045747-7">do</span><span class="w">
  </span><span class="p" data-group-id="7612045747-8">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="o">+</span><span class="n">x</span><span class="p" data-group-id="7612045747-8">}</span><span class="w">
</span><span class="k" data-group-id="7612045747-7">end</span></code></pre>
<p>
Just like <code class="inline">assert</code>, the <code class="inline">defcast</code> macro needs to dive into the input AST fragment and detect individual sub-fragments (e.g. function name, individual arguments). Then, ExActor performs an elaborate transformation, reassembling this sub-parts into a more complex code.</p>
<p>
Today, I’m going to show you some basic techniques of building such macros, and I’ll continue with more complex transformations in subsequent articles. But before doing this, I should advise you to carefully consider whether your code needs to be based on macros. Though very powerful, macros have some downsides.</p>
<p>
First, as you’ll see in this series, the code can quickly become much more involved than “plain” run-time abstractions. You can quickly end up doing many nested <code class="inline">quote</code>/<code class="inline">unquote</code> calls and weird pattern matches that rely on undocumented format of the AST.</p>
<p>
In addition, proliferation of macros may make your client code extremly cryptic, since it will rely on custom, non-standard idioms (such as <code class="inline">defcast</code> from ExActor). It can become harder to reason about the code, and understand what exactly happens underneath.</p>
<p>
On the plus side, macros can be very helpful when removing boilerplate (as hopefully ExActor example demonstrated), and have the power of accessing information that is not available at run-time (as you should see from the <code class="inline">assert</code> example). Finally, since they run during compilation, macros make it possible to optimize some code by moving calculations to compile-time.</p>
<p>
So there will definitely be cases that are suited for macros, and you shouldn’t be afraid of using them. However, you shouldn’t choose macros only to gain some cute DSL-ish syntax. Before reaching for macros, you should consider whether your problem can be solved efficiently in run-time, relying on “standard” language abstractions such as functions, modules, and protocols.</p>
<h2>
Discovering the AST structure</h2>
<p>
At the moment of writing this there is very little documentation on the AST structure. However, it’s easy to explore and play with AST in the shell session, and this is how I usually discover the AST format.</p>
<p>
For example, here’s how a quoted reference to a variable looks like:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="2281964232-1">do</span><span class="w"> </span><span class="n">my_var</span><span class="w"> </span><span class="k" data-group-id="2281964232-1">end</span><span class="w">
</span><span class="p" data-group-id="2281964232-2">{</span><span class="ss">:my_var</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2281964232-3">[</span><span class="p" data-group-id="2281964232-3">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="2281964232-2">}</span></code></pre>
<p>
Here, the first element represents the name of the variable. The second element is a context keyword list that contains some metadata specific for this particular AST fragment (e.g. imports and aliases). Most often you won’t be interested in context data. The third element usually represents the module where the quoting happened, and is used to ensure hygiene of quoted variables. If this element is <code class="inline">nil</code> then the identifier is not hygienic.</p>
<p>
A simple expression looks a bit more involved:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8809135531-1">do</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="8809135531-1">end</span><span class="w">
</span><span class="p" data-group-id="8809135531-2">{</span><span class="ss">:+</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8809135531-3">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="8809135531-3">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8809135531-4">[</span><span class="p" data-group-id="8809135531-5">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8809135531-6">[</span><span class="p" data-group-id="8809135531-6">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="8809135531-5">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8809135531-7">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8809135531-8">[</span><span class="p" data-group-id="8809135531-8">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="8809135531-7">}</span><span class="p" data-group-id="8809135531-4">]</span><span class="p" data-group-id="8809135531-2">}</span></code></pre>
<p>
This might look scary, but it’s reasonably easy to understand if I show you the higher-level pattern:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="3154561451-1">{</span><span class="ss">:+</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3154561451-2">[</span><span class="n">ast_for_a</span><span class="p">,</span><span class="w"> </span><span class="n">ast_for_b</span><span class="p" data-group-id="3154561451-2">]</span><span class="p" data-group-id="3154561451-1">}</span></code></pre>
<p>
In our example, <code class="inline">ast_for_a</code> and <code class="inline">ast_for_b</code> follow the shape of a variable reference you’ve seen earlier (e.g. <code class="inline">{:a, [], Elixir}</code>. More generally, quoted arguments can be arbitrary complex since they describe the expression of each argument. Essentially, AST is a deep nested structure of simple quoted expressions such as the ones I’m showing you here.</p>
<p>
Let’s take a look at a function call:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(3)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8454458130-1">do</span><span class="w"> </span><span class="n">div</span><span class="p" data-group-id="8454458130-2">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8454458130-2">)</span><span class="w"> </span><span class="k" data-group-id="8454458130-1">end</span><span class="w">
</span><span class="p" data-group-id="8454458130-3">{</span><span class="ss">:div</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8454458130-4">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="8454458130-4">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8454458130-5">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="8454458130-5">]</span><span class="p" data-group-id="8454458130-3">}</span></code></pre>
<p>
This resembles the quoted <code class="inline">+</code> operation, which shouldn’t come as a surprise knowing that <code class="inline">+</code> <a href="https://github.com/elixir-lang/elixir/blob/v0.14.0/lib/elixir/lib/kernel.ex#L856">is actually a function</a>. In fact, all binary operators will be quoted as function calls.</p>
<p>
Finally, let’s take a look at a quoted function definition:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(4)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1920904554-1">do</span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="nf">my_fun</span><span class="p" data-group-id="1920904554-2">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p" data-group-id="1920904554-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:ok</span><span class="w"> </span><span class="k" data-group-id="1920904554-1">end</span><span class="w">
</span><span class="p" data-group-id="1920904554-3">{</span><span class="ss">:def</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1920904554-4">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="1920904554-4">]</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="1920904554-5">[</span><span class="p" data-group-id="1920904554-6">{</span><span class="ss">:my_fun</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1920904554-7">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="1920904554-7">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1920904554-8">[</span><span class="p" data-group-id="1920904554-9">{</span><span class="ss">:arg1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1920904554-10">[</span><span class="p" data-group-id="1920904554-10">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="1920904554-9">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1920904554-11">{</span><span class="ss">:arg2</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1920904554-12">[</span><span class="p" data-group-id="1920904554-12">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="1920904554-11">}</span><span class="p" data-group-id="1920904554-8">]</span><span class="p" data-group-id="1920904554-6">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="1920904554-13">[</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:ok</span><span class="p" data-group-id="1920904554-13">]</span><span class="p" data-group-id="1920904554-5">]</span><span class="p" data-group-id="1920904554-3">}</span></code></pre>
<p>
While this looks scary, it can be simplified by looking at important parts. Essentially, this deep structure amounts to:</p>
<pre><code class="highlight makeup elixir"><span class="p" data-group-id="8959684944-1">{</span><span class="ss">:def</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8959684944-2">[</span><span class="n">fun_call</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8959684944-3">[</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="8959684944-3">]</span><span class="p" data-group-id="8959684944-2">]</span><span class="p" data-group-id="8959684944-1">}</span></code></pre>
<p>
with <code class="inline">fun_call</code> having the structure of a function call (which you’ve just seen).</p>
<p>
As you can see, there usually is some reason and sense behind the AST. I won’t go through all possible AST shapes here, but the approach to discovery is to play in <code class="inline">iex</code> and quote simpler forms of expressions you’re interested in. This is a bit of reverse engineering, but it’s not exactly a rocket science.</p>
<h2>
Writing assert macro</h2>
<p>
For a quick demonstration, let’s write a simplified version of the <code class="inline">assert</code> macro. This is an interesting macro because it literally reinterprets the meaning of comparison operators. Normally, when you write <code class="inline">a == b</code> you get a boolean result. However, when this expression is given to the <code class="inline">assert</code> macro, a detailed output is printed if the expression evaluates to <code class="inline">false</code>.</p>
<p>
I’ll start simple, by supporting only <code class="inline">==</code> operator in the macro. To recap, when we call <code class="inline">assert expected == required</code>, it’s the same as calling <code class="inline">assert(expected == required)</code>, which means that our macro receives a quoted fragment that represents comparison. Let’s discover the AST structure of this comparison:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6269332939-1">do</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k" data-group-id="6269332939-1">end</span><span class="w">
</span><span class="p" data-group-id="6269332939-2">{</span><span class="ss">:==</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6269332939-3">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="6269332939-3">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6269332939-4">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="6269332939-4">]</span><span class="p" data-group-id="6269332939-2">}</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6269332939-5">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="6269332939-5">end</span><span class="w">
</span><span class="p" data-group-id="6269332939-6">{</span><span class="ss">:==</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6269332939-7">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="6269332939-7">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6269332939-8">[</span><span class="p" data-group-id="6269332939-9">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6269332939-10">[</span><span class="p" data-group-id="6269332939-10">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="6269332939-9">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6269332939-11">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6269332939-12">[</span><span class="p" data-group-id="6269332939-12">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="6269332939-11">}</span><span class="p" data-group-id="6269332939-8">]</span><span class="p" data-group-id="6269332939-6">}</span></code></pre>
<p>
So our structure is essentially, <code class="inline">{:==, context, [quoted_lhs, quoted_rhs]}</code>. This should not be surprising if you remember the examples shown in previous section, where I’ve mentioned that binary operators are quoted as two arguments function calls.</p>
<p>
Knowing the AST shape, it’s relatively simple to write the macro:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Assertions</span><span class="w"> </span><span class="k" data-group-id="4219679891-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">assert</span><span class="p" data-group-id="4219679891-2">(</span><span class="p" data-group-id="4219679891-3">{</span><span class="ss">:==</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4219679891-4">[</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p" data-group-id="4219679891-4">]</span><span class="p" data-group-id="4219679891-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="4219679891-2">)</span><span class="w"> </span><span class="k" data-group-id="4219679891-5">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="4219679891-6">do</span><span class="w">
      </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4219679891-7">(</span><span class="n">lhs</span><span class="p" data-group-id="4219679891-7">)</span><span class="w">
      </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="4219679891-8">(</span><span class="n">rhs</span><span class="p" data-group-id="4219679891-8">)</span><span class="w">

      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4219679891-9">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="4219679891-9">)</span><span class="w">

      </span><span class="k">unless</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="k" data-group-id="4219679891-10">do</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;Assertion with == failed&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;code: </span><span class="si" data-group-id="4219679891-11">#{</span><span class="k">unquote</span><span class="p" data-group-id="4219679891-12">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="4219679891-13">(</span><span class="n">expr</span><span class="p" data-group-id="4219679891-13">)</span><span class="p" data-group-id="4219679891-12">)</span><span class="si" data-group-id="4219679891-11">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;lhs: </span><span class="si" data-group-id="4219679891-14">#{</span><span class="n">left</span><span class="si" data-group-id="4219679891-14">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;rhs: </span><span class="si" data-group-id="4219679891-15">#{</span><span class="n">right</span><span class="si" data-group-id="4219679891-15">}</span><span class="s">&quot;</span><span class="w">
      </span><span class="k" data-group-id="4219679891-10">end</span><span class="w">

      </span><span class="n">result</span><span class="w">
    </span><span class="k" data-group-id="4219679891-6">end</span><span class="w">
  </span><span class="k" data-group-id="4219679891-5">end</span><span class="w">
</span><span class="k" data-group-id="4219679891-1">end</span></code></pre>
<p>
The first interesting thing happens in line 2. Notice how we pattern match on the input expression, expecting it to conform to some structure. This is perfectly fine, since macros are functions, which means you can rely on pattern matching, guards, and even have multi-clause macros. In our case, we rely on pattern matching to take each (quoted) side of the comparison expression into corresponding variables.</p>
<p>
Then, in the quoted code, we reinterpret the <code class="inline">==</code> operation by computing left- and right-hand side  individually, (lines 4 and 5), and then the entire result (line 7). Finally, if the result is false, we print detailed informations (lines 9-14).</p>
<p>
Let’s try it out:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Assertions</span><span class="w"> </span><span class="k" data-group-id="8107652679-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="8107652679-1">end</span><span class="w">
</span><span class="gp unselectable">iex(2)&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nc">Assertions</span><span class="w">

</span><span class="gp unselectable">iex(3)&gt; </span><span class="n">assert</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="w">
</span><span class="nc">Assertion</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">failed</span><span class="w">
</span><span class="ss">code</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="ss">lhs</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="ss">rhs</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span></code></pre>
<h2>
Generalizing the code</h2>
<p>
It’s not much harder to make the code work for other operators:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Assertions</span><span class="w"> </span><span class="k" data-group-id="6926744223-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">assert</span><span class="p" data-group-id="6926744223-2">(</span><span class="p" data-group-id="6926744223-3">{</span><span class="n">operator</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6926744223-4">[</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p" data-group-id="6926744223-4">]</span><span class="p" data-group-id="6926744223-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="6926744223-2">)</span><span class="w">
    </span><span class="ow">when</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="6926744223-5">[</span><span class="ss">:==</span><span class="p">,</span><span class="w"> </span><span class="ss">:&lt;</span><span class="p">,</span><span class="w"> </span><span class="ss">:&gt;</span><span class="p">,</span><span class="w"> </span><span class="ss">:&lt;=</span><span class="p">,</span><span class="w"> </span><span class="ss">:&gt;=</span><span class="p">,</span><span class="w"> </span><span class="ss">:===</span><span class="p">,</span><span class="w"> </span><span class="ss">:=~</span><span class="p">,</span><span class="w"> </span><span class="ss">:!==</span><span class="p">,</span><span class="w"> </span><span class="ss">:!=</span><span class="p">,</span><span class="w"> </span><span class="ss">:in</span><span class="p" data-group-id="6926744223-5">]</span><span class="w">
  </span><span class="k" data-group-id="6926744223-6">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="6926744223-7">do</span><span class="w">
      </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6926744223-8">(</span><span class="n">lhs</span><span class="p" data-group-id="6926744223-8">)</span><span class="w">
      </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6926744223-9">(</span><span class="n">rhs</span><span class="p" data-group-id="6926744223-9">)</span><span class="w">

      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="6926744223-10">(</span><span class="n">operator</span><span class="p" data-group-id="6926744223-10">)</span><span class="p" data-group-id="6926744223-11">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p" data-group-id="6926744223-11">)</span><span class="w">

      </span><span class="k">unless</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="k" data-group-id="6926744223-12">do</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;Assertion with </span><span class="si" data-group-id="6926744223-13">#{</span><span class="k">unquote</span><span class="p" data-group-id="6926744223-14">(</span><span class="n">operator</span><span class="p" data-group-id="6926744223-14">)</span><span class="si" data-group-id="6926744223-13">}</span><span class="s"> failed&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;code: </span><span class="si" data-group-id="6926744223-15">#{</span><span class="k">unquote</span><span class="p" data-group-id="6926744223-16">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="6926744223-17">(</span><span class="n">expr</span><span class="p" data-group-id="6926744223-17">)</span><span class="p" data-group-id="6926744223-16">)</span><span class="si" data-group-id="6926744223-15">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;lhs: </span><span class="si" data-group-id="6926744223-18">#{</span><span class="n">left</span><span class="si" data-group-id="6926744223-18">}</span><span class="s">&quot;</span><span class="w">
        </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;rhs: </span><span class="si" data-group-id="6926744223-19">#{</span><span class="n">right</span><span class="si" data-group-id="6926744223-19">}</span><span class="s">&quot;</span><span class="w">
      </span><span class="k" data-group-id="6926744223-12">end</span><span class="w">

      </span><span class="n">result</span><span class="w">
    </span><span class="k" data-group-id="6926744223-7">end</span><span class="w">
  </span><span class="k" data-group-id="6926744223-6">end</span><span class="w">
</span><span class="k" data-group-id="6926744223-1">end</span></code></pre>
<p>
There are only a couple of changes here. First, in the pattern-match, the hard-coded <code class="inline">:==</code> is replaced with the <code class="inline">operator</code> variable (line 2).</p>
<p>
I’ve also introduced (or to be honest, copy-pasted from Elixir source) guards specifying the set of operators for which the macro works (line 3). There is a special reason for this check. Remember how I earlier mentioned that quoted <code class="inline">a + b</code> (and any other binary operation) has the same shape as quoted <code class="inline">fun(a,b)</code>. Consequently, without these guards, every two-arguments function call would end up in our macro, and this is something we probably don’t want. Using this guard limits allowed inputs only to known binary operators.</p>
<p>
The interesting thing happens in line 9. Here I make a simple generic dispatch to the operator using <code class="inline">unquote(operator)(left, right)</code>. You might think that I could have instead used <code class="inline">left unquote(operator) right</code>, but this wouldn’t work. The reason is that <code class="inline">operator</code> variable holds an atom (e.g. <code class="inline">:==</code>). Thus, this naive quoting would produce <code class="inline">left :== right</code>, which is not even a proper Elixir syntax.</p>
<p>
Keep in mind that while quoting, we don’t assemble strings, but AST fragments. So instead, when we want to generate a binary operation code, we need to inject a proper AST, which (as explained earlier) is the same as the two arguments function call. Hence, we can simply generate the function call <code class="inline">unquote(operator)(left, right)</code>.</p>
<p>
With this in mind, I’m going to finish today’s session. It was a bit shorter, but slightly more complex. <a href="macros_4">Next time</a>, I’m going to dive a bit deeper into the topic of AST parsing.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/macros_3">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/macros_3.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Sun, 15 Jun 2014 00:00:00 +0000</pubDate></item><item><title>Understanding Elixir Macros, Part 2 - Micro Theory</title><link>http://theerlangelist.com//article/macros_2</link><description><![CDATA[<h1>Understanding Elixir Macros, Part 2 - Micro Theory</h1>
<h4 class="right">2014-06-11</h4>

<div class="article-body">
<p>
This is the second part of the mini-series on Elixir macros. <a href="macros_1">Last time</a> I discussed compilation phases and Elixir AST, finishing with a basic example of the <code class="inline">trace</code> macro. Today, I’ll provide a bit more details on macro mechanics.</p>
<p>
This is going to involve repeating some of the stuff mentioned last time, but I think it’s beneficial to understand how things work and how the final AST is built. If you grasp this, you can reason about your macro code with more confidence. This becomes important, since more involved macros will consist of many combined <code class="inline">quote</code>/<code class="inline">unquote</code> constructs which can at first seem intimidating.</p>
<h2>
Calling a macro</h2>
<p>
The most important thing to be aware of is the expansion phase. This is where compiler calls various macros (and other code-generating constructs) to produce the final AST.</p>
<p>
For example, a typical usage of the <code class="inline">trace</code> macro will look like this:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyModule</span><span class="w"> </span><span class="k" data-group-id="9471444740-1">do</span><span class="w">
  </span><span class="kn">require</span><span class="w"> </span><span class="nc">Tracer</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">some_fun</span><span class="p" data-group-id="9471444740-2">(</span><span class="n">...</span><span class="p" data-group-id="9471444740-2">)</span><span class="w"> </span><span class="k" data-group-id="9471444740-3">do</span><span class="w">
    </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">trace</span><span class="p" data-group-id="9471444740-4">(</span><span class="n">...</span><span class="p" data-group-id="9471444740-4">)</span><span class="w">
  </span><span class="k" data-group-id="9471444740-3">end</span><span class="w">
</span><span class="k" data-group-id="9471444740-1">end</span></code></pre>
<p>
As previously explained, the compiler starts with an AST that resembles this code. This AST is then expanded to produce the final code. Consequently, in the snippet above, the call to <code class="inline">Tracer.trace/1</code> will take place in the expansion phase.</p>
<p>
Our macro receives the input AST and must produce the output AST. The compiler will then simply replace the macro call with the AST returned from that macro. This process is incremental - a macro can return AST that will invoke some other macro (or even itself). The compiler will simply re-expand until there’s nothing left to expand.</p>
<p>
A macro call is thus our opportunity to change the meaning of the code. A typical macro will take the input AST and somehow decorate it, adding some additional code around the input.</p>
<p>
That’s exactly what we did in the <code class="inline">trace</code> macro. We took a quoted expression (e.g. <code class="inline">1+2</code>) and spit out something like:</p>
<pre><code class="highlight makeup elixir"><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="nc">Tracer</span><span class="o">.</span><span class="n">print</span><span class="p" data-group-id="1921789311-1">(</span><span class="s">&quot;1 + 2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="1921789311-1">)</span><span class="w">
</span><span class="n">result</span></code></pre>
<p>
To call the <code class="inline">trace</code> macro from any part of the code (including shell), you must invoke either <code class="inline">require Tracer</code> or <code class="inline">import Tracer</code>. Why is this? There are two seemingly contradicting properties of macros:</p>
<ul>
  <li>
A macro is an Elixir code  </li>
  <li>
A macro runs in expansion time, before the final bytecode is produced  </li>
</ul>
<p>
How can Elixir code run before it is produced? It can’t. To call a macro, the container module (the module where the macro is defined) must already be compiled.</p>
<p>
Consequently, to run macros defined in the <code class="inline">Tracer</code> module, we must ensure that it is already compiled. In other words, we must provide some hints to the compiler about the module ordering. When we require a module, we instruct the Elixir to hold the compilation of the current module until the required module is compiled and loaded into the compiler run-time (the Erlang VM instance where compiler is running). We can only call <code class="inline">trace</code> macro when the <code class="inline">Tracer</code> module is fully compiled, and available to the compiler.</p>
<p>
Using <code class="inline">import</code> has the same effect but it additionally lexically imports all exported functions and macros, making it possible to write <code class="inline">trace</code> instead of <code class="inline">Tracer.trace</code>.</p>
<p>
Since macros are functions and Elixir doesn’t require parentheses in function calls, we can use this syntax:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Tracer</span><span class="o">.</span><span class="n">trace</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span></code></pre>
<p>
This is quite possibly the most important reason why Elixir doesn’t require parentheses in function calls. Remember that most language constructs are actually macros. If parentheses were obligatory, the code we’d have to write would be noisier:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="p" data-group-id="5549561817-1">(</span><span class="nc">MyModule</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w">
  </span><span class="kd">def</span><span class="p" data-group-id="5549561817-2">(</span><span class="n">function_1</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="5549561817-2">)</span><span class="w">
  </span><span class="kd">def</span><span class="p" data-group-id="5549561817-3">(</span><span class="n">function_2</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="5549561817-3">)</span><span class="w">
</span><span class="p" data-group-id="5549561817-1">)</span></code></pre>
<h2>
Hygiene</h2>
<p>
As hinted in the last article, macros are by default hygienic. This means that variables introduced by a macro are its own private affair that won’t interfere with the rest of the code. This is why we can safely introduce the <code class="inline">result</code> variable in our <code class="inline">trace</code> macro:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="2459300382-1">do</span><span class="w">
  </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="2459300382-2">(</span><span class="n">expression_ast</span><span class="p" data-group-id="2459300382-2">)</span><span class="w">  </span><span class="c1"># result is private to this macro</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="2459300382-1">end</span></code></pre>
<p>
This variable won’t interfere with the code that is calling the macro. In place where you call the trace macro, you can freely declare your own <code class="inline">result</code> variable, and it won’t be shadowed by the <code class="inline">result</code> from the tracer macro.</p>
<p>
Most of the time hygiene is exactly what you want, but there are exceptions. Sometimes, you may need to create a variable that is available to the code calling the macro. Instead of devising some contrived example, let’s take a look at the real use case from the Plug library. This is how we can specify routes with Plug router:</p>
<pre><code class="highlight makeup elixir"><span class="n">get</span><span class="w"> </span><span class="s">&quot;/resource1&quot;</span><span class="w"> </span><span class="k" data-group-id="4241539860-1">do</span><span class="w">
  </span><span class="n">send_resp</span><span class="p" data-group-id="4241539860-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="4241539860-2">)</span><span class="w">
</span><span class="k" data-group-id="4241539860-1">end</span><span class="w">

</span><span class="n">post</span><span class="w"> </span><span class="s">&quot;/resource2&quot;</span><span class="w"> </span><span class="k" data-group-id="4241539860-3">do</span><span class="w">
  </span><span class="n">send_resp</span><span class="p" data-group-id="4241539860-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="4241539860-4">)</span><span class="w">
</span><span class="k" data-group-id="4241539860-3">end</span></code></pre>
<p>
Notice how in both snippets we use <code class="inline">conn</code> variable that doesn’t exist. This is possible because <code class="inline">get</code> macro binds this variable in the generated code. You can imagine that the resulting code is something like:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defp</span><span class="w"> </span><span class="nf">do_match</span><span class="p" data-group-id="7841720397-1">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/resource1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">conn</span><span class="p" data-group-id="7841720397-1">)</span><span class="w"> </span><span class="k" data-group-id="7841720397-2">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="7841720397-2">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_match</span><span class="p" data-group-id="7841720397-3">(</span><span class="s">&quot;POST&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/resource2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">conn</span><span class="p" data-group-id="7841720397-3">)</span><span class="w"> </span><span class="k" data-group-id="7841720397-4">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="7841720397-4">end</span></code></pre>
<p>
<em>Note: the real code produced by Plug is somewhat different, this is just a simplification.</em></p>
<p>
This is an example of a macro introducing a variable that must not be hygienic. The variable <code class="inline">conn</code> is introduced by the <code class="inline">get</code> macro, but must be visible to the code where the macro is called.</p>
<p>
Another example is the situation I had with ExActor. Take a look a the following example:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyServer</span><span class="w"> </span><span class="k" data-group-id="3674782817-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="n">defcall</span><span class="w"> </span><span class="n">my_request</span><span class="p" data-group-id="3674782817-2">(</span><span class="n">...</span><span class="p" data-group-id="3674782817-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">reply</span><span class="p" data-group-id="3674782817-3">(</span><span class="n">result</span><span class="p" data-group-id="3674782817-3">)</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="3674782817-1">end</span></code></pre>
<p>
If you’re familiar with <code class="inline">GenServer</code> then you know that the result of a call must be in form <code class="inline">{:reply, response, state}</code>. However, in the snippet above, the state is not even mentioned. So how can we return the non-mentioned state? This is possible, because <code class="inline">defcall</code> macro generates a hidden state variable, which is then implicitly used by the <code class="inline">reply</code> macro.</p>
<p>
In both cases, a macro must create a variable that is not hygienic and must be visible beyond macro’s quoted code. For such purposes you can use <code class="inline">var!</code> construct. Here’s how a simple version of the Plug’s <code class="inline">get</code> macro could look like:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="1659233453-1">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="1659233453-1">)</span><span class="w"> </span><span class="k" data-group-id="1659233453-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1659233453-3">do</span><span class="w">
    </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_match</span><span class="p" data-group-id="1659233453-4">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="1659233453-5">(</span><span class="n">route</span><span class="p" data-group-id="1659233453-5">)</span><span class="p">,</span><span class="w"> </span><span class="n">var!</span><span class="p" data-group-id="1659233453-6">(</span><span class="n">conn</span><span class="p" data-group-id="1659233453-6">)</span><span class="p" data-group-id="1659233453-4">)</span><span class="w"> </span><span class="k" data-group-id="1659233453-7">do</span><span class="w">
      </span><span class="c1"># put body AST here</span><span class="w">
    </span><span class="k" data-group-id="1659233453-7">end</span><span class="w">
  </span><span class="k" data-group-id="1659233453-3">end</span><span class="w">
</span><span class="k" data-group-id="1659233453-2">end</span></code></pre>
<p>
Notice how we use <code class="inline">var!(conn)</code>. By doing this, we’re specifying that <code class="inline">conn</code> is a variable that must be visible to the caller.</p>
<p>
In the snippet above, it’s not explained how the body is injected. Before doing so, you must understand a bit about arguments that macros receive.</p>
<h2>
Macro arguments</h2>
<p>
You should always keep in mind that macros are essentially Elixir functions that are invoked in expansion phase, while the final AST is being produced. The specifics of macros is that arguments being passed are always quoted. This is why we can call:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">my_fun</span><span class="w"> </span><span class="k" data-group-id="9687616116-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="9687616116-1">end</span></code></pre>
<p>
Which is the same as:</p>
<pre><code class="highlight makeup elixir"><span class="kd">def</span><span class="p" data-group-id="7481168726-1">(</span><span class="n">my_fun</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7481168726-2">(</span><span class="n">...</span><span class="p" data-group-id="7481168726-2">)</span><span class="p" data-group-id="7481168726-1">)</span></code></pre>
<p>
Notice how we’re calling the <code class="inline">def</code> macro, passing <code class="inline">my_fun</code> even when this variable doesn’t exist. This is completely fine, since we’re actually passing the result of <code class="inline">quote(do: my_fun)</code>, and quoting doesn’t require that the variable exists. Internally, <code class="inline">def</code> macro will receive the quoted representation which will, among other things, contain <code class="inline">:my_fun</code>. The <code class="inline">def</code> macro will use this information to generate the function with the corresponding name.</p>
<p>
Another thing I sort of skimmed over is the <code class="inline">do…end</code> block. Whenever you pass a <code class="inline">do…end</code> block to a macro, it is the same as passing a keywords list with a <code class="inline">:do</code> key.</p>
<p>
So the call</p>
<pre><code class="highlight makeup elixir"><span class="n">my_macro</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="k" data-group-id="4499183255-1">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="4499183255-1">end</span></code></pre>
<p>
is the same as</p>
<pre><code class="highlight makeup elixir"><span class="n">my_macro</span><span class="p" data-group-id="3295720323-1">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="3295720323-1">)</span></code></pre>
<p>
This is just a special syntactical sugar of Elixir. The parser transforms <code class="inline">do..end</code> into <code class="inline">{:do, …}</code>.</p>
<p>
Now, I’ve just mentioned that arguments are quoted. However, for many constants (atoms, numbers, strings), the quoted representation is exactly the same as the input value. In addition, two element tuples and lists will retain their structure when quoted. This means that <code class="inline">quote(do: {a,b})</code> will give a two element tuple, with both values being of course quoted.</p>
<p>
Let’s illustrate this in a shell:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3886364279-1">do</span><span class="w"> </span><span class="ss">:an_atom</span><span class="w"> </span><span class="k" data-group-id="3886364279-1">end</span><span class="w">
</span><span class="ss">:an_atom</span><span class="w">

</span><span class="gp unselectable">iex(2)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3886364279-2">do</span><span class="w"> </span><span class="s">&quot;a string&quot;</span><span class="w"> </span><span class="k" data-group-id="3886364279-2">end</span><span class="w">
</span><span class="s">&quot;a string&quot;</span><span class="w">

</span><span class="gp unselectable">iex(3)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3886364279-3">do</span><span class="w"> </span><span class="mf">3.14</span><span class="w"> </span><span class="k" data-group-id="3886364279-3">end</span><span class="w">
</span><span class="mf">3.14</span><span class="w">

</span><span class="gp unselectable">iex(4)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3886364279-4">do</span><span class="w"> </span><span class="p" data-group-id="3886364279-5">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="3886364279-5">}</span><span class="w"> </span><span class="k" data-group-id="3886364279-4">end</span><span class="w">
</span><span class="p" data-group-id="3886364279-6">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3886364279-6">}</span><span class="w">

</span><span class="gp unselectable">iex(5)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3886364279-7">do</span><span class="w"> </span><span class="p" data-group-id="3886364279-8">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="3886364279-8">]</span><span class="w"> </span><span class="k" data-group-id="3886364279-7">end</span><span class="w">
</span><span class="p" data-group-id="3886364279-9">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="3886364279-9">]</span></code></pre>
<p>
In contrast, a quoted three element tuple doesn’t retain its shape:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(6)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3487763886-1">do</span><span class="w"> </span><span class="p" data-group-id="3487763886-2">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="3487763886-2">}</span><span class="w"> </span><span class="k" data-group-id="3487763886-1">end</span><span class="w">
</span><span class="p" data-group-id="3487763886-3">{</span><span class="ss">:{}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3487763886-4">[</span><span class="p" data-group-id="3487763886-4">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3487763886-5">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="3487763886-5">]</span><span class="p" data-group-id="3487763886-3">}</span></code></pre>
<p>
Since lists and two element tuples retain their structure when quoted, the same holds for a keyword list:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(7)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1328618254-1">do</span><span class="w"> </span><span class="p" data-group-id="1328618254-2">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1328618254-2">]</span><span class="w"> </span><span class="k" data-group-id="1328618254-1">end</span><span class="w">
</span><span class="p" data-group-id="1328618254-3">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1328618254-3">]</span><span class="w">

</span><span class="gp unselectable">iex(8)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1328618254-4">do</span><span class="w"> </span><span class="p" data-group-id="1328618254-5">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="1328618254-5">]</span><span class="w"> </span><span class="k" data-group-id="1328618254-4">end</span><span class="w">
</span><span class="p" data-group-id="1328618254-6">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1328618254-7">{</span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1328618254-8">[</span><span class="p" data-group-id="1328618254-8">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="1328618254-7">}</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1328618254-9">{</span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1328618254-10">[</span><span class="p" data-group-id="1328618254-10">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="1328618254-9">}</span><span class="p" data-group-id="1328618254-6">]</span></code></pre>
<p>
In the first example, you can see that the input keyword list is completely intact. The second example proves that complex members (such as references to <code class="inline">x</code> and <code class="inline">y</code>) are quoted. But the list still retains its shape. It is still a keyword lists with keys <code class="inline">:a</code> and <code class="inline">:b</code>.</p>
<h2>
Putting it together</h2>
<p>
Why is all this important? Because in the macro code, you can easily retrieve the options from the keywords list, without analyzing some convoluted AST. Let’s see this in action on our oversimplified take on <code class="inline">get</code> macro. Earlier, we left with this sketch:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="0437850208-1">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="0437850208-1">)</span><span class="w"> </span><span class="k" data-group-id="0437850208-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0437850208-3">do</span><span class="w">
    </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_match</span><span class="p" data-group-id="0437850208-4">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0437850208-5">(</span><span class="n">route</span><span class="p" data-group-id="0437850208-5">)</span><span class="p">,</span><span class="w"> </span><span class="n">var!</span><span class="p" data-group-id="0437850208-6">(</span><span class="n">conn</span><span class="p" data-group-id="0437850208-6">)</span><span class="p" data-group-id="0437850208-4">)</span><span class="w"> </span><span class="k" data-group-id="0437850208-7">do</span><span class="w">
      </span><span class="c1"># put body AST here</span><span class="w">
    </span><span class="k" data-group-id="0437850208-7">end</span><span class="w">
  </span><span class="k" data-group-id="0437850208-3">end</span><span class="w">
</span><span class="k" data-group-id="0437850208-2">end</span></code></pre>
<p>
Remember that <code class="inline">do…end</code> is the same as <code class="inline">do: …</code> so when we call <code class="inline">get route do … end</code>, we’re effectively calling <code class="inline">get(route, do: …)</code>. Keeping in mind that macro arguments are quoted, but also knowing that quoted keyword lists keep their shape, it’s possible to retrieve the quoted body in the macro using <code class="inline">body[:do]</code>:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="5104645303-1">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="5104645303-1">)</span><span class="w"> </span><span class="k" data-group-id="5104645303-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5104645303-3">do</span><span class="w">
    </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_match</span><span class="p" data-group-id="5104645303-4">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5104645303-5">(</span><span class="n">route</span><span class="p" data-group-id="5104645303-5">)</span><span class="p">,</span><span class="w"> </span><span class="n">var!</span><span class="p" data-group-id="5104645303-6">(</span><span class="n">conn</span><span class="p" data-group-id="5104645303-6">)</span><span class="p" data-group-id="5104645303-4">)</span><span class="w"> </span><span class="k" data-group-id="5104645303-7">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="5104645303-8">(</span><span class="n">body</span><span class="p" data-group-id="5104645303-9">[</span><span class="ss">:do</span><span class="p" data-group-id="5104645303-9">]</span><span class="p" data-group-id="5104645303-8">)</span><span class="w">
    </span><span class="k" data-group-id="5104645303-7">end</span><span class="w">
  </span><span class="k" data-group-id="5104645303-3">end</span><span class="w">
</span><span class="k" data-group-id="5104645303-2">end</span></code></pre>
<p>
So we simply inject the quoted input body into the body of the <code class="inline">do_match</code> clause we’re generating.</p>
<p>
As already mentioned, this is the purpose of a macro. It receives some AST fragments, and combines them together with the boilerplate code, to generate the final result. Ideally, when we do this, we don’t care about the contents of the input AST. In our example, we simply inject the body in the generated function, without caring what is actually in that body.</p>
<p>
It is reasonably simple to test that this macro works. Here’s a bare minimum of the required code:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Plug.Router</span><span class="w"> </span><span class="k" data-group-id="5732101583-1">do</span><span class="w">
  </span><span class="c1"># get macro removes the boilerplate from the client and ensures that</span><span class="w">
  </span><span class="c1"># generated code conforms to some standard required by the generic logic</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="5732101583-2">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="5732101583-2">)</span><span class="w"> </span><span class="k" data-group-id="5732101583-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5732101583-4">do</span><span class="w">
      </span><span class="kd">defp</span><span class="w"> </span><span class="nf">do_match</span><span class="p" data-group-id="5732101583-5">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5732101583-6">(</span><span class="n">route</span><span class="p" data-group-id="5732101583-6">)</span><span class="p">,</span><span class="w"> </span><span class="n">var!</span><span class="p" data-group-id="5732101583-7">(</span><span class="n">conn</span><span class="p" data-group-id="5732101583-7">)</span><span class="p" data-group-id="5732101583-5">)</span><span class="w"> </span><span class="k" data-group-id="5732101583-8">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="5732101583-9">(</span><span class="n">body</span><span class="p" data-group-id="5732101583-10">[</span><span class="ss">:do</span><span class="p" data-group-id="5732101583-10">]</span><span class="p" data-group-id="5732101583-9">)</span><span class="w">
      </span><span class="k" data-group-id="5732101583-8">end</span><span class="w">
    </span><span class="k" data-group-id="5732101583-4">end</span><span class="w">
  </span><span class="k" data-group-id="5732101583-3">end</span><span class="w">
</span><span class="k" data-group-id="5732101583-1">end</span></code></pre>
<p>
Now we can implement a client module:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyRouter</span><span class="w"> </span><span class="k" data-group-id="0739517012-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Plug.Router</span><span class="w">

  </span><span class="c1"># Generic code that relies on the multi-clause dispatch</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">match</span><span class="p" data-group-id="0739517012-2">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">route</span><span class="p" data-group-id="0739517012-2">)</span><span class="w"> </span><span class="k" data-group-id="0739517012-3">do</span><span class="w">
    </span><span class="n">do_match</span><span class="p" data-group-id="0739517012-4">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="ss">:dummy_connection</span><span class="p" data-group-id="0739517012-4">)</span><span class="w">
  </span><span class="k" data-group-id="0739517012-3">end</span><span class="w">

  </span><span class="c1"># Using macro to minimize boilerplate</span><span class="w">
  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0739517012-5">{</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hi!&quot;</span><span class="p" data-group-id="0739517012-5">}</span><span class="w">
  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/goodbye&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0739517012-6">{</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Bye!&quot;</span><span class="p" data-group-id="0739517012-6">}</span><span class="w">
</span><span class="k" data-group-id="0739517012-1">end</span></code></pre>
<p>
And test it:</p>
<pre><code class="highlight makeup elixir"><span class="nc">MyRouter</span><span class="o">.</span><span class="n">match</span><span class="p" data-group-id="5688976918-1">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/hello&quot;</span><span class="p" data-group-id="5688976918-1">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="w">
</span><span class="c1"># {:dummy_connection, &quot;Hi!&quot;}</span><span class="w">

</span><span class="nc">MyRouter</span><span class="o">.</span><span class="n">match</span><span class="p" data-group-id="5688976918-2">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/goodbye&quot;</span><span class="p" data-group-id="5688976918-2">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span><span class="w">
</span><span class="c1"># {:dummy_connection, &quot;Bye!&quot;}</span></code></pre>
<p>
The important thing to notice here is the code of <code class="inline">match/2</code>. This is the generic code that relies on the existence of the implementation of <code class="inline">do_match/3</code>.</p>
<h2>
Using modules</h2>
<p>
Looking at the code above, you can see that the glue code of <code class="inline">match/2</code> is developed in the client module. That’s definitely far from perfect, since each client must provide correct implementation of this function, and be aware of how <code class="inline">do_match</code> function must be invoked.</p>
<p>
It would be better if <code class="inline">Plug.Router</code> abstraction could provide this implementation for us. For that purpose we can reach for the <code class="inline">use</code> macro, a rough equivalent of mixins in other languages.</p>
<p>
The general idea is as follows:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">ClientCode</span><span class="w"> </span><span class="k" data-group-id="9555461823-1">do</span><span class="w">
  </span><span class="c1"># invokes the mixin</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">GenericCode</span><span class="p">,</span><span class="w"> </span><span class="ss">option_1</span><span class="p">:</span><span class="w"> </span><span class="n">value_1</span><span class="p">,</span><span class="w"> </span><span class="ss">option_2</span><span class="p">:</span><span class="w"> </span><span class="n">value_2</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="9555461823-1">end</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">GenericCode</span><span class="w"> </span><span class="k" data-group-id="9555461823-2">do</span><span class="w">
  </span><span class="c1"># called when the module is used</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">__using__</span><span class="p" data-group-id="9555461823-3">(</span><span class="n">options</span><span class="p" data-group-id="9555461823-3">)</span><span class="w"> </span><span class="k" data-group-id="9555461823-4">do</span><span class="w">
    </span><span class="c1"># generates an AST that will be inserted in place of the use</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9555461823-5">do</span><span class="w">
      </span><span class="n">...</span><span class="w">
    </span><span class="k" data-group-id="9555461823-5">end</span><span class="w">
  </span><span class="k" data-group-id="9555461823-4">end</span><span class="w">
</span><span class="k" data-group-id="9555461823-2">end</span></code></pre>
<p>
So the <code class="inline">use</code> mechanism allows us to inject some piece of code into the caller’s context. This is just a replacement for something like:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">ClientCode</span><span class="w"> </span><span class="k" data-group-id="9527268062-1">do</span><span class="w">
  </span><span class="kn">require</span><span class="w"> </span><span class="nc">GenericCode</span><span class="w">
  </span><span class="nc">GenericCode</span><span class="o">.</span><span class="c">__using__</span><span class="p" data-group-id="9527268062-2">(</span><span class="n">...</span><span class="p" data-group-id="9527268062-2">)</span><span class="w">
</span><span class="k" data-group-id="9527268062-1">end</span></code></pre>
<p>
Which can be proven by looking <a href="https://github.com/elixir-lang/elixir/blob/v0.14.0/lib/elixir/lib/kernel.ex#L3531-L3532">in Elixir source code</a>. This proves another point - that of incremental expansion. The <code class="inline">use</code> macro generates the code which will call another macro. Or to put it more fancy, <code class="inline">use</code> generates a code that generates a code. As mentioned earlier, the compiler will simply reexpand this until there’s nothing left to be expanded.</p>
<p>
Armed with this knowledge, we can move the implementation of the <code class="inline">match</code> function to the generic <code class="inline">Plug.Router</code> module:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Plug.Router</span><span class="w"> </span><span class="k" data-group-id="5336859823-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">__using__</span><span class="p" data-group-id="5336859823-2">(</span><span class="c">_options</span><span class="p" data-group-id="5336859823-2">)</span><span class="w"> </span><span class="k" data-group-id="5336859823-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5336859823-4">do</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Plug.Router</span><span class="w">

      </span><span class="kd">def</span><span class="w"> </span><span class="nf">match</span><span class="p" data-group-id="5336859823-5">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">route</span><span class="p" data-group-id="5336859823-5">)</span><span class="w"> </span><span class="k" data-group-id="5336859823-6">do</span><span class="w">
        </span><span class="n">do_match</span><span class="p" data-group-id="5336859823-7">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="ss">:dummy_connection</span><span class="p" data-group-id="5336859823-7">)</span><span class="w">
      </span><span class="k" data-group-id="5336859823-6">end</span><span class="w">
    </span><span class="k" data-group-id="5336859823-4">end</span><span class="w">
  </span><span class="k" data-group-id="5336859823-3">end</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="5336859823-8">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="5336859823-8">)</span><span class="w"> </span><span class="k" data-group-id="5336859823-9">do</span><span class="w">
    </span><span class="n">...</span><span class="w"> </span><span class="c1"># This code remains the same</span><span class="w">
  </span><span class="k" data-group-id="5336859823-9">end</span><span class="w">
</span><span class="k" data-group-id="5336859823-1">end</span></code></pre>
<p>
This now keeps the client code very lean:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyRouter</span><span class="w"> </span><span class="k" data-group-id="7690245982-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Plug.Router</span><span class="w">

  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7690245982-2">{</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hi!&quot;</span><span class="p" data-group-id="7690245982-2">}</span><span class="w">
  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/goodbye&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7690245982-3">{</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Bye!&quot;</span><span class="p" data-group-id="7690245982-3">}</span><span class="w">
</span><span class="k" data-group-id="7690245982-1">end</span></code></pre>
<p>
As mentioned, the AST generated by the <code class="inline">__using__</code> macro will simply be injected in place of the <code class="inline">use Plug.Router</code> call. Take special note how we do <code class="inline">import Plug.Router</code> from the <code class="inline">__using__</code> macro. This is not strictly needed, but it allows the client to call <code class="inline">get</code> instead of <code class="inline">Plug.Router.get</code>.</p>
<p>
So what have we gained? The various boilerplate is now confined to the single place (<code class="inline">Plug.Router</code>). Not only does this simplify the client code, it also keeps the abstraction properly closed. The module <code class="inline">Plug.Router</code> ensures that whatever is generated by <code class="inline">get</code> macros fits properly with the generic code of <code class="inline">match</code>. As clients, we simply use the module and call into the provided macros to assemble our router.</p>
<p>
This concludes today’s session. Many details are not covered, but hopefully you have a better understanding of how macros integrate with the Elixir compiler. In the <a href="macros_3">next part</a> I’ll dive deeper and start exploring how we can tear apart the input AST.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/macros_2">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/macros_2.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Wed, 11 Jun 2014 00:00:00 +0000</pubDate></item><item><title>Understanding Elixir Macros, Part 1 - Basics</title><link>http://theerlangelist.com//article/macros_1</link><description><![CDATA[<h1>Understanding Elixir Macros, Part 1 - Basics</h1>
<h4 class="right">2014-06-06</h4>

<div class="article-body">
<p>
This is the first article in the miniseries that deals with macros. I originally planned on treating this topic in my upcoming <a href="https://www.manning.com/books/elixir-in-action-second-edition?a_aid=sjuric">Elixir in Action</a> book, but decided against it because the subject somehow doesn’t fit into the main theme of the book that is more focused on the underlying VM and crucial parts of OTP.</p>
<p>
Instead, I decided to provide a treatment on macros here. Personally, I find the subject of macros very interesting, and in this miniseries I’ll try to explain how they work, providing some basic techniques and advices on how to write them. While I’m convinced that writing macros is not very hard, it certainly requires a higher level of attention compared to plain Elixir code. Thus, I think it’s very helpful to understand some inner details of Elixir compiler. Knowing how things tick behind the scene makes it easier to reason about the meta-programming code.</p>
<p>
This will be a medium-level difficulty text. If you’re familiar with Elixir and Erlang, but are still somewhat confused about macros, then you’re in the right place. If you’re new to Elixir and Erlang, it’s probably better to start with something else, for example the <a href="https://elixir-lang.org/getting-started/introduction.html">Getting started guide</a>, or one of the available books.</p>
<h2>
Meta-programming</h2>
<p>
Chances are you’re already somewhat familiar with meta-programming in Elixir. The essential idea is that we have a code that generates code based on some input.</p>
<p>
Owing to macros we can write constructs like this one from <a href="https://github.com/elixir-lang/plug">Plug</a>:</p>
<pre><code class="highlight makeup elixir"><span class="n">get</span><span class="w"> </span><span class="s">&quot;/hello&quot;</span><span class="w"> </span><span class="k" data-group-id="8315247117-1">do</span><span class="w">
  </span><span class="n">send_resp</span><span class="p" data-group-id="8315247117-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p" data-group-id="8315247117-2">)</span><span class="w">
</span><span class="k" data-group-id="8315247117-1">end</span><span class="w">

</span><span class="n">match</span><span class="w"> </span><span class="bp">_</span><span class="w"> </span><span class="k" data-group-id="8315247117-3">do</span><span class="w">
  </span><span class="n">send_resp</span><span class="p" data-group-id="8315247117-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">404</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;oops&quot;</span><span class="p" data-group-id="8315247117-4">)</span><span class="w">
</span><span class="k" data-group-id="8315247117-3">end</span></code></pre>
<p>
or this from <a href="https://github.com/sasa1977/exactor">ExActor</a>:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">SumServer</span><span class="w"> </span><span class="k" data-group-id="6235194955-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExActor.GenServer</span><span class="w">

  </span><span class="n">defcall</span><span class="w"> </span><span class="n">sum</span><span class="p" data-group-id="6235194955-2">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="6235194955-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">reply</span><span class="p" data-group-id="6235194955-3">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p" data-group-id="6235194955-3">)</span><span class="w">
</span><span class="k" data-group-id="6235194955-1">end</span></code></pre>
<p>
In both cases, we are running some custom macro in compile time that will transform the original code to something else. Calls to Plug’s <code class="inline">get</code> and <code class="inline">match</code> will create a function, while ExActor’s <code class="inline">defcall</code> will generate two functions and the code that properly propagates arguments from the client process to the server.</p>
<p>
Elixir itself is heavily powered by macros. Many constructs, such as <code class="inline">defmodule</code>, <code class="inline">def</code>, <code class="inline">if</code>, <code class="inline">unless</code>, and even <a href="https://github.com/elixir-lang/elixir/blob/v0.13.3/lib/elixir/lib/kernel.ex#L2767"><code class="inline">defmacro</code></a> are actually macros. This keeps the language core minimal, and simplifies further extensions to the language.</p>
<p>
Related, but somewhat less known is the possibility to generate functions on the fly:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Fsm</span><span class="w"> </span><span class="k" data-group-id="0986781525-1">do</span><span class="w">
  </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="0986781525-2">[</span><span class="w">
    </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0986781525-3">{</span><span class="ss">:pause</span><span class="p">,</span><span class="w"> </span><span class="ss">:paused</span><span class="p" data-group-id="0986781525-3">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">running</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0986781525-4">{</span><span class="ss">:stop</span><span class="p">,</span><span class="w"> </span><span class="ss">:stopped</span><span class="p" data-group-id="0986781525-4">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">paused</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0986781525-5">{</span><span class="ss">:resume</span><span class="p">,</span><span class="w"> </span><span class="ss">:running</span><span class="p" data-group-id="0986781525-5">}</span><span class="w">
  </span><span class="p" data-group-id="0986781525-2">]</span><span class="w">

  </span><span class="k">for</span><span class="w"> </span><span class="p" data-group-id="0986781525-6">{</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0986781525-7">{</span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p" data-group-id="0986781525-7">}</span><span class="p" data-group-id="0986781525-6">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="k" data-group-id="0986781525-8">do</span><span class="w">
    </span><span class="kd">def</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0986781525-9">(</span><span class="n">action</span><span class="p" data-group-id="0986781525-9">)</span><span class="p" data-group-id="0986781525-10">(</span><span class="k">unquote</span><span class="p" data-group-id="0986781525-11">(</span><span class="n">state</span><span class="p" data-group-id="0986781525-11">)</span><span class="p" data-group-id="0986781525-10">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="0986781525-12">(</span><span class="n">next_state</span><span class="p" data-group-id="0986781525-12">)</span><span class="w">
  </span><span class="k" data-group-id="0986781525-8">end</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">initial</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:running</span><span class="w">
</span><span class="k" data-group-id="0986781525-1">end</span><span class="w">

</span><span class="nc">Fsm</span><span class="o">.</span><span class="n">initial</span><span class="w">
</span><span class="c1"># :running</span><span class="w">

</span><span class="nc">Fsm</span><span class="o">.</span><span class="n">initial</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Fsm</span><span class="o">.</span><span class="n">pause</span><span class="w">
</span><span class="c1"># :paused</span><span class="w">

</span><span class="nc">Fsm</span><span class="o">.</span><span class="n">initial</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Fsm</span><span class="o">.</span><span class="n">pause</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Fsm</span><span class="o">.</span><span class="n">pause</span><span class="w">
</span><span class="c1"># ** (FunctionClauseError) no function clause matching in Fsm.pause/1</span></code></pre>
<p>
Here, we have a declarative specification of an FSM that is (again in compile time) transformed into corresponding multi-clause functions.</p>
<p>
The similar technique is for example employed by Elixir to generate <code class="inline">String.Unicode</code> module. Essentially, this module is generated by reading <code class="inline">UnicodeData.txt</code> and <code class="inline">SpecialCasing.txt</code> files where codepoints are described. Based on the data from this file, various functions (e.g. <code class="inline">upcase</code>, <code class="inline">downcase</code>) are generated.</p>
<p>
In either case (macros or in-place code generation), we are performing some transformation of the abstract syntax tree structure in the middle of the compilation. To understand how this works, you need to learn a bit about compilation process and AST.</p>
<h2>
Compilation process</h2>
<p>
Roughly speaking, the compilation of Elixir code happens in three phases:</p>
<p>
  <img src="/images/compilation_process.png" alt="Compilation process" />
</p>
<p>
The input source code is parsed, and a corresponding abstract syntax tree (AST) is produced. The AST represents your code in form of nested Elixir terms. Then the expansion phase kicks off. It is in this phase that various built-in and custom macros are called to transform the input AST into the final version. Once this transformation is done, Elixir can produce final bytecode - a binary representation of your source program.</p>
<p>
This is just an approximation of the process. For example, Elixir compiler actually generates Erlang AST and relies on Erlang functions to transform it into a bytecode, but it’s not important to know exact details. However, I find this general picture helpful when reasoning about meta-programming code.</p>
<p>
The main point to understand is that meta-programming magic happens in the expansion phase. The compiler initially starts with an AST that closely resembles your original Elixir code, and then expands it to the final version.</p>
<p>
Another important takeaway from this diagram is that in Elixir, meta-programming stops after binaries are produced. Except for code upgrades or some dynamic code loading trickery (which is beyond the scope of this article), you can be sure that your code is not redefined. While meta-programming always introduces an invisible (or not so obvious) layer to the code, in Elixir this at least happens only in compile-time, and is thus independent of various execution paths of a program.</p>
<p>
Given that code transformation happens in compile time, it is relatively easy to reason about the final product, and meta-programming doesn’t interfere with static analysis tools, such as <a href="http://www.erlang.org/doc/man/dialyzer.html">dialyzer</a>. Compile-time meta-programming also means that we get no performance penalty. Once we get to run-time, the code is already shaped, and no meta-programming construct is running.</p>
<h2>
Creating AST fragments</h2>
<p>
So what is an Elixir AST. It is an Elixir term, a deep nested hierarchy that represents a syntactically correct Elixir code. To make things clearer, let’s see some examples. To generate an AST of some code, you can use <code class="inline">quote</code> special form:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="n">quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="4820283856-1">do</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k" data-group-id="4820283856-1">end</span><span class="w">
</span><span class="p" data-group-id="4820283856-2">{</span><span class="ss">:+</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4820283856-3">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="4820283856-3">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4820283856-4">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4820283856-4">]</span><span class="p" data-group-id="4820283856-2">}</span></code></pre>
<p>
Quote takes an arbitrarily complex Elixir expression and returns the corresponding AST fragment that describes that input code.</p>
<p>
In our case, the result is an AST fragment describing simple sum operation (<code class="inline">1+2</code>). This is often called a <em>quoted expression</em>.</p>
<p>
Most of the time you don’t need to understand the exact details of the quoted structure, but let’s take a look at this simple example. In this case our AST fragment is a triplet that consists of:</p>
<ul>
  <li>
An atom identifying the operation that will be invoked (<code class="inline">:+</code>)  </li>
  <li>
A context of the expression (e.g. imports and aliases). Most of the time you don’t need to understand this data  </li>
  <li>
The arguments (operands) of the operation  </li>
</ul>
<p>
The main point is that quoted expression is an Elixir term that describes the code. The compiler will use this to eventually generate the final bytecode.</p>
<p>
Though not very common, it is possible to evaluate a quoted expression:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="7045227576-1">(</span><span class="n">quoted</span><span class="p" data-group-id="7045227576-1">)</span><span class="w">
</span><span class="p" data-group-id="7045227576-2">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7045227576-3">[</span><span class="p" data-group-id="7045227576-3">]</span><span class="p" data-group-id="7045227576-2">}</span></code></pre>
<p>
The result tuple contains the result of the expression, and the list of variable bindings that are made in that expression.</p>
<p>
However, before the AST is somehow evaluated (which is usually done by the compiler), the quoted expression is not semantically verified. For example, when we write following expression:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(3)&gt; </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">
</span><span class="gt">** (RuntimeError) undefined function: a/0</span></code></pre>
<p>
We get an error, since there’s no variable (or function) called <code class="inline">a</code>.</p>
<p>
In contrast, if we quote the expression:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(3)&gt; </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3535038561-1">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="3535038561-1">end</span><span class="w">
</span><span class="p" data-group-id="3535038561-2">{</span><span class="ss">:+</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3535038561-3">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="3535038561-3">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3535038561-4">[</span><span class="p" data-group-id="3535038561-5">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3535038561-6">[</span><span class="p" data-group-id="3535038561-6">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="3535038561-5">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3535038561-7">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3535038561-8">[</span><span class="p" data-group-id="3535038561-8">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="3535038561-7">}</span><span class="p" data-group-id="3535038561-4">]</span><span class="p" data-group-id="3535038561-2">}</span></code></pre>
<p>
There’s no error. We have a quoted representation of <code class="inline">a+b</code>, which means we generated the term that describes the expression <code class="inline">a+b</code>, regardless of whether these variables exist or not. The final code is not yet emitted, so there’s no error.</p>
<p>
If we insert that representation into some part of the AST where <code class="inline">a</code> and <code class="inline">b</code> are valid identifiers, this code will be correct.</p>
<p>
Let’s try this out. First, we’ll quote the sum expression:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(4)&gt; </span><span class="n">sum_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1636632146-1">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="1636632146-1">end</span></code></pre>
<p>
Then we’ll make a quoted binding expression:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(5)&gt; </span><span class="n">bind_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1030022189-1">do</span><span class="w">
          </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="w">
          </span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="w">
        </span><span class="k" data-group-id="1030022189-1">end</span></code></pre>
<p>
Again, keep in mind that these are just quoted expressions. They are simply the data that describes the code, but nothing is yet evaluated. In particular, variables <code class="inline">a</code> and <code class="inline">b</code> don’t exist in the current shell session.</p>
<p>
To make these fragments work together, we must connect them:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(6)&gt; </span><span class="n">final_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="4393527942-1">do</span><span class="w">
          </span><span class="k">unquote</span><span class="p" data-group-id="4393527942-2">(</span><span class="n">bind_expr</span><span class="p" data-group-id="4393527942-2">)</span><span class="w">
          </span><span class="k">unquote</span><span class="p" data-group-id="4393527942-3">(</span><span class="n">sum_expr</span><span class="p" data-group-id="4393527942-3">)</span><span class="w">
        </span><span class="k" data-group-id="4393527942-1">end</span></code></pre>
<p>
Here we generate a new quoted expression that consists of whatever is in <code class="inline">bind_expr</code>, followed by whatever is in <code class="inline">sum_expr</code>. Essentially, we produced a new AST fragment that combines both expressions. Don’t worry about the <code class="inline">unquote</code> part - I’ll explain this in a bit.</p>
<p>
In the meantime, we can evaluate this final AST fragment:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(7)&gt; </span><span class="nc">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="p" data-group-id="2065157106-1">(</span><span class="n">final_expr</span><span class="p" data-group-id="2065157106-1">)</span><span class="w">
</span><span class="p" data-group-id="2065157106-2">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2065157106-3">[</span><span class="p" data-group-id="2065157106-4">{</span><span class="p" data-group-id="2065157106-5">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="2065157106-5">}</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="2065157106-4">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2065157106-6">{</span><span class="p" data-group-id="2065157106-7">{</span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="nc">Elixir</span><span class="p" data-group-id="2065157106-7">}</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2065157106-6">}</span><span class="p" data-group-id="2065157106-3">]</span><span class="p" data-group-id="2065157106-2">}</span></code></pre>
<p>
Again, the result consists of the result of an expression (<code class="inline">3</code>) and bindings list where we can see that our expression bound two variables <code class="inline">a</code> and <code class="inline">b</code> to the respective values of <code class="inline">1</code> and <code class="inline">2</code>.</p>
<p>
This is the core of meta-programming approach in Elixir. When meta-programming, we essentially compose various AST fragments to generate some alternate AST that represents the code we want to produce. In doing so, we’re most often not interested in the exact contents or structure of input AST fragments (the ones we combine). Instead, we use <code class="inline">quote</code> to generate and combine input fragments and generate some decorated code.</p>
<h2>
Unquoting</h2>
<p>
This is where <code class="inline">unquote</code> comes into play. Notice that whatever is inside the <code class="inline">quote</code> block is, well, quoted - turned into an AST fragment. This means we can’t normally inject the contents of some variable that exists outside of our quote. Looking at the example above, this wouldn’t work:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9026555818-1">do</span><span class="w">
  </span><span class="n">bind_expr</span><span class="w">
  </span><span class="n">sum_expr</span><span class="w">
</span><span class="k" data-group-id="9026555818-1">end</span></code></pre>
<p>
In this snippet, <code class="inline">quote</code> simply generates quoted references to <code class="inline">bind_expr</code> and <code class="inline">sum_expr</code> variables that must exist in the context where this AST will be interpreted. However, this is not what we want in our case. What we need is a way of directly injecting contents of <code class="inline">bind_expr</code> and <code class="inline">sum_expr</code> to corresponding places in the AST fragment we’re generating.</p>
<p>
That’s the purpose of <code class="inline">unquote(…)</code> - the expression inside parentheses is immediately evaluated, and inserted in place of the <code class="inline">unquote</code> call. This in turn means that the result of <code class="inline">unquote</code> must also be a valid AST fragment.</p>
<p>
Another way of looking at <code class="inline">unquote</code> is to treat it as an analogue to string interpolation (<code class="inline">#{}</code>). With strings you can do this:</p>
<pre><code class="highlight makeup elixir"><span class="s">&quot;... </span><span class="si" data-group-id="2725174850-1">#{</span><span class="n">some_expression</span><span class="si" data-group-id="2725174850-1">}</span><span class="s"> ... &quot;</span></code></pre>
<p>
Similarly, when quoting you can do this:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="7787483960-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="k">unquote</span><span class="p" data-group-id="7787483960-2">(</span><span class="n">some_expression</span><span class="p" data-group-id="7787483960-2">)</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="7787483960-1">end</span></code></pre>
<p>
In both cases, you evaluate an expression that must be valid in the current context, and inject the result in the expression you’re building (either string, or an AST fragment).</p>
<p>
It’s important to understand this, because <code class="inline">unquote</code> is not a reversal of a <code class="inline">quote</code>. While <code class="inline">quote</code> takes a code fragment and turns it into a quoted expression, <code class="inline">unquote</code> doesn’t do the opposite. If you want to turn a quoted expression into a string, you can use <code class="inline">Macro.to_string/1</code>.</p>
<h2>
Example: tracing expressions</h2>
<p>
Let’s combine this theory into a simple example. We’ll write a macro that can help us in debugging the code. Here’s how this macro can be used:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">trace</span><span class="p" data-group-id="5067442877-1">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="5067442877-1">)</span><span class="w">
</span><span class="nc">Result</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="mi">3</span></code></pre>
<p>
The <code class="inline">Tracer.trace</code> takes a given expression and prints it’s result to the screen. Then the result of the expression is returned.</p>
<p>
It’s important to realize that this is a macro, which means that input expression (<code class="inline">1 + 2</code>) will be transformed into something more elaborate - a code that prints the result and returns it. This transformation will happen in the expansion time, and the resulting bytecode will contain some decorated version of the input code.</p>
<p>
Before looking at the implementation, it might be helpful to imagine the final result. When we call <code class="inline">Tracer.trace(1+2)</code>, the resulting bytecode will correspond to something like this:</p>
<pre><code class="highlight makeup elixir"><span class="n">mangled_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="w">
</span><span class="nc">Tracer</span><span class="o">.</span><span class="n">print</span><span class="p" data-group-id="6676887684-1">(</span><span class="s">&quot;1+2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mangled_result</span><span class="p" data-group-id="6676887684-1">)</span><span class="w">
</span><span class="n">mangled_result</span></code></pre>
<p>
The name <code class="inline">mangled_result</code> indicates that Elixir compiler will somehow mangle all temporary variables we’re introducing in our macro. This is also known as the macro hygiene, and we’ll discuss later in this series (though not in this article).</p>
<p>
Given this template, here’s how the macro can be implemented:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="3689886752-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">trace</span><span class="p" data-group-id="3689886752-2">(</span><span class="n">expression_ast</span><span class="p" data-group-id="3689886752-2">)</span><span class="w"> </span><span class="k" data-group-id="3689886752-3">do</span><span class="w">
    </span><span class="n">string_representation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="3689886752-4">(</span><span class="n">expression_ast</span><span class="p" data-group-id="3689886752-4">)</span><span class="w">

    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3689886752-5">do</span><span class="w">
      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3689886752-6">(</span><span class="n">expression_ast</span><span class="p" data-group-id="3689886752-6">)</span><span class="w">
      </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">print</span><span class="p" data-group-id="3689886752-7">(</span><span class="k">unquote</span><span class="p" data-group-id="3689886752-8">(</span><span class="n">string_representation</span><span class="p" data-group-id="3689886752-8">)</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="3689886752-7">)</span><span class="w">
      </span><span class="n">result</span><span class="w">
    </span><span class="k" data-group-id="3689886752-5">end</span><span class="w">
  </span><span class="k" data-group-id="3689886752-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">print</span><span class="p" data-group-id="3689886752-9">(</span><span class="n">string_representation</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="3689886752-9">)</span><span class="w"> </span><span class="k" data-group-id="3689886752-10">do</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="s">&quot;Result of </span><span class="si" data-group-id="3689886752-11">#{</span><span class="n">string_representation</span><span class="si" data-group-id="3689886752-11">}</span><span class="s">: </span><span class="si" data-group-id="3689886752-12">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">result</span><span class="si" data-group-id="3689886752-12">}</span><span class="s">&quot;</span><span class="w">
  </span><span class="k" data-group-id="3689886752-10">end</span><span class="w">
</span><span class="k" data-group-id="3689886752-1">end</span></code></pre>
<p>
Let’s analyze this code one step at a time.</p>
<p>
First, we define the macro using <code class="inline">defmacro</code>. A macro is essentially a special kind of function. It’s name will be mangled, and this function is meant to be invoked only in the expansion phase (though you could theoretically still call it in run-time).</p>
<p>
Our macro receives a quoted expression. This is very important to keep in mind - whichever arguments you send to a macro, they will already be quoted. So when we call <code class="inline">Tracer.trace(1+2)</code>, our macro (which is a function) won’t receive <code class="inline">3</code>. Instead, the contents of <code class="inline">expression_ast</code> will be the result of <code class="inline">quote(do: 1+2)</code>.</p>
<p>
In line 3, we use <code class="inline">Macro.to_string/1</code> to compute the string representation of the received AST fragment. This is the kind of thing you can’t do with a plain function that is called in runtime. While its possible to call <code class="inline">Macro.to_string/1</code> in runtime, the problem is that we don’t have an access to AST anymore, and therefore don’t know what is the string representation of some expression.</p>
<p>
Once we have a string representation, we can generate and return the resulting AST, which is done from the <code class="inline">quote do … end</code> construct. The result of this is the quoted expression that will substitute the original <code class="inline">Tracer.trace(…)</code> call.</p>
<p>
Let’s look at this part closer:</p>
<pre><code class="highlight makeup elixir"><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3965891681-1">do</span><span class="w">
  </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3965891681-2">(</span><span class="n">expression_ast</span><span class="p" data-group-id="3965891681-2">)</span><span class="w">
  </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">print</span><span class="p" data-group-id="3965891681-3">(</span><span class="k">unquote</span><span class="p" data-group-id="3965891681-4">(</span><span class="n">string_representation</span><span class="p" data-group-id="3965891681-4">)</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="3965891681-3">)</span><span class="w">
  </span><span class="n">result</span><span class="w">
</span><span class="k" data-group-id="3965891681-1">end</span></code></pre>
<p>
If you understood the explanation of <code class="inline">unquote</code> then this is reasonably simple. We essentially inject the <code class="inline">expression_ast</code> (quoted <code class="inline">1+2</code>) into the fragment we’re generating, taking the result of the operation into the <code class="inline">result</code> variable. Then we print this together with the stringified expression (obtained via <code class="inline">Macro.to_string/1</code>), and finally return the result.</p>
<h2>
Expanding an AST</h2>
<p>
It is easy to observe how this connects in the shell. Start the <code class="inline">iex</code> shell and copy-paste the definition of the <code class="inline">Tracer</code> module above:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Tracer</span><span class="w"> </span><span class="k" data-group-id="6107310984-1">do</span><span class="w">
          </span><span class="n">...</span><span class="w">
        </span><span class="k" data-group-id="6107310984-1">end</span></code></pre>
<p>
Then, you must require the <code class="inline">Tracer</code> module:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="kn">require</span><span class="w"> </span><span class="nc">Tracer</span></code></pre>
<p>
Next, let’s quote a call to <code class="inline">trace</code> macro:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(3)&gt; </span><span class="n">quoted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0555842211-1">do</span><span class="w"> </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">trace</span><span class="p" data-group-id="0555842211-2">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p" data-group-id="0555842211-2">)</span><span class="w"> </span><span class="k" data-group-id="0555842211-1">end</span><span class="w">
</span><span class="p" data-group-id="0555842211-3">{</span><span class="p" data-group-id="0555842211-4">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0555842211-5">[</span><span class="p" data-group-id="0555842211-5">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0555842211-6">[</span><span class="p" data-group-id="0555842211-7">{</span><span class="ss">:__aliases__</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0555842211-8">[</span><span class="ss">alias</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="0555842211-8">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0555842211-9">[</span><span class="ss">:Tracer</span><span class="p" data-group-id="0555842211-9">]</span><span class="p" data-group-id="0555842211-7">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:trace</span><span class="p" data-group-id="0555842211-6">]</span><span class="p" data-group-id="0555842211-4">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0555842211-10">[</span><span class="p" data-group-id="0555842211-10">]</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="0555842211-11">[</span><span class="p" data-group-id="0555842211-12">{</span><span class="ss">:+</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0555842211-13">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="0555842211-13">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0555842211-14">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="0555842211-14">]</span><span class="p" data-group-id="0555842211-12">}</span><span class="p" data-group-id="0555842211-11">]</span><span class="p" data-group-id="0555842211-3">}</span></code></pre>
<p>
Now, this output looks a bit scary, and you usually don’t have to understand it. But if you look close enough, somewhere in this structure you can see a mention of <code class="inline">Tracer</code> and <code class="inline">trace</code>, which proves that this AST fragment corresponds to our original code, and is not yet expanded.</p>
<p>
Now, we can turn this AST into an expanded version, using <code class="inline">Macro.expand/2</code>:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(4)&gt; </span><span class="n">expanded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">expand</span><span class="p" data-group-id="4944312937-1">(</span><span class="n">quoted</span><span class="p">,</span><span class="w"> </span><span class="bp">__ENV__</span><span class="p" data-group-id="4944312937-1">)</span><span class="w">
</span><span class="p" data-group-id="4944312937-2">{</span><span class="ss">:__block__</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-3">[</span><span class="p" data-group-id="4944312937-3">]</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="4944312937-4">[</span><span class="p" data-group-id="4944312937-5">{</span><span class="ss">:=</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-6">[</span><span class="p" data-group-id="4944312937-6">]</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="4944312937-7">[</span><span class="p" data-group-id="4944312937-8">{</span><span class="ss">:result</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-9">[</span><span class="ss">counter</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="4944312937-9">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Tracer</span><span class="p" data-group-id="4944312937-8">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="4944312937-10">{</span><span class="ss">:+</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-11">[</span><span class="ss">context</span><span class="p">:</span><span class="w"> </span><span class="nc">Elixir</span><span class="p">,</span><span class="w"> </span><span class="ss">import</span><span class="p">:</span><span class="w"> </span><span class="nc">Kernel</span><span class="p" data-group-id="4944312937-11">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-12">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4944312937-12">]</span><span class="p" data-group-id="4944312937-10">}</span><span class="p" data-group-id="4944312937-7">]</span><span class="p" data-group-id="4944312937-5">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="4944312937-13">{</span><span class="p" data-group-id="4944312937-14">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-15">[</span><span class="p" data-group-id="4944312937-15">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-16">[</span><span class="p" data-group-id="4944312937-17">{</span><span class="ss">:__aliases__</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-18">[</span><span class="ss">alias</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p">,</span><span class="w"> </span><span class="ss">counter</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="4944312937-18">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-19">[</span><span class="ss">:Tracer</span><span class="p" data-group-id="4944312937-19">]</span><span class="p" data-group-id="4944312937-17">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:print</span><span class="p" data-group-id="4944312937-16">]</span><span class="p" data-group-id="4944312937-14">}</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="4944312937-20">[</span><span class="p" data-group-id="4944312937-20">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-21">[</span><span class="s">&quot;1 + 2&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-22">{</span><span class="ss">:result</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-23">[</span><span class="ss">counter</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="4944312937-23">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Tracer</span><span class="p" data-group-id="4944312937-22">}</span><span class="p" data-group-id="4944312937-21">]</span><span class="p" data-group-id="4944312937-13">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="4944312937-24">{</span><span class="ss">:result</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4944312937-25">[</span><span class="ss">counter</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="4944312937-25">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Tracer</span><span class="p" data-group-id="4944312937-24">}</span><span class="p" data-group-id="4944312937-4">]</span><span class="p" data-group-id="4944312937-2">}</span></code></pre>
<p>
This is now the fully expanded version of our code, and somewhere inside it you can see mentions of <code class="inline">result</code> (the temporary variable introduced by the macro), and the call to <code class="inline">Tracer.print/2</code>. You can even turn this expression into a string:</p>
<pre><code class="highlight makeup elixir"><span class="gp unselectable">iex(5)&gt; </span><span class="nc">Macro</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="3340523148-1">(</span><span class="n">expanded</span><span class="p" data-group-id="3340523148-1">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w">
</span><span class="p" data-group-id="3340523148-2">(</span><span class="w">
  </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="nc">Tracer</span><span class="o">.</span><span class="n">print</span><span class="p" data-group-id="3340523148-3">(</span><span class="s">&quot;1 + 2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="3340523148-3">)</span><span class="w">
  </span><span class="n">result</span><span class="w">
</span><span class="p" data-group-id="3340523148-2">)</span></code></pre>
<p>
The point of all this is to demonstrate that your macro call is really expanded to something else. This is how macros work. Though we only tried it from the shell, the same things happen when we’re building our projects with <code class="inline">mix</code> or <code class="inline">elixirc</code>.</p>
<p>
I guess this is enough for the first session. You’ve learned a bit about the compiler process and the AST, and seen a fairly simple example of a macro. In the <a href="macros_2">next installment</a>, I’ll dive a bit deeper, discussing some mechanical aspects of macros.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/macros_1">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/macros_1.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Fri, 6 Jun 2014 00:00:00 +0000</pubDate></item><item><title>Why Elixir</title><link>http://theerlangelist.com//article/why_elixir</link><description><![CDATA[<h1>Why Elixir</h1>
<h4 class="right">2014-01-21</h4>

<div class="article-body">
<p>
It’s been about a year since I’ve started using Elixir. Originally, I intended to use the language only for blogging purposes, thinking it could help me better illustrate benefits of Erlang Virtual Machine (EVM). However, I was immediately fascinated with what the language brings to the table, and very quickly introduced it to the Erlang based production system I have been developing at the time. Today, I consider Elixir as a better alternative for the development of EVM powered systems, and in this posts I’ll try to highlight some of its benefits, and also dispell some misconceptions about it.</p>
<h2>
The problems of Erlang the language</h2>
<p>
EVM has many benefits that makes it easier to build highly-available, scalable, fault-tolerant, distributed systems. There are various testimonials on the Internet, and I’ve blogged a bit about some advantages of Erlang <a href="http://theerlangelist.com/2012/12/yet-another-introduction-to-erlang.html">here</a> and <a href="http://www.theerlangelist.com/2013/01/erlang-based-server-systems.html">here</a>, and the chapter 1 of my upcoming book <a href="https://www.manning.com/books/elixir-in-action-second-edition?a_aid=sjuric">Elixir in Action</a> presents benefits of both Erlang and Elixir.</p>
<p>
Long story short, Erlang provides excellent abstractions for managing highly-scalable, fault-tolerant systems, which is particularly useful in concurrent systems, where many independent or loosely-dependent tasks must be performed. I’ve been using Erlang in production for more than three years, to build a long-polling based HTTP push server that in peak time serves over 2000 reqs/sec (non-cached). Never before have I written anything of this scale nor have I ever developed something this stable. The service just runs happily, without me thinking about it. This was actually my first Erlang code, bloated with anti-patterns, and bad approaches. And still, EVM proved to be very resilient, and run the code as best as it could. Most importantly, it was fairly straightforward for me to work on the complex problem, mostly owing to Erlang concurrency mechanism.</p>
<p>
However, despite some great properties, I never was (and I’m still not) quite comfortable programming in Erlang. The coding experience somehow never felt very fluent, and the resulting code was always burdened with excessive boilerplate and duplication. <strong>The problem was not the language syntax</strong>. I did a little Prolog back in my student days, and I liked the language a lot. By extension, I also like Erlang syntax, and actually think it is in many ways nicer and more elegant than Elixir. And this is coming from an OO developer who spent most of his coding time in languages such as Ruby, JavaScript, C# and C++.</p>
<p>
The problem I have with Erlang is that the language is somehow too simple, making it very hard to eliminate boilerplate and structural duplication. Conversely, the resulting code gets a bit messy, being harder to write, analyze, and modify. After coding in Erlang for some time, I thought that functional programming is inferior to OO, when it comes to efficient code organization.</p>
<h2>
What Elixir is (not)</h2>
<p>
This is where Elixir changed my opinion. After I’ve spent enough time with the language, I was finally able to see benefits and elegance of functional programming more clearly. Now I can’t say anymore that I prefer OO to FP. I find the coding experience in Elixir much more pleasant, and I’m able to concentrate on the problem I’m solving, instead of dealing with the language’s shortcomings.</p>
<p>
Before discussing some benefits of Elixir, there is an important thing I’d like to stress: <strong>Elixir is not Ruby for Erlang</strong>. It is also not CoffeeScript, Clojure, C++ or something else for Erlang. Relationship between Elixir and Erlang is unique, with Elixir being often semantically very close to Erlang, but in addition bringing many ideas from different languages. The end result may on surface look like Ruby, but I find it much more closer to Erlang, with both languages completely sharing the type system, and taking the same functional route.</p>
<p>
So what is Elixir? To me, it is an Erlang-like language with improved code organization capabilities. This definition differs from what you’ll see on the official page, but I think it captures the essence of Elixir, when compared to Erlang.</p>
<p>
Let me elaborate on this. In my opinion, a programming language has a couple of roles:</p>
<ul>
  <li>
It serves as an interface that allows programmers to control something, e.g. a piece of hardware, a virtual machine, a running application, UI layout, …  </li>
  <li>
It shapes the way developers think about the world they’re modeling. An OO language will make us look for entities with state and behavior, while in FP language we’ll think about data and transformations. A declarative programming language will force us to think about rules, while in imperative language we’ll think more about sequence of actions.  </li>
  <li>
It provides tools to organize the code, remove duplications, boilerplate, noise, and hopefully model the problem as closely as possible to the way we understand it.  </li>
</ul>
<p>
Erlang and Elixir are completely identical in first two roles - they target the same “thing” (EVM), and they both take a functional approach. It is in role three where Elixir improves on Erlang, and gives us additional tools to organize our code, and hopefully be more efficient in writing production-ready, maintainable code.</p>
<h2>
Ingredients</h2>
<p>
Much has been said about Elixir on the Internet, but I especially like two articles from Devin Torres which you can find <a href="https://devinus.io/the-excitement-of-elixir/">here</a> and <a href="https://devinus.io/elixir-its-not-about-syntax/">here</a>. Devin is an experienced Erlang developer, who among other things wrote a popular <a href="https://github.com/devinus/poolboy">poolboy</a> library, so it’s worth reading what he thinks about Elixir.</p>
<p>
I’ll try not to repeat much, and avoid going into many mechanical details. Instead, let’s do a brief tour of main tools that can be used for better code organization.</p>
<h3>
Metaprogramming</h3>
<p>
Metaprogramming in Elixir comes in a couple of flavors, but the essence is the same. It allows us to write concise constructs that seems as if they’re a part of the language. These constructs are in compile-time then transformed into a proper code. On a mechanical level, it helps us remove structural duplication - a case where two pieces of code share the same abstract pattern, but they differ in many mechanical details.</p>
<p>
For example, a following snippet presents a sketch of a module models a <code class="inline">User</code> record:</p>
<pre><code class="highlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">User</span><span class="w"> </span><span class="k" data-group-id="3341369101-1">do</span><span class="w">
  </span><span class="c1">#initializer</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">new</span><span class="p" data-group-id="3341369101-2">(</span><span class="n">data</span><span class="p" data-group-id="3341369101-2">)</span><span class="w"> </span><span class="k" data-group-id="3341369101-3">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="3341369101-3">end</span><span class="w">

  </span><span class="c1"># getters</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">name</span><span class="p" data-group-id="3341369101-4">(</span><span class="n">user</span><span class="p" data-group-id="3341369101-4">)</span><span class="w"> </span><span class="k" data-group-id="3341369101-5">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="3341369101-5">end</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">age</span><span class="p" data-group-id="3341369101-6">(</span><span class="n">user</span><span class="p" data-group-id="3341369101-6">)</span><span class="w"> </span><span class="k" data-group-id="3341369101-7">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="3341369101-7">end</span><span class="w">

  </span><span class="c1"># setters</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">name</span><span class="p" data-group-id="3341369101-8">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p" data-group-id="3341369101-8">)</span><span class="w"> </span><span class="k" data-group-id="3341369101-9">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="3341369101-9">end</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">age</span><span class="p" data-group-id="3341369101-10">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p" data-group-id="3341369101-10">)</span><span class="w"> </span><span class="k" data-group-id="3341369101-11">do</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="3341369101-11">end</span><span class="w">
</span><span class="k" data-group-id="3341369101-1">end</span></code></pre>
<p>
Some other type of record will follow this pattern, but contain different fields. Instead of copy-pasting this pattern, we can use Elixir <code class="inline">defrecord</code> macro:</p>
<pre><code class="highlight makeup elixir"><span class="n">defrecord</span><span class="w"> </span><span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span></code></pre>
<p>
Based on the given definition, <code class="inline">defrecord</code> generates a dedicated module that contains utility functions for manipulating our <code class="inline">User</code> record. Thus, the common pattern is stated only in one place (the code of <code class="inline">defrecord</code> macro), while the particular logic is relieved of mechanical implementation details.</p>
<p>
Elixir macros are nothing like C/C++ macros. Instead of working on strings, they are something like compile-time Elixir functions that are called in the middle of parsing, and work on the abstract syntax tree (AST), which is a code represented as Elixir data structure. Macro can work on AST, and spit out some alternative AST that represents the generated code. Consequently, macros are executed in compile-time, so once we come to runtime, the performance is not affected, and there are no surprise situations where some piece of code can change the definition of a module (which is possible for example in JavaScript or Ruby).</p>
<p>
Owing to macros, most of Elixir, is actually implemented in Elixir, including constructs such as <code class="inline">if</code>, <code class="inline">unless</code>, or unit testing support. Unicode support works by reading UnicodeData.txt file, and generating the corresponding implementation of Unicode aware string function such as <code class="inline">downcase</code> or <code class="inline">upcase</code>. This in turn makes it easier for developers to contribute to Elixir.</p>
<p>
Macros also allow 3rd party library authors to provide internal DSLs that naturally fit in language. <a href="https://github.com/elixir-lang/ecto">Ecto</a> project, that provides embedded integrated queries, something like LINQ for Elixir, is my personal favorite that really showcases the power of macros.</p>
<p>
I’ve seen people sometimes dismissing Elixir, stating they don’t need metaprogramming capabilities. While extremely useful, metaprogramming can also become very dangerous tool, and it is advised to carefully consider their usage. That said, there are many features that are powered by metaprogramming, and even if you don’t write macros yourself, you’ll still probably enjoy many of these features, such as aforementioned records, Unicode support, or integrated query language.</p>
<h3>
Pipeline operator</h3>
<p>
This seemingly simple operator is so useful, I “invented” its <a href="https://github.com/sasa1977/fun_chain">Erlang equivalent</a> even before I was aware it exists in Elixir (or other languages for that matter).</p>
<p>
Let’s see the problem first. In Erlang, there is no pipeline operator, and furthermore, we can’t reassign variables. Therefore, typical Erlang code will often be written with following pattern:</p>
<pre><code class="erlang">State1 = trans_1(State),
State2 = trans_2(State1),
State3 = trans_3(State2),
...</code></pre>
<p>
This is a very clumsy code that relies on intermediate variables, and correct passing of the last result to the next call. I actually had a nasty bug because I accidentally used <code class="inline">State6</code> in one place instead of <code class="inline">State7</code>.</p>
<p>
Of course, we can go around by inlining function calls:</p>
<pre><code class="erlang">trans_3(
  trans_2(
    trans_1(State)
  )
)</code></pre>
<p>
As you can see, this code can soon get ugly, and the problem is often aggravated when transformation functions receive additional arguments, and the number of transformation increases.</p>
<p>
The pipeline operator makes it possible to combine various operations without using intermediate variables:</p>
<pre><code class="highlight makeup elixir"><span class="n">state</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">trans_1</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">trans_2</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">trans_3</span></code></pre>
<p>
The code reads like the prose, from top to bottom, and highlights one of the strengths of FP, where we treat functions as data transformers that are combined in various ways to achieve the desired result.</p>
<p>
For example, the following code computes the sum of squares of all positive numbers of a list:</p>
<pre><code class="highlight makeup elixir"><span class="n">list</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="1700912354-1">(</span><span class="o">&amp;</span><span class="p" data-group-id="1700912354-2">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="1700912354-2">)</span><span class="p" data-group-id="1700912354-1">)</span><span class="w">       </span><span class="c1"># take positive numbers</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="1700912354-3">(</span><span class="o">&amp;</span><span class="p" data-group-id="1700912354-4">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="1700912354-4">)</span><span class="p" data-group-id="1700912354-3">)</span><span class="w">         </span><span class="c1"># square each one</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p" data-group-id="1700912354-5">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="1700912354-6">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;2</span><span class="p" data-group-id="1700912354-6">)</span><span class="p" data-group-id="1700912354-5">)</span><span class="w">   </span><span class="c1"># calculate sum</span></code></pre>
<p>
The pipeline operator works extremely well because the API in Elixir libraries follows the “subject (noun) as the first argument” convention. Unlike Erlang, Elixir takes the stance that all functions should take the thing they operate on as the first argument. So <code class="inline">String</code> module functions take string as the first argument, while <code class="inline">Enum</code> module functions take enumerable as the first argument.</p>
<h3>
Polymorphism via protocols</h3>
<p>
Protocols are the Elixir way of providing something roughly similar to OO interfaces. Initially, I wasn’t much impressed with them, but as the time progressed, I started seeing many benefits they bring. Protocols allow developers to create a generic logic that can be used with any type of data, assuming that some contract is implemented for the given data.</p>
<p>
An excellent example is the <a href="https://hexdocs.pm/elixir/Enum.html">Enum</a> module, that provides many useful functions for manipulating with anything that is enumerable. For example, this is how we iterate an enumerable:</p>
<pre><code class="highlight makeup elixir"><span class="nc">Enum</span><span class="o">.</span><span class="n">each</span><span class="p" data-group-id="7994075532-1">(</span><span class="n">enumerable</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="7994075532-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="k" data-group-id="7994075532-2">end</span><span class="p" data-group-id="7994075532-1">)</span></code></pre>
<p>
<code class="inline">Enum.each</code> works with different types such as lists, or key-value dictionaries, and of course we can add support for our own types by implementing corresponding protocol. This is resemblant of OO interfaces, with an additional twist that it’s possible to implement a protocol for a type, even if you don’t own its source code.</p>
<p>
One of the best example of protocol usefulness is the <a href="https://hexdocs.pm/elixir/Stream.html">Stream</a> module, which implements a lazy, composable, enumerable abstraction. A stream makes it possible to compose various enumerable transformations, and then generate the result only when needed, by feeding the stream to some function from the <code class="inline">Enum</code> module. For example, here’s the code that computes the sum of squares of all positive numbers of a list in a single pass:</p>
<pre><code class="highlight makeup elixir"><span class="n">list</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Stream</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="8120445192-1">(</span><span class="o">&amp;</span><span class="p" data-group-id="8120445192-2">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="8120445192-2">)</span><span class="p" data-group-id="8120445192-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Stream</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="8120445192-3">(</span><span class="o">&amp;</span><span class="p" data-group-id="8120445192-4">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="8120445192-4">)</span><span class="p" data-group-id="8120445192-3">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p" data-group-id="8120445192-5">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="8120445192-6">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ni">&amp;2</span><span class="p" data-group-id="8120445192-6">)</span><span class="p" data-group-id="8120445192-5">)</span><span class="w">   </span><span class="c1"># Entire iteration happens here in a single pass</span></code></pre>
<p>
In lines 2 and 3, operations are composed, but not yet executed. The result is a specification descriptor that implements an <code class="inline">Enumerable</code> protocol. Once we feed this descriptor to some <code class="inline">Enum</code> function (line 3), it starts producing values. Other than supporting protocol mechanism, there is no special laziness support from Elixir compiler.</p>
<h3>
The mix tool</h3>
<p>
The final important piece of puzzle is the tool that help us manage projects. Elixir comes bundled with the <code class="inline">mix</code> tool that does exactly that. This is again done in an impressively simple manner. When you create a new project, only 7 files are created (including .gitignore and README.md) on the disk. And this is all it takes to create a proper OTP application. It’s an excellent example of how far can things be simplified, by hiding necessary boilerplate and bureaucracy in the generic abstraction.</p>
<p>
Mix tool supports various other tasks, such as dependency management. The tool is also extensible, so you can create your own specific tasks as needed.</p>
<h3>
Syntactical changes</h3>
<p>
The list doesn’t stop here, and there are many other benefits Elixir gives us. Many of these do include syntactical changes from Erlang, such as support for variable rebinding, optional parentheses, implicit statement endings, nullability, short circuits operators, …</p>
<p>
Admittedly, some ambiguity is introduced due to optional parentheses, as illustrated in this example:</p>
<pre><code class="highlight makeup elixir"><span class="n">abs</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w">    </span><span class="c1"># same as abs(-1 + 5)</span></code></pre>
<p>
However, I use parentheses (except for macros and zero arg functions), so I can’t remember experiencing this problem in practice.</p>
<p>
In general, I like many of the decision made in this department. It’s nice to be able to write <code class="inline">if</code> without obligatory <code class="inline">else</code>. It’s also nice that I don’t have to consciously think which character must I use to end the statement.</p>
<p>
Even optional parentheses are good, as they support DSL-ish usage of macros, making the code less noisy. Without them, we would have to add parentheses when invoking macros:</p>
<pre><code class="highlight makeup elixir"><span class="n">defrecord</span><span class="w"> </span><span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">       </span><span class="c1"># without parentheses</span><span class="w">

</span><span class="n">defrecord</span><span class="p" data-group-id="6326300468-1">(</span><span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6326300468-2">[</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="6326300468-2">]</span><span class="p" data-group-id="6326300468-1">)</span><span class="w">    </span><span class="c1"># with parentheses</span></code></pre>
<p>
Still, I don’t find these enhancements to be of crucial importance. They are nice finishing touches, but if this was all Elixir had to offer, I’d probably still use pure Erlang.</p>
<h2>
Wrapping up</h2>
<p>
Much has been said in this article, and yet I feel that the magic of Elixir is far from being completely captured. The language preference is admittedly something subjective, but I feel that Elixir really improves on Erlang foundations. With more than three years of production level coding in Erlang, and about a year of using Elixir, I simply find Elixir experience to be much more pleasant. The resulting code seems more compact, and I can be more focused on the problem I’m solving, instead of wrestling with excessive noise and boilerplate.</p>
<p>
It is for similar reasons that I like EVM. The underlying concurrency mechanisms makes it radically easier for me to tackle complexity of a highly loaded server-side system that must constantly provide service and perform many simultaneous tasks.</p>
<p>
Both Elixir and EVM raise the abstraction bar, and help me tackle complex problems with greater ease. This is why I would always put my money behind Elixir/EVM combination as the tools of choice for building a server-side system. YMMV of course.</p>
</div>

<div class="article-footer">
  <div>
    <i>Copyright 2014, Saša Jurić. This article is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</i>
    <br/>
    <i>The article was first published on <a href="http://theerlangelist.com/article/why_elixir">The Erlangelist site</a>.</i>
    <br/>
    <i>The source of the article can be found <a href="https://github.com/sasa1977/erlangelist/tree/master/site/articles/why_elixir.md">here</a>.</i>

  </div>
</div>]]></description><pubDate>Tue, 21 Jan 2014 00:00:00 +0000</pubDate></item></channel></rss>