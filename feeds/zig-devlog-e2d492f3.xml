<?xml version="1.0" encoding="utf-8"?><rss version="2.0"><channel><title>Zig Devlog</title><link>https://raw.githubusercontent.com/xavwe/rss-aggregator/refs/heads/main/feeds/zig-devlog-e2d492f3.xml</link><description>Archived feed from https://ziglang.org/devlog/index.xml</description><item><title>zig libc</title><link>https://ziglang.org/devlog/2026/#2026-01-31</link><description><![CDATA[<div id="2026-01-31"><h1><a class="" href="#2026-01-31">zig libc</a></h1><p>Author: Andrew Kelley</p><p>Over the past month or so, several enterprising contributors have taken an interest in the <a href="https://codeberg.org/ziglang/zig/issues/30978" target="_blank">zig libc subproject</a>. The idea here is to incrementally delete redundant code, by providing libc functions as Zig standard library wrappers rather than as vendored C source files. In many cases, these functions are one-to-one mappings, such as <code>memcpy</code> or <code>atan2</code>, or trivially wrap a generic function, like <code>strnlen</code>:</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">strnlen</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">str</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="operator">*</span><span class="punctuation_delimiter">:</span><span class="number">0</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">c_char</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">max</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="keyword_modifier">callconv</span><span class="punctuation_bracket">(</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">c</span><span class="punctuation_bracket">)</span> <span class="type_builtin">usize</span> <span class="punctuation_bracket">{</span>
    <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">findScalar</span><span class="punctuation_bracket">(</span><span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span> <span class="function_builtin">@ptrCast</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">str</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="operator">..</span><span class="constant variable_builtin type variable">max</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span> <span class="number">0</span><span class="punctuation_bracket">)</span> <span class="keyword_operator">orelse</span> <span class="constant variable_builtin type variable">max</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>So far, roughly 250 C source files have been deleted from the Zig repository, with 2032 remaining.</p><p>With each function that makes the transition, Zig gains independence from third party projects and from the C programming language, compilation speed improves, Zig’s installation size is simplified and reduced, and user applications which statically link libc enjoy reduced binary size.</p><p>Additionally, a <a href="https://codeberg.org/ziglang/zig/pulls/31037" target="_blank">recent enhancement</a> now makes zig libc share the Zig Compilation Unit with other Zig code rather than being a separate static archive, linked together later. This is one of the advantages of Zig having an integrated compiler and linker. When the exported libc functions share the ZCU, redundant code is eliminated because functions can be optimized together. It’s kind of like enabling LTO (Link-Time Optimization) across the libc boundary, except it’s done properly in the frontend instead of too late, in the linker.</p><p>Furthermore, when this work is combined with the recent <a href="https://codeberg.org/ziglang/zig/issues/30150" target="_blank">std.Io changes</a>, there is potential for users to seamlessly control how libc performs I/O - for example forcing all calls to <code>read</code> and <code>write</code> to participate in an io_uring event loop, even though that code was not written with such use case in mind. Or, <a href="https://codeberg.org/ziglang/zig/pulls/30788" target="_blank">resource leak detection</a> could be enabled for third-party C code. For now this is only a vaporware idea which has not been experimented with, but the idea intrigues me.</p><p>Big thanks to Szabolcs Nagy for <a href="https://wiki.musl-libc.org/libc-test.html" target="_blank">libc-test</a>. This project has been a huge help in making sure that we don’t regress any math functions.</p><p>As a reminder to our users, now that Zig is transitioning to being the static libc provider, if you encounter issues with the musl, mingw-w64, or wasi-libc libc functionality provided by Zig, <strong>please file bug reports in Zig first</strong> so we don’t annoy maintainers for bugs that are in Zig, and no longer vendored by independent libc implementation projects.</p><p>Abolish ICE.</p></div>]]></description><pubDate>Sat, 31 Jan 2026 00:00:00 +0000</pubDate></item></channel></rss>