<?xml version="1.0" encoding="utf-8"?><rss version="2.0"><channel><title>Zig Devlog</title><link>https://raw.githubusercontent.com/xavwe/rss-aggregator/refs/heads/main/feeds/zig-devlog-e2d492f3.xml</link><description>Archived feed from https://ziglang.org/devlog/index.xml</description><item><title>Two Package Management Workflow Enhancements</title><link>https://ziglang.org/devlog/2026/#2026-02-06</link><description><![CDATA[<div id="2026-02-06"><h1><a class="" href="#2026-02-06">Two Package Management Workflow Enhancements</a></h1><p>Author: Andrew Kelley</p><p>If you have a Zig project with dependencies, two big changes just landed which I think you will be interested to learn about.</p><p>Fetched packages are now stored <em>locally</em> in the <code>zig-pkg</code> directory of the project root (next to your <code>build.zig</code> file).</p><p>For example here are a few results from <a href="https://codeberg.org/awebo-chat/awebo" target="_blank">awebo</a> after running <code>zig build</code>:</p><pre><code>$ du -sh zig-pkg/*
13M    freetype-2.14.1-alzUkTyBqgBwke4Jsot997WYSpl207Ij9oO-2QOvGrOi
20K    opus-0.0.2-vuF-cMAkAADVsm707MYCtPmqmRs0gzg84Sz0qGbb5E3w
4.3M   pulseaudio-16.1.1-9-mk_62MZkNwBaFwiZ7ZVrYRIf_3dTqqJR5PbMRCJzSuLw
5.2M   uucode-0.1.0-ZZjBPvtWUACf5dqD_f9I37VGFsN24436CuceC5pTJ25n
728K   vaxis-0.5.1-BWNV_AxECQCj3p4Hcv4U3Yo1WMUJ7Z2FUj0UkpuJGxQQ
</code></pre><p>It is highly recommended to add this directory to the project-local source control ignore file (e.g. <code>.gitignore</code>). However, by being outside of <code>.zig-cache</code>, it provides the possibility of distributing self-contained source tarballs, which contain all dependencies and therefore can be used to build offline, or for archival purposes.</p><p>Meanwhile, an <em>additional</em> copy of the dependency is cached globally. After filtering out all the unused files based on the <code>paths</code> filter, the contents are recompressed:</p><pre><code>$ du -sh ~/.cache/zig/p/*
2.4M    freetype-2.14.1-alzUkTyBqgBwke4Jsot997WYSpl207Ij9oO-2QOvGrOi.tar.gz
4.0K    opus-0.0.2-vuF-cMAkAADVsm707MYCtPmqmRs0gzg84Sz0qGbb5E3w.tar.gz
636K    pulseaudio-16.1.1-9-mk_62MZkNwBaFwiZ7ZVrYRIf_3dTqqJR5PbMRCJzSuLw.tar.gz
880K    uucode-0.1.0-ZZjBPvtWUACf5dqD_f9I37VGFsN24436CuceC5pTJ25n.tar.gz
120K    vaxis-0.5.1-BWNV_BFECQBbXeTeFd48uTJRjD5a-KD6kPuKanzzVB01.tar.gz
</code></pre><p>The motivation for this change is to make it easier to tinker. Go ahead and edit those files, see what happens. Swap out your package directory with a git clone. Grep your dependencies all together. Configure your IDE to auto-complete based on the <code>zig-pkg</code> directory. <a href="https://codeberg.org/awebo-chat/awebo/issues/61" target="_blank">Run baobab on your dependency tree</a>. Furthermore, by having the global cache have compressed files instead makes it easier to share that cached data between computers. In the future, <a href="https://github.com/ziglang/zig/issues/23236" target="_blank">it is planned to support peer-to-peer torrenting of dependency trees</a>. By recompressing packages into a canonical form, this will allow peers to share Zig packages with minimal bandwidth. I love this idea because it simultaneously provides resilience to network outages, as well as a popularity contest. Find out which open source packages are popular based on number of seeders!</p><p>The second change here is the addition of the <code>--fork</code> flag to <code>zig build</code>.</p><p>In retrospect, it seems so obvious, I donâ€™t know why I didnâ€™t think of it since the beginning. It looks like this:</p><pre><code>zig build --fork=[path]
</code></pre><p>This is a <strong>project override</strong> option. Given a path to a source checkout of a project, all packages matching that project across the entire dependency tree will be overridden.</p><p>Thanks to the fact that package content hashes include name and fingerprint, <strong>this resolves before the package is potentially fetched</strong>.</p><p>This is an easy way to temporarily use one or more forks which are in entirely separate directories. You can iterate on your entire dependency tree until everything is working, while using comfortably the development environment and source control of the dependency projects.</p><p>The fact that it is a CLI flag makes it appropriately ephemeral. The moment you drop the flags, youâ€™re back to using your pristine, fetched dependency tree.</p><p>If the project does not match, an error occurs, preventing confusion:</p><pre><code>$ zig build --fork=/home/andy/dev/mime
error: fork /home/andy/dev/mime matched no mime packages
$
</code></pre><p>If the project does match, you get a reminder that you are using a fork, preventing confusion:</p><pre><code>$ zig build --fork=/home/andy/dev/dvui
info: fork /home/andy/dev/dvui matched 1 (dvui) packages
...
</code></pre><p>This functionality is intended to enhance the workflow of dealing with ecosystem breakage. I already tried it a bit and found it to be quite pleasant to work with. The new workflow goes like this:</p><ol><li>Fail to build from source due to ecosystem breakage.</li><li>Tinker with <code>--fork</code> until your project works again. During this time you can use the actual upstream source control, test suite, <code>zig build test --watch -fincremental</code>, etc.</li><li>Now you have a new option: be selfish and just keep working on your own stuff, or you can proceed to submit your patches upstream.</li></ol><p>â€¦and you can probably skip the step where you switch your <code>build.zig.zon</code> to your fork unless you expect upstream to take a long time to merge your fixes.</p></div>]]></description><pubDate>Fri, 6 Feb 2026 00:00:00 +0000</pubDate></item><item><title>Bypassing Kernel32.dll for Fun and Nonprofit</title><link>https://ziglang.org/devlog/2026/#2026-02-03</link><description><![CDATA[<div id="2026-02-03"><h1><a class="" href="#2026-02-03">Bypassing Kernel32.dll for Fun and Nonprofit</a></h1><p>Author: Andrew Kelley</p><p>The Windows operating system provides a large ABI surface area for doing things in the kernel. However, not all ABIs are created equally. As Casey Muratori points out in his lecture, <a href="https://www.youtube.com/watch?v=5IUj1EZwpJY" target="_blank">The Only Unbreakable Law</a>, the organizational structure of software development teams has a direct impact on the structure of the software they produce.</p><p>The DLLs on Windows are organized into a heirarchy, with some of the APIs being high-level wrappers around lower-level ones. For example, whenever you call functions of <code>kernel32.dll</code>, ultimately, the actual work is done by <code>ntdll.dll</code>. You can observe this directly by using ProcMon.exe and examining stack traces.</p><p>What weâ€™ve learned empirically is that the ntdll APIs are generally well-engineered, reasonable, and powerful, but the kernel32 wrappers introduce unnecessary heap allocations, additional failure modes, unintentional CPU usage, and bloat.</p><p>This is why the Zig standard library policy is to <a href="https://codeberg.org/ziglang/zig/issues/31131" target="_blank">Prefer the Native API over Win32</a>. Weâ€™re not quite there yet - we have plenty of calls into kernel32 remaining - but weâ€™ve taken great strides recently. Iâ€™ll give you two examples.</p><h2>Example 1: Entropy</h2><p>According to the official documentation, Windows does not have a straightforward way to get random bytes.</p><p><a href="https://github.com/rust-random/rand/issues/111" target="_blank">Many projects including Chromium, boringssl, Firefox, and Rust</a> call <code>SystemFunction036</code> from <code>advapi32.dll</code> because it worked on versions older than Windows 8.</p><p>Unfortunately, starting with Windows 8, the first time you call this function, it dynamically loads <code>bcryptprimitives.dll</code> and calls <a href="https://learn.microsoft.com/en-us/windows/win32/seccng/processprng" target="_blank">ProcessPrng</a>. If loading the DLL fails (for example due to an overloaded system, which we have observed on Zig CI several times), it returns error 38 (from a function that has <code>void</code> return type and is documented to never fail).</p><p>The first thing <code>ProcessPrng</code> does is heap allocate a small, constant number of bytes. If this fails it returns <code>NO_MEMORY</code> in a <code>BOOL</code> (documented behavior is to never fail, and always return <code>TRUE</code>).</p><p><code>bcryptprimitives.dll</code> apparently also runs a test suite every time you load it.</p><p>All that <code>ProcessPrng</code> is <em>really</em> doing is <code>NtOpenFile</code> on <code>&quot;\\Device\\CNG&quot;</code> and reading 48 bytes with <code>NtDeviceIoControlFile</code> to get a seed, and then initializing a per-CPU AES-based CSPRNG.</p><p>So the dependency on <code>bcryptprimitives.dll</code> and <code>advapi32.dll</code> can both be avoided, and the nondeterministic failure and latencies on first RNG read can also be avoided.</p><h2>Example 2: NtReadFile and NtWriteFile</h2><p><code>ReadFile</code> looks like this:</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_modifier">extern</span> <span class="string">&quot;kernel32&quot;</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">ReadFile</span><span class="punctuation_bracket">(</span>
    <span class="constant variable_builtin variable_parameter variable type">hFile</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">HANDLE</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">lpBuffer</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">LPVOID</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">nNumberOfBytesToRead</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">DWORD</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">lpNumberOfBytesRead</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="constant variable_builtin type variable">DWORD</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">lpOverlapped</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="constant variable_builtin type variable">OVERLAPPED</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">)</span> <span class="keyword_modifier">callconv</span><span class="punctuation_bracket">(</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">winapi</span><span class="punctuation_bracket">)</span> <span class="constant variable_builtin type variable">BOOL</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p><code>NtReadFile</code> looks like this:</p><pre><code class="zig"><span class="keyword_modifier">pub</span> <span class="keyword_modifier">extern</span> <span class="string">&quot;ntdll&quot;</span> <span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">NtReadFile</span><span class="punctuation_bracket">(</span>
    <span class="constant variable_builtin variable_parameter variable type">FileHandle</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">HANDLE</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">Event</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="constant variable_builtin type variable">HANDLE</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">ApcRoutine</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">IO_APC_ROUTINE</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">ApcContext</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="type_builtin">anyopaque</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">IoStatusBlock</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="constant variable_builtin type variable">IO_STATUS_BLOCK</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">Buffer</span><span class="punctuation_delimiter">:</span> <span class="operator">*</span><span class="type_builtin">anyopaque</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">Length</span><span class="punctuation_delimiter">:</span> <span class="constant variable_builtin type variable">ULONG</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">ByteOffset</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">LARGE_INTEGER</span><span class="punctuation_delimiter">,</span>
    <span class="constant variable_builtin variable_parameter variable type">Key</span><span class="punctuation_delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">ULONG</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">)</span> <span class="keyword_modifier">callconv</span><span class="punctuation_bracket">(</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">winapi</span><span class="punctuation_bracket">)</span> <span class="constant variable_builtin type variable">NTSTATUS</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>As a reminder, <em>the above function is implemented by calling the below function</em>.</p><p>Already we can see some nice things about using the lower level API. For instance, the <em>real</em> API simply gives us the error code as the return value, while the kernel32 wrapper hides the status code somewhere, returns a <code>BOOL</code> and then requires you to call <code>GetLastError</code> to find out what went wrong. Imagine! Returning a value from a function ðŸŒˆ</p><p>Furthermore, <code>OVERLAPPED</code> is a fake type. The Windows kernel doesnâ€™t actually know or care about it at all! The actual primitives here are events, APCs, and <code>IO_STATUS_BLOCK</code>.</p><p>If you have a synchronous file handle, then <code>Event</code> and <code>ApcRoutine</code> must be <code>null</code>. You get the answer in the <code>IO_STATUS_BLOCK</code> immediately. If you pass an APC routine here then some old bitrotted 32-bit code runs and you get garbage results.</p><p>On the other hand if you have an asynchronous file handle, then you need to either use an <code>Event</code> or an <code>ApcRoutine</code>. <code>kernel32.dll</code> uses events, which means that itâ€™s doing extra, unnecessary resource allocation and management just to read from a file. Instead, Zig now passes an APC routine and then calls <code>NtDelayExecution</code>. This integrates seamlessly with cancelation, making it possible to cancel tasks while they perform file I/O, regardless of whether the file was opened in synchronous mode or asynchronous mode.</p><p>For a deeper dive into this topic, please refer to this issue:</p><p><a href="https://codeberg.org/ziglang/zig/issues/31131" target="_blank">Windows: Prefer the Native API over Win32</a></p></div>]]></description><pubDate>Tue, 3 Feb 2026 00:00:00 +0000</pubDate></item><item><title>zig libc</title><link>https://ziglang.org/devlog/2026/#2026-01-31</link><description><![CDATA[<div id="2026-01-31"><h1><a class="" href="#2026-01-31">zig libc</a></h1><p>Author: Andrew Kelley</p><p>Over the past month or so, several enterprising contributors have taken an interest in the <a href="https://codeberg.org/ziglang/zig/issues/30978" target="_blank">zig libc subproject</a>. The idea here is to incrementally delete redundant code, by providing libc functions as Zig standard library wrappers rather than as vendored C source files. In many cases, these functions are one-to-one mappings, such as <code>memcpy</code> or <code>atan2</code>, or trivially wrap a generic function, like <code>strnlen</code>:</p><pre><code class="zig"><span class="keyword_function">fn</span> <span class="constant variable_builtin type variable function">strnlen</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin variable_parameter variable type">str</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="operator">*</span><span class="punctuation_delimiter">:</span><span class="number">0</span><span class="punctuation_bracket">]</span><span class="keyword">const</span> <span class="constant variable_builtin type variable">c_char</span><span class="punctuation_delimiter">,</span> <span class="constant variable_builtin variable_parameter variable type">max</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> <span class="keyword_modifier">callconv</span><span class="punctuation_bracket">(</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable">c</span><span class="punctuation_bracket">)</span> <span class="type_builtin">usize</span> <span class="punctuation_bracket">{</span>
    <span class="keyword_return">return</span> <span class="constant variable_builtin type variable">std</span><span class="punctuation_delimiter">.</span><span class="constant variable_builtin type variable_member variable">mem</span><span class="punctuation_delimiter">.</span><span class="type constant variable_builtin function_call variable_member variable">findScalar</span><span class="punctuation_bracket">(</span><span class="type_builtin">u8</span><span class="punctuation_delimiter">,</span> <span class="function_builtin">@ptrCast</span><span class="punctuation_bracket">(</span><span class="constant variable_builtin type variable">str</span><span class="punctuation_bracket">[</span><span class="number">0</span><span class="operator">..</span><span class="constant variable_builtin type variable">max</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span> <span class="number">0</span><span class="punctuation_bracket">)</span> <span class="keyword_operator">orelse</span> <span class="constant variable_builtin type variable">max</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<p>So far, roughly 250 C source files have been deleted from the Zig repository, with 2032 remaining.</p><p>With each function that makes the transition, Zig gains independence from third party projects and from the C programming language, compilation speed improves, Zigâ€™s installation size is simplified and reduced, and user applications which statically link libc enjoy reduced binary size.</p><p>Additionally, a <a href="https://codeberg.org/ziglang/zig/pulls/31037" target="_blank">recent enhancement</a> now makes zig libc share the Zig Compilation Unit with other Zig code rather than being a separate static archive, linked together later. This is one of the advantages of Zig having an integrated compiler and linker. When the exported libc functions share the ZCU, redundant code is eliminated because functions can be optimized together. Itâ€™s kind of like enabling LTO (Link-Time Optimization) across the libc boundary, except itâ€™s done properly in the frontend instead of too late, in the linker.</p><p>Furthermore, when this work is combined with the recent <a href="https://codeberg.org/ziglang/zig/issues/30150" target="_blank">std.Io changes</a>, there is potential for users to seamlessly control how libc performs I/O - for example forcing all calls to <code>read</code> and <code>write</code> to participate in an io_uring event loop, even though that code was not written with such use case in mind. Or, <a href="https://codeberg.org/ziglang/zig/pulls/30788" target="_blank">resource leak detection</a> could be enabled for third-party C code. For now this is only a vaporware idea which has not been experimented with, but the idea intrigues me.</p><p>Big thanks to Szabolcs Nagy for <a href="https://wiki.musl-libc.org/libc-test.html" target="_blank">libc-test</a>. This project has been a huge help in making sure that we donâ€™t regress any math functions.</p><p>As a reminder to our users, now that Zig is transitioning to being the static libc provider, if you encounter issues with the musl, mingw-w64, or wasi-libc libc functionality provided by Zig, <strong>please file bug reports in Zig first</strong> so we donâ€™t annoy maintainers for bugs that are in Zig, and no longer vendored by independent libc implementation projects.</p><p>The very same day I sat at home writing this devlog like a coward, less than five miles away, <a href="https://www.kptv.com/2026/01/31/live-labor-unions-rally-march-portland-ice-facility-protest/" target="_blank">armed forces who are in my city against the will of our elected officials shot tear gas, unprovoked, at peaceful protestors</a>. Next time I hope to have the courage to join my neighbors, and I hope to not get shot like <a href="https://en.wikipedia.org/wiki/Killing_of_Alex_Pretti" target="_blank">Alex Pretti</a> and <a href="https://en.wikipedia.org/wiki/Killing_of_Ren%C3%A9e_Good" target="_blank">RenÃ©e Good</a>.</p></div>]]></description><pubDate>Sat, 31 Jan 2026 00:00:00 +0000</pubDate></item></channel></rss>